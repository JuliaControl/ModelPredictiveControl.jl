<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Predictive Controllers · ModelPredictiveControl.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelPredictiveControl.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../manual/">Manual</a></li><li><span class="tocitem">Functions</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox" checked/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Public</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../sim_model/">Plant Models</a></li><li><a class="tocitem" href="../state_estim/">State Estimators</a></li><li class="is-active"><a class="tocitem" href>Predictive Controllers</a><ul class="internal"><li><a class="tocitem" href="#PredictiveController"><span>PredictiveController</span></a></li><li><a class="tocitem" href="#LinMPC"><span>LinMPC</span></a></li><li><a class="tocitem" href="#NonLinMPC"><span>NonLinMPC</span></a></li><li><a class="tocitem" href="#Set-Constraint"><span>Set Constraint</span></a></li><li><a class="tocitem" href="#Move-Manipulated-Input"><span>Move Manipulated Input</span></a></li><li><a class="tocitem" href="#Get-Additional-Information"><span>Get Additional Information</span></a></li></ul></li><li><a class="tocitem" href="../generic_func/">Generic Functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../internals/sim_model/">Plant Models</a></li><li><a class="tocitem" href="../../internals/state_estim/">State Estimators</a></li><li><a class="tocitem" href="../../internals/predictive_control/">Predictive Controllers</a></li></ul></li></ul></li><li><a class="tocitem" href="../../func_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functions</a></li><li><a class="is-disabled">Public</a></li><li class="is-active"><a href>Predictive Controllers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Predictive Controllers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/franckgaga/ModelPredictiveControl.jl/blob/main/docs/src/public/predictive_control.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Predictive-Controllers"><a class="docs-heading-anchor" href="#Predictive-Controllers">Predictive Controllers</a><a id="Predictive-Controllers-1"></a><a class="docs-heading-anchor-permalink" href="#Predictive-Controllers" title="Permalink"></a></h1><ul><li><a href="#Predictive-Controllers">Predictive Controllers</a></li><li class="no-marker"><ul><li><a href="#PredictiveController">PredictiveController</a></li><li><a href="#LinMPC">LinMPC</a></li><li><a href="#NonLinMPC">NonLinMPC</a></li><li><a href="#Set-Constraint">Set Constraint</a></li><li><a href="#Move-Manipulated-Input">Move Manipulated Input</a></li><li><a href="#Get-Additional-Information">Get Additional Information</a></li></ul></li></ul><p>All the predictive controllers in this module rely on a state estimator to compute the predictions. The default <a href="#ModelPredictiveControl.LinMPC"><code>LinMPC</code></a> estimator is a <a href="../state_estim/#ModelPredictiveControl.SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a>, and <a href="#ModelPredictiveControl.NonLinMPC"><code>NonLinMPC</code></a>, an <a href="../state_estim/#ModelPredictiveControl.UnscentedKalmanFilter"><code>UnscentedKalmanFilter</code></a>. For simpler and more classical designs, an <a href="../state_estim/#ModelPredictiveControl.InternalModel"><code>InternalModel</code></a> structure is also available, that assumes by default that the current model mismatch estimation is constant in the future (same approach than dynamic matrix control, DMC).</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The nomenclature uses hats for the predictions (or estimations, for the state estimators) e.g. <span>$\mathbf{Ŷ}$</span> encompasses the future model outputs <span>$\mathbf{y}$</span> over the prediction horizon <span>$H_p$</span>.</p></div></div><h2 id="PredictiveController"><a class="docs-heading-anchor" href="#PredictiveController">PredictiveController</a><a id="PredictiveController-1"></a><a class="docs-heading-anchor-permalink" href="#PredictiveController" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelPredictiveControl.PredictiveController" href="#ModelPredictiveControl.PredictiveController"><code>ModelPredictiveControl.PredictiveController</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract supertype of all predictive controllers.</p><hr/><pre><code class="nohighlight hljs">(mpc::PredictiveController)(ry, d=Float64[]; kwargs...)</code></pre><p>Functor allowing callable <code>PredictiveController</code> object as an alias for <a href="#ModelPredictiveControl.moveinput!"><code>moveinput!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mpc = LinMPC(LinModel(tf(5, [2, 1]), 3), Nwt=[0], Hp=1000, Hc=1);

julia&gt; u = mpc([5]); round.(u, digits=3)
1-element Vector{Float64}:
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/franckgaga/ModelPredictiveControl.jl/blob/e815aa33b71a61dda97668b0efa50c57d8c77dff/src/predictive_control.jl#L1-L19">source</a></section></article><h2 id="LinMPC"><a class="docs-heading-anchor" href="#LinMPC">LinMPC</a><a id="LinMPC-1"></a><a class="docs-heading-anchor-permalink" href="#LinMPC" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelPredictiveControl.LinMPC" href="#ModelPredictiveControl.LinMPC"><code>ModelPredictiveControl.LinMPC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinMPC(model::LinModel; &lt;keyword arguments&gt;)</code></pre><p>Construct a linear predictive controller based on <a href="../sim_model/#ModelPredictiveControl.LinModel"><code>LinModel</code></a> <code>model</code>.</p><p>The controller minimizes the following objective function at each discrete time <span>$k$</span>:</p><p class="math-container">\[\min_{\mathbf{ΔU}, ϵ}    \mathbf{(R̂_y - Ŷ)}&#39; \mathbf{M}_{H_p} \mathbf{(R̂_y - Ŷ)}   
                       + \mathbf{(ΔU)}&#39;      \mathbf{N}_{H_c} \mathbf{(ΔU)}  
                       + \mathbf{(R̂_u - U)}&#39; \mathbf{L}_{H_p} \mathbf{(R̂_u - U)} 
                       + C ϵ^2\]</p><p>in which the weight matrices are repeated <span>$H_p$</span> or <span>$H_c$</span> times:</p><p class="math-container">\[\begin{aligned}
    \mathbf{M}_{H_p} &amp;= \text{diag}\mathbf{(M,M,...,M)}     \\
    \mathbf{N}_{H_c} &amp;= \text{diag}\mathbf{(N,N,...,N)}     \\
    \mathbf{L}_{H_p} &amp;= \text{diag}\mathbf{(L,L,...,L)}     
\end{aligned}\]</p><p>and with the following nomenclature:</p><table><tr><th style="text-align: left">VARIABLE</th><th style="text-align: left">DESCRIPTION</th><th style="text-align: left">SIZE</th></tr><tr><td style="text-align: left"><span>$H_p$</span></td><td style="text-align: left">prediction horizon (integer)</td><td style="text-align: left"><code>()</code></td></tr><tr><td style="text-align: left"><span>$H_c$</span></td><td style="text-align: left">control horizon (integer)</td><td style="text-align: left"><code>()</code></td></tr><tr><td style="text-align: left"><span>$\mathbf{ΔU}$</span></td><td style="text-align: left">manipulated input increments over <span>$H_c$</span></td><td style="text-align: left"><code>(nu*Hc,)</code></td></tr><tr><td style="text-align: left"><span>$\mathbf{Ŷ}$</span></td><td style="text-align: left">predicted outputs over <span>$H_p$</span></td><td style="text-align: left"><code>(ny*Hp,)</code></td></tr><tr><td style="text-align: left"><span>$\mathbf{U}$</span></td><td style="text-align: left">manipulated inputs over <span>$H_p$</span></td><td style="text-align: left"><code>(nu*Hp,)</code></td></tr><tr><td style="text-align: left"><span>$\mathbf{R̂_y}$</span></td><td style="text-align: left">predicted output setpoints over <span>$H_p$</span></td><td style="text-align: left"><code>(ny*Hp,)</code></td></tr><tr><td style="text-align: left"><span>$\mathbf{R̂_u}$</span></td><td style="text-align: left">predicted manipulated input setpoints over <span>$H_p$</span></td><td style="text-align: left"><code>(nu*Hp,)</code></td></tr><tr><td style="text-align: left"><span>$\mathbf{M}$</span></td><td style="text-align: left">output setpoint tracking weights</td><td style="text-align: left"><code>(ny*Hp, ny*Hp)</code></td></tr><tr><td style="text-align: left"><span>$\mathbf{N}$</span></td><td style="text-align: left">manipulated input increment weights</td><td style="text-align: left"><code>(nu*Hc, nu*Hc)</code></td></tr><tr><td style="text-align: left"><span>$\mathbf{L}$</span></td><td style="text-align: left">manipulated input setpoint tracking weights</td><td style="text-align: left"><code>(nu*Hp, nu*Hp)</code></td></tr><tr><td style="text-align: left"><span>$C$</span></td><td style="text-align: left">slack variable weight</td><td style="text-align: left"><code>()</code></td></tr><tr><td style="text-align: left"><span>$ϵ$</span></td><td style="text-align: left">slack variable for constraint softening</td><td style="text-align: left"><code>()</code></td></tr></table><p>The <span>$\mathbf{ΔU}$</span> vector includes the manipulated input increments <span>$\mathbf{Δu}(k+j) =  \mathbf{u}(k+j) - \mathbf{u}(k+j-1)$</span> from <span>$j=0$</span> to <span>$H_c-1$</span>, the <span>$\mathbf{Ŷ}$</span> vector,  the output predictions <span>$\mathbf{ŷ(k+j)}$</span> from <span>$j=1$</span> to <span>$H_p$</span>, and the <span>$\mathbf{U}$</span>  vector, the manipulated inputs <span>$\mathbf{u}(k+j)$</span> from <span>$j=0$</span> to <span>$H_p-1$</span>. The  manipulated input setpoint predictions <span>$\mathbf{R̂_u}$</span> are constant at <span>$\mathbf{r_u}$</span>.</p><p>This method uses the default state estimator, a <a href="../state_estim/#ModelPredictiveControl.SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a> with default arguments.</p><p><strong>Arguments</strong></p><ul><li><code>model::LinModel</code> : model used for controller predictions and state estimations.</li><li><code>Hp=10+nk</code>: prediction horizon <span>$H_p$</span>, <code>nk</code> is the number of delays in <code>model</code>.</li><li><code>Hc=2</code> : control horizon <span>$H_c$</span>.</li><li><code>Mwt=fill(1.0,model.ny)</code> : main diagonal of <span>$\mathbf{M}$</span> weight matrix (vector)</li><li><code>Nwt=fill(0.1,model.nu)</code> : main diagonal of <span>$\mathbf{N}$</span> weight matrix (vector)</li><li><code>Lwt=fill(0.0,model.nu)</code> : main diagonal of <span>$\mathbf{L}$</span> weight matrix (vector)</li><li><code>Cwt=1e5</code> : slack variable weight <span>$C$</span> (scalar), use <code>Cwt=Inf</code> for hard constraints only</li><li><code>ru=model.uop</code> : manipulated input setpoints <span>$\mathbf{r_u}$</span> (vector)</li><li><code>optim=JuMP.Model(OSQP.MathOptInterfaceOSQP.Optimizer)</code> : quadratic optimizer used in the predictive controller, provided as a <a href="https://jump.dev/JuMP.jl/stable/reference/models/#JuMP.Model"><code>JuMP.Model</code></a> (default to <a href="https://osqp.org/docs/parsers/jump.html"><code>OSQP.jl</code></a> optimizer)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 4);

julia&gt; mpc = LinMPC(model, Mwt=[0, 1], Nwt=[0.5], Hp=30, Hc=1)
LinMPC controller with a sample time Ts = 4.0 s, SteadyKalmanFilter estimator and:
 1 manipulated inputs u
 4 states x̂
 2 measured outputs ym
 0 unmeasured outputs yu
 0 measured disturbances d</code></pre><p><strong>Extended Help</strong></p><p>Manipulated inputs setpoints <span>$\mathbf{r_u}$</span> are not common but they can be interesting for over-actuated systems, when <code>nu &gt; ny</code> (e.g. prioritize solutions with lower economical  costs). The default <code>Lwt</code> value implies that this feature is disabled by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/franckgaga/ModelPredictiveControl.jl/blob/e815aa33b71a61dda97668b0efa50c57d8c77dff/src/controller/linmpc.jl#L73-L149">source</a></section><section><div><pre><code class="nohighlight hljs">LinMPC(estim::StateEstimator; &lt;keyword arguments&gt;)</code></pre><p>Use custom state estimator <code>estim</code> to construct <code>LinMPC</code>.</p><p><code>estim.model</code> must be a <a href="../sim_model/#ModelPredictiveControl.LinModel"><code>LinModel</code></a>. Else, a <a href="#ModelPredictiveControl.NonLinMPC"><code>NonLinMPC</code></a> is required. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; estim = KalmanFilter(LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 4), i_ym=[2]);

julia&gt; mpc = LinMPC(estim, Mwt=[0, 1], Nwt=[0.5], Hp=30, Hc=1)
LinMPC controller with a sample time Ts = 4.0 s, KalmanFilter estimator and:
 1 manipulated inputs u
 3 states x̂
 1 measured outputs ym
 1 unmeasured outputs yu
 0 measured disturbances d</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/franckgaga/ModelPredictiveControl.jl/blob/e815aa33b71a61dda97668b0efa50c57d8c77dff/src/controller/linmpc.jl#L153-L172">source</a></section></article><h2 id="NonLinMPC"><a class="docs-heading-anchor" href="#NonLinMPC">NonLinMPC</a><a id="NonLinMPC-1"></a><a class="docs-heading-anchor-permalink" href="#NonLinMPC" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelPredictiveControl.NonLinMPC" href="#ModelPredictiveControl.NonLinMPC"><code>ModelPredictiveControl.NonLinMPC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonLinMPC(model::SimModel; &lt;keyword arguments&gt;)</code></pre><p>Construct a nonlinear predictive controller based on <a href="../sim_model/#ModelPredictiveControl.SimModel"><code>SimModel</code></a> <code>model</code>.</p><p>Both <a href="../sim_model/#ModelPredictiveControl.NonLinModel"><code>NonLinModel</code></a> and <a href="../sim_model/#ModelPredictiveControl.LinModel"><code>LinModel</code></a> are supported (see Extended Help). The  controller minimizes the following objective function at each discrete time <span>$k$</span>:</p><p class="math-container">\[\min_{\mathbf{ΔU}, ϵ}    \mathbf{(R̂_y - Ŷ)}&#39; \mathbf{M}_{H_p} \mathbf{(R̂_y - Ŷ)}   
                       + \mathbf{(ΔU)}&#39;      \mathbf{N}_{H_c} \mathbf{(ΔU)}  
                       + \mathbf{(R̂_u - U)}&#39; \mathbf{L}_{H_p} \mathbf{(R̂_u - U)} 
                       + C ϵ^2  +  E J_E(\mathbf{U}_E, \mathbf{Ŷ}_E, \mathbf{D̂}_E)\]</p><p>See <a href="#ModelPredictiveControl.LinMPC"><code>LinMPC</code></a> for the variable definitions. The custom economic function <span>$J_E$</span> can penalizes solutions with high economic costs. Setting all the weights to 0 except <span>$E$</span>  creates a pure economic model predictive controller (EMPC). The arguments of <span>$J_E$</span> are  the manipulated inputs, the predicted outputs and measured disturbances from <span>$k$</span> to  <span>$k+H_p$</span> inclusively:</p><p class="math-container">\[    \mathbf{U}_E = \begin{bmatrix} \mathbf{U}      \\ \mathbf{u}(k+H_p-1)   \end{bmatrix}  \text{,} \qquad
    \mathbf{Ŷ}_E = \begin{bmatrix} \mathbf{ŷ}(k)   \\ \mathbf{Ŷ}            \end{bmatrix}  \text{,} \qquad
    \mathbf{D̂}_E = \begin{bmatrix} \mathbf{d}(k)   \\ \mathbf{D̂}            \end{bmatrix}\]</p><p>since <span>$H_c ≤ H_p$</span> implies that <span>$\mathbf{u}(k+H_p) = \mathbf{u}(k+H_p-1)$</span>. The vector <span>$\mathbf{D̂}$</span> includes the predicted measured disturbance over <span>$H_p$</span>.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Replace any of the 3 arguments with <code>_</code> if not needed (see <code>JE</code> default value below).</p></div></div><p>This method uses the default state estimator, an <a href="../state_estim/#ModelPredictiveControl.UnscentedKalmanFilter"><code>UnscentedKalmanFilter</code></a> with  default arguments. </p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>See Extended Help if you get an error like <code>MethodError: no method matching  Float64(::ForwardDiff.Dual)</code>.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>model::SimModel</code> : model used for controller predictions and state estimations.</li><li><code>Hp=10</code>: prediction horizon <span>$H_p$</span>.</li><li><code>Hc=2</code> : control horizon <span>$H_c$</span>.</li><li><code>Mwt=fill(1.0,model.ny)</code> : main diagonal of <span>$\mathbf{M}$</span> weight matrix (vector)</li><li><code>Nwt=fill(0.1,model.nu)</code> : main diagonal of <span>$\mathbf{N}$</span> weight matrix (vector)</li><li><code>Lwt=fill(0.0,model.nu)</code> : main diagonal of <span>$\mathbf{L}$</span> weight matrix (vector)</li><li><code>Cwt=1e5</code> : slack variable weight <span>$C$</span> (scalar), use <code>Cwt=Inf</code> for hard constraints only</li><li><code>Ewt=0.0</code> : economic costs weight <span>$E$</span> (scalar). </li><li><code>JE=(_,_,_)-&gt;0.0</code> : economic function <span>$J_E(\mathbf{U}_E, \mathbf{D̂}_E, \mathbf{Ŷ}_E)$</span>.</li><li><code>ru=model.uop</code> : manipulated input setpoints <span>$\mathbf{r_u}$</span> (vector)</li><li><code>optim=JuMP.Model(Ipopt.Optimizer)</code> : nonlinear optimizer used in the predictive   controller, provided as a <a href="https://jump.dev/JuMP.jl/stable/reference/models/#JuMP.Model"><code>JuMP.Model</code></a>  (default to <a href="https://github.com/jump-dev/Ipopt.jl"><code>Ipopt.jl</code></a> optimizer)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = NonLinModel((x,u,_)-&gt;0.5x+u, (x,_)-&gt;2x, 10, 1, 1, 1);

julia&gt; mpc = NonLinMPC(model, Hp=20, Hc=1, Cwt=1e6)
NonLinMPC controller with a sample time Ts = 10.0 s, UnscentedKalmanFilter estimator and:
 1 manipulated inputs u
 2 states x̂
 1 measured outputs ym
 0 unmeasured outputs yu
 0 measured disturbances d</code></pre><p><strong>Extended Help</strong></p><p><code>NonLinMPC</code> controllers based on <a href="../sim_model/#ModelPredictiveControl.LinModel"><code>LinModel</code></a> compute the predictions with matrix  algebra instead of a <code>for</code> loop. This feature can accelerate the optimization and is not  available in any other package, to my knowledge.</p><p>The optimizations rely on <a href="https://github.com/jump-dev/JuMP.jl"><code>JuMP.jl</code></a> automatic  differentiation (AD) to compute the objective and constraint derivatives. Optimizers  generally benefit from exact derivatives like AD. However, the <a href="../sim_model/#ModelPredictiveControl.NonLinModel"><code>NonLinModel</code></a> <code>f</code>  and <code>h</code> functions must be compatible with this feature. See <a href="https://jump.dev/JuMP.jl/stable/manual/nlp/#Automatic-differentiation">Automatic differentiation</a> for common mistakes when writing these functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/franckgaga/ModelPredictiveControl.jl/blob/e815aa33b71a61dda97668b0efa50c57d8c77dff/src/controller/nonlinmpc.jl#L77-L151">source</a></section><section><div><pre><code class="nohighlight hljs">NonLinMPC(estim::StateEstimator; &lt;keyword arguments&gt;)</code></pre><p>Use custom state estimator <code>estim</code> to construct <code>NonLinMPC</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = NonLinModel((x,u,_)-&gt;0.5x+u, (x,_)-&gt;2x, 10, 1, 1, 1);

julia&gt; estim = UnscentedKalmanFilter(model, σQ_int=[0.05]);

julia&gt; mpc = NonLinMPC(estim, Hp=20, Hc=1, Cwt=1e6)
NonLinMPC controller with a sample time Ts = 10.0 s, UnscentedKalmanFilter estimator and:
 1 manipulated inputs u
 2 states x̂
 1 measured outputs ym
 0 unmeasured outputs yu
 0 measured disturbances d</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/franckgaga/ModelPredictiveControl.jl/blob/e815aa33b71a61dda97668b0efa50c57d8c77dff/src/controller/nonlinmpc.jl#L155-L174">source</a></section></article><h2 id="Set-Constraint"><a class="docs-heading-anchor" href="#Set-Constraint">Set Constraint</a><a id="Set-Constraint-1"></a><a class="docs-heading-anchor-permalink" href="#Set-Constraint" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelPredictiveControl.setconstraint!" href="#ModelPredictiveControl.setconstraint!"><code>ModelPredictiveControl.setconstraint!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setconstraint!(mpc::PredictiveController; &lt;keyword arguments&gt;)</code></pre><p>Set the constraint parameters of <code>mpc</code> predictive controller.</p><p>The predictive controllers support both soft and hard constraints, defined by:</p><p class="math-container">\[\begin{alignat*}{3}
    \mathbf{u_{min}  - c_{u_{min}}}  ϵ &amp;≤ \mathbf{u}(k+j)  &amp;&amp;≤ \mathbf{u_{max}  + c_{u_{max}}}  ϵ &amp;&amp;\qquad j = 0, 1 ,..., H_c - 1 \\
    \mathbf{Δu_{min} - c_{Δu_{min}}} ϵ &amp;≤ \mathbf{Δu}(k+j) &amp;&amp;≤ \mathbf{Δu_{max} + c_{Δu_{max}}} ϵ &amp;&amp;\qquad j = 0, 1 ,..., H_c - 1 \\
    \mathbf{ŷ_{min}  - c_{ŷ_{min}}}  ϵ &amp;≤ \mathbf{ŷ}(k+j)  &amp;&amp;≤ \mathbf{ŷ_{max}  + c_{ŷ_{max}}}  ϵ &amp;&amp;\qquad j = 1, 2 ,..., H_p \\
\end{alignat*}\]</p><p>and also <span>$ϵ ≥ 0$</span>. All the constraint parameters are vector. Use <code>±Inf</code> values when there  is no bound. The constraint softness parameters <span>$\mathbf{c}$</span>, also called equal concern  for relaxation, are non-negative values that specify the softness of the associated bound.  Use <code>0.0</code> values for hard constraints. The predicted output constraints <span>$\mathbf{ŷ_{min}}$</span>  and <span>$\mathbf{ŷ_{max}}$</span> are soft by default.</p><p><strong>Arguments</strong></p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The default constraints are mentioned here for clarity but omitting a keyword argument  will not re-assign to its default value (defaults are set at construction only).</p></div></div><ul><li><code>umin=fill(-Inf,nu)</code> : manipulated input lower bounds <span>$\mathbf{u_{min}}$</span> </li><li><code>umax=fill(+Inf,nu)</code> : manipulated input upper bounds <span>$\mathbf{u_{max}}$</span> </li><li><code>Δumin=fill(-Inf,nu)</code> : manipulated input increment lower bounds <span>$\mathbf{Δu_{min}}$</span> </li><li><code>Δumax=fill(+Inf,nu)</code> : manipulated input increment upper bounds <span>$\mathbf{Δu_{max}}$</span> </li><li><code>ŷmin=fill(-Inf,ny)</code> : predicted output lower bounds <span>$\mathbf{ŷ_{min}}$</span> </li><li><code>ŷmax=fill(+Inf,ny)</code> : predicted output upper bounds <span>$\mathbf{ŷ_{max}}$</span> </li><li><code>c_umin=fill(0.0,nu)</code> : <code>umin</code> softness weights <span>$\mathbf{c_{u_{min}}}$</span> </li><li><code>c_umax=fill(0.0,nu)</code> : <code>umax</code> softness weights <span>$\mathbf{c_{u_{max}}}$</span> </li><li><code>c_Δumin=fill(0.0,nu)</code> : <code>Δumin</code> softness weights <span>$\mathbf{c_{Δu_{min}}}$</span> </li><li><code>c_Δumax=fill(0.0,nu)</code> : <code>Δumax</code> softness weights <span>$\mathbf{c_{Δu_{max}}}$</span> </li><li><code>c_ŷmin=fill(1.0,ny)</code> : <code>ŷmin</code> softness weights <span>$\mathbf{c_{ŷ_{min}}}$</span> </li><li><code>c_ŷmax=fill(1.0,ny)</code> : <code>ŷmax</code> softness weights <span>$\mathbf{c_{ŷ_{max}}}$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/franckgaga/ModelPredictiveControl.jl/blob/e815aa33b71a61dda97668b0efa50c57d8c77dff/src/predictive_control.jl#L52-L88">source</a></section></article><h2 id="Move-Manipulated-Input"><a class="docs-heading-anchor" href="#Move-Manipulated-Input">Move Manipulated Input</a><a id="Move-Manipulated-Input-1"></a><a class="docs-heading-anchor-permalink" href="#Move-Manipulated-Input" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelPredictiveControl.moveinput!" href="#ModelPredictiveControl.moveinput!"><code>ModelPredictiveControl.moveinput!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">moveinput!(
    mpc::PredictiveController, 
    ry, 
    d  = Float64[];
    R̂y = repeat(ry, mpc.Hp), 
    D̂  = repeat(d,  mpc.Hp), 
    ym = nothing
)</code></pre><p>Compute the optimal manipulated input value <code>u</code> for the current control period.</p><p>Solve the optimization problem of <code>mpc</code> <a href="#ModelPredictiveControl.PredictiveController"><code>PredictiveController</code></a> and return the  results <span>$\mathbf{u}(k)$</span>. Following the receding horizon principle, the algorithm discards  the optimal future manipulated inputs <span>$\mathbf{u}(k+1), \mathbf{u}(k+2),$</span>... The  arguments <code>ry</code> and <code>d</code> are current output setpoints <span>$\mathbf{r_y}(k)$</span> and measured  disturbances <span>$\mathbf{d}(k)$</span>. The predicted output setpoint <code>R̂y</code> and measured disturbances  <code>D̂</code> are defined as:</p><p class="math-container">\[    \mathbf{R̂_y} = \begin{bmatrix}
        \mathbf{r̂_y}(k+1)   \\
        \mathbf{r̂_y}(k+2)   \\
        \vdots              \\
        \mathbf{r̂_y}(k+H_p)
    \end{bmatrix}                   \qquad \text{and} \qquad
    \mathbf{D̂}   = \begin{bmatrix}
        \mathbf{d̂}(k+1)     \\
        \mathbf{d̂}(k+2)     \\
        \vdots              \\
        \mathbf{d̂}(k+H_p)
    \end{bmatrix}\]</p><p>They are assumed constant in the future by default, that is  <span>$\mathbf{r̂_y}(k+j) = \mathbf{r_y}(k)$</span> and <span>$\mathbf{d̂}(k+j) = \mathbf{d}(k)$</span> for <span>$j=1$</span> to <span>$H_p$</span>. Current measured outputs <code>ym</code> (keyword argument) are only required if  <code>mpc.estim</code> is a <a href="../state_estim/#ModelPredictiveControl.InternalModel"><code>InternalModel</code></a>.</p><p>See also <a href="#ModelPredictiveControl.LinMPC"><code>LinMPC</code></a>, <a href="#ModelPredictiveControl.NonLinMPC"><code>NonLinMPC</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mpc = LinMPC(LinModel(tf(5, [2, 1]), 3), Nwt=[0], Hp=1000, Hc=1);

julia&gt; u = moveinput!(mpc, [5]); round.(u, digits=3)
1-element Vector{Float64}:
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/franckgaga/ModelPredictiveControl.jl/blob/e815aa33b71a61dda97668b0efa50c57d8c77dff/src/predictive_control.jl#L199-L246">source</a></section></article><h2 id="Get-Additional-Information"><a class="docs-heading-anchor" href="#Get-Additional-Information">Get Additional Information</a><a id="Get-Additional-Information-1"></a><a class="docs-heading-anchor-permalink" href="#Get-Additional-Information" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelPredictiveControl.getinfo" href="#ModelPredictiveControl.getinfo"><code>ModelPredictiveControl.getinfo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getinfo(mpc::PredictiveController)</code></pre><p>Get additional information about <code>mpc</code> controller optimum.</p><p>Return the dictionary <code>info</code> with the additional information, and <code>sol_summary</code>, the optimizer solution summary that can be printed. The dictionary <code>info</code> has the following  fields:</p><ul><li><code>:ΔU</code> : optimal manipulated input increments over <code>Hc</code> <span>$(\mathbf{ΔU})$</span></li><li><code>:ϵ</code>  : optimal slack variable <span>$(ϵ)$</span></li><li><code>:J</code>  : objective value optimum <span>$(J)$</span></li><li><code>:U</code>  : optimal manipulated inputs over <code>Hp</code> <span>$(\mathbf{U})$</span></li><li><code>:u</code>  : current optimal manipulated input <span>$(\mathbf{u})$</span></li><li><code>:d</code>  : current measured disturbance <span>$(\mathbf{d})$</span></li><li><code>:D̂</code>  : predicted measured disturbances over <code>Hp</code> <span>$(\mathbf{D̂})$</span></li><li><code>:ŷ</code>  : current estimated output <span>$(\mathbf{ŷ})$</span></li><li><code>:Ŷ</code>  : predicted outputs over <code>Hp</code> <span>$(\mathbf{Ŷ = Ŷ_d + Ŷ_s})$</span></li><li><code>:Ŷd</code> : predicted deterministic output over <code>Hp</code> <span>$(\mathbf{Ŷ_d})$</span></li><li><code>:Ŷs</code> : predicted stochastic output over <code>Hp</code> <span>$(\mathbf{Ŷ_s})$</span></li><li><code>:R̂y</code> : predicted output setpoint over <code>Hp</code> <span>$(\mathbf{R̂_y})$</span></li><li><code>:R̂u</code> : predicted manipulated input setpoint over <code>Hp</code> <span>$(\mathbf{R̂_u})$</span></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mpc = LinMPC(LinModel(tf(5, [2, 1]), 3), Nwt=[0], Hp=1000, Hc=1);

julia&gt; u = moveinput!(mpc, [5]);

julia&gt; info, sol_summary = getinfo(mpc); round.(info[:Ŷ][end], digits=2)
5.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/franckgaga/ModelPredictiveControl.jl/blob/e815aa33b71a61dda97668b0efa50c57d8c77dff/src/predictive_control.jl#L266-L298">source</a></section><section><div><pre><code class="nohighlight hljs">getinfo(mpc::NonLinMPC)</code></pre><p>Invoke <a href="#ModelPredictiveControl.getinfo"><code>getinfo(::PredictiveController)</code></a> and add <code>:JE</code> the economic optimum <span>$J_E$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/franckgaga/ModelPredictiveControl.jl/blob/e815aa33b71a61dda97668b0efa50c57d8c77dff/src/controller/nonlinmpc.jl#L191-L195">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../state_estim/">« State Estimators</a><a class="docs-footer-nextpage" href="../generic_func/">Generic Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 12 May 2023 21:55">Friday 12 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
