var documenterSearchIndex = {"docs":
[{"location":"internals/predictive_control/#PredictiveController-Internals","page":"Predictive Controllers","title":"PredictiveController Internals","text":"","category":"section"},{"location":"internals/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"The prediction methodology of this module is mainly based on Maciejowski textbook [1].","category":"page"},{"location":"internals/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"[1]: Maciejowski, J. 2000, \"Predictive control : with constraints\", 1st ed., Prentice Hall,  ISBN 978-0201398236.","category":"page"},{"location":"internals/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"ModelPredictiveControl.init_deterpred\nModelPredictiveControl.init_ΔUtoU\nModelPredictiveControl.relaxU\nModelPredictiveControl.relaxΔU\nModelPredictiveControl.relaxŶ\nModelPredictiveControl.init_quadprog\nModelPredictiveControl.init_stochpred\nModelPredictiveControl.init_linconstraint\nModelPredictiveControl.getestimates!\nModelPredictiveControl.initpred!\nModelPredictiveControl.linconstraint!","category":"page"},{"location":"internals/predictive_control/#ModelPredictiveControl.init_deterpred","page":"Predictive Controllers","title":"ModelPredictiveControl.init_deterpred","text":"init_deterpred(model::LinModel, Hp, Hc)\n\nConstruct deterministic prediction matrices for LinModel model.\n\nThe linear model predictions are evaluated by :\n\nbeginaligned\n    mathbfY = mathbfE ΔU + mathbfG d(k) + mathbfJ D + mathbfK_d x_d(k) \n                                                  + mathbfQ u(k-1) + mathbfY_s     \n               = mathbfE ΔU + mathbfF\nendaligned\n\nwhere predicted outputs mathbfY, stochastic outputs mathbfY_s, and  measured disturbances mathbfD are from k + 1 to k + H_p. Input increments  mathbfΔU are from k to k + H_c - 1. Deterministic state estimates  mathbfx_d(k) are extracted from current estimates mathbfx_k-1(k) with getestimates!. Operating points on mathbfu, mathbfd and mathbfy  are omitted in above equations.\n\nExtended Help\n\nUsing the mathbfA B_u C B_d D_d matrices in model and the equation mathbfW_j = mathbfC ( _i=0^j mathbfA^i ) mathbfB_u, the prediction  matrices are computed by :\n\nbeginaligned\nmathbfE = beginbmatrix\nmathbfW_0       mathbf0          cdots  mathbf0              \nmathbfW_1       mathbfW_0      cdots  mathbf0              \nvdots               vdots              ddots  vdots                  \nmathbfW_H_p-1   mathbfW_H_p-2  cdots  mathbfW_H_p-H_c+1\nendbmatrix\n\nmathbfG = beginbmatrix\nmathbfCmathbfA^0 mathbfB_d      \nmathbfCmathbfA^1 mathbfB_d      \nvdots                                    \nmathbfCmathbfA^H_p-1 mathbfB_d\nendbmatrix\n\nmathbfJ = beginbmatrix\nmathbfD_d                               mathbf0                                 cdots  mathbf0    \nmathbfCmathbfA^0 mathbfB_d      mathbfD_d                               cdots  mathbf0    \nvdots                                     vdots                                     ddots  vdots       \nmathbfCmathbfA^H_p-2 mathbfB_d  mathbfCmathbfA^H_p-3 mathbfB_d  cdots  mathbfD_d\nendbmatrix\n\nmathbfK_d = beginbmatrix\nmathbfCmathbfA^0      \nmathbfCmathbfA^1      \nvdots                        \nmathbfCmathbfA^H_p-1\nendbmatrix\n\nmathbfQ = beginbmatrix\nmathbfW_0        \nmathbfW_1        \nvdots              \nmathbfW_H_p-1\nendbmatrix\nendaligned\n\nnote: Note\nStochastic predictions mathbfY_s are calculated separately (see  init_stochpred) and added to the mathbfF matrix to support internal  model structure and reduce NonLinMPC computational costs. That is also why the  prediction matrices are built on mathbfA B_u C B_d D_d instead of the  augmented model mathbfA B_u C B_d D_d.\n\n\n\n\n\nReturn empty matrices if model is not a LinModel\n\n\n\n\n\n","category":"function"},{"location":"internals/predictive_control/#ModelPredictiveControl.init_ΔUtoU","page":"Predictive Controllers","title":"ModelPredictiveControl.init_ΔUtoU","text":"init_ΔUtoU(nu, Hp, Hc, C, c_Umin, c_Umax)\n\nInit manipulated input increments to inputs conversion matrices.\n\nThe conversion from the input increments mathbfΔU to manipulated inputs over H_p  and H_c are calculated by:\n\nbeginaligned\nmathbfU = \n    mathbfU_H_p = mathbfS_H_p mathbfΔU + mathbfT_H_p mathbfu(k-1) \n    mathbfU_H_c = mathbfS_H_c mathbfΔU + mathbfT_H_c mathbfu(k-1)\nendaligned\n\n\n\n\n\n","category":"function"},{"location":"internals/predictive_control/#ModelPredictiveControl.relaxU","page":"Predictive Controllers","title":"ModelPredictiveControl.relaxU","text":"relaxU(C, c_Umin, c_Umax, S_Hp, S_Hc)\n\nAugment manipulated inputs constraints with slack variable ϵ for softening.\n\nDenoting the input increments augmented with the slack variable mathbfΔU = beginsmallmatrix mathbfΔU  ϵ endsmallmatrix, it returns the augmented conversion matrix mathbfS_H_p, similar to the one described at init_ΔUtoU. It also returns the mathbfA matrices for the inequality constraints:\n\nbeginbmatrix \n    mathbfA_U_min  \n    mathbfA_U_max \nendbmatrix mathbfΔU \nbeginbmatrix\n    - mathbfU_min + mathbfT_H_c mathbfu(k-1) \n    + mathbfU_max - mathbfT_H_c mathbfu(k-1)\nendbmatrix\n\n\n\n\n\n","category":"function"},{"location":"internals/predictive_control/#ModelPredictiveControl.relaxΔU","page":"Predictive Controllers","title":"ModelPredictiveControl.relaxΔU","text":"relaxΔU(C, c_ΔUmin, c_ΔUmax, ΔUmin, ΔUmax, N_Hc)\n\nAugment input increments constraints with slack variable ϵ for softening.\n\nDenoting the input increments augmented with the slack variable  mathbfΔU = beginsmallmatrix mathbfΔU  ϵ endsmallmatrix, it returns the augmented input increment weights mathbfN_H_c (that incorporate C). It also   returns the augmented constraints mathbfΔU_min and mathbfΔU_max and the  mathbfA matrices for the inequality constraints:\n\nbeginbmatrix \n    mathbfA_ΔU_min  \n    mathbfA_ΔU_max\nendbmatrix mathbfΔU \nbeginbmatrix\n    - mathbfΔU_min \n    + mathbfΔU_max\nendbmatrix\n\n\n\n\n\n","category":"function"},{"location":"internals/predictive_control/#ModelPredictiveControl.relaxŶ","page":"Predictive Controllers","title":"ModelPredictiveControl.relaxŶ","text":"relaxŶ(::LinModel, C, c_Ŷmin, c_Ŷmax, E)\n\nAugment linear output prediction constraints with slack variable ϵ for softening.\n\nDenoting the input increments augmented with the slack variable  mathbfΔU = beginsmallmatrix mathbfΔU  ϵ endsmallmatrix, it returns the  mathbfE matrix that appears in the linear model prediction equation  mathbfY = E ΔU + F, and the mathbfA matrices for the inequality constraints:\n\nbeginbmatrix \n    mathbfA_Y_min  \n    mathbfA_Y_max\nendbmatrix mathbfΔU \nbeginbmatrix\n    - mathbfY_min + mathbfF \n    + mathbfY_max - mathbfF \nendbmatrix\n\n\n\n\n\nReturn empty matrices if model is not a LinModel\n\n\n\n\n\n","category":"function"},{"location":"internals/predictive_control/#ModelPredictiveControl.init_quadprog","page":"Predictive Controllers","title":"ModelPredictiveControl.init_quadprog","text":"init_quadprog(model::LinModel, Ẽ, S_Hp, M_Hp, N_Hc, L_Hp)\n\nInit the quadratic programming optimization matrix P̃ and q̃.\n\nThe matrices appear in the quadratic general form :\n\n    J = min_mathbfΔU frac12mathbf(ΔU)P(ΔU) + mathbfq(ΔU) + p \n\nmathbfP is constant if the model and weights are linear and time invariant (LTI). The  vector mathbfq and scalar p need recalculation each control period k (see initpred! method). p does not impact the minima position. It is thus  useless at optimization but required to evaluate the minimal J value.\n\n\n\n\n\nReturn empty matrices if model is not a LinModel.\n\n\n\n\n\n","category":"function"},{"location":"internals/predictive_control/#ModelPredictiveControl.init_stochpred","page":"Predictive Controllers","title":"ModelPredictiveControl.init_stochpred","text":"init_stochpred(estim::StateEstimator, Hp)\n\nInit the stochastic prediction matrix Ks from estim estimator for predictive control.\n\nmathbfK_s is the prediction matrix of the stochastic model (composed exclusively of  integrators):\n\n    mathbfY_s = mathbfK_s x_s(k)\n\nThe stochastic predictions mathbfY_s are the integrator outputs from k+1 to  k+H_p. mathbfx_s(k) is extracted from current estimates mathbfx_k-1(k) with getestimates!. The method also returns an empty mathbfP_s matrix, since  it is useless except for InternalModel estimators.\n\n\n\n\n\ninit_stochpred(estim::InternalModel, Hp)\n\nInit the stochastic prediction matrices for InternalModel.\n\nKs and Ps matrices are defined as:\n\n    mathbfY_s = mathbfK_s x_s(k) + mathbfP_s y_s(k)\n\nCurrent stochastic outputs mathbfy_s(k) comprises the measured outputs  mathbfy_s^m(k) = mathbfy^m(k) - mathbfy_d^m(k) and unmeasured  mathbfy_s^u(k) = 0. See [2].\n\n[2]: Desbiens, A., D. Hodouin & É. Plamondon. 2000, \"Global predictive control : a unified control structure for decoupling setpoint tracking, feedforward compensation and  disturbance rejection dynamics\", IEE Proceedings - Control Theory and Applications,  vol. 147, no 4, https://doi.org/10.1049/ip-cta:20000443, p. 465–475, ISSN 1350-2379.\n\n\n\n\n\n","category":"function"},{"location":"internals/predictive_control/#ModelPredictiveControl.init_linconstraint","page":"Predictive Controllers","title":"ModelPredictiveControl.init_linconstraint","text":"init_linconstraint(model::LinModel, \n    A_Umin, A_Umax, A_ΔŨmin, A_ΔŨmax, A_Ŷmin, A_Ŷmax,\n    i_Umin, i_Umax, i_ΔŨmin, i_ΔŨmax, i_Ŷmin, i_Ŷmax\n)\n\nInit A, b and i_b for the linear inequality constraints (mathbfA ΔU  b).\n\ni_b is a BitVector including the indices of mathbfb that are finite numbers.\n\n\n\n\n\nInit values without predicted output constraints if model is not a LinModel.\n\n\n\n\n\n","category":"function"},{"location":"internals/predictive_control/#ModelPredictiveControl.getestimates!","page":"Predictive Controllers","title":"ModelPredictiveControl.getestimates!","text":"getestimates!(mpc::PredictiveController, estim::StateEstimator)\n\nGet estimator output and split x̂ into the deterministic x̂d and stochastic x̂s states.\n\n\n\n\n\ngetestimates!(mpc::PredictiveController, estim::InternalModel)\n\nGet the internal model deterministic estim.x̂d and stochastic estim.x̂s states.\n\n\n\n\n\n","category":"function"},{"location":"internals/predictive_control/#ModelPredictiveControl.initpred!","page":"Predictive Controllers","title":"ModelPredictiveControl.initpred!","text":"initpred!(mpc, model::LinModel, d, D̂, R̂y)\n\nInit linear model prediction matrices F, q̃ and p.\n\nSee init_deterpred and init_quadprog for the definition of the matrices.\n\n\n\n\n\ninitpred!(mpc::PredictiveController, model::SimModel, d, D̂, R̂y)\n\nInit d0 and D̂0 matrices when model is not a LinModel.\n\nd0 and D̂0 are the measured disturbances and its predictions without the operating points mathbfd_op.\n\n\n\n\n\n","category":"function"},{"location":"internals/predictive_control/#ModelPredictiveControl.linconstraint!","page":"Predictive Controllers","title":"ModelPredictiveControl.linconstraint!","text":"linconstraint!(mpc::PredictiveController, model::LinModel)\n\nSet b vector for the linear model inequality constraints (mathbfA ΔU  b).\n\n\n\n\n\nSet b excluding predicted output constraints when model is not a LinModel.\n\n\n\n\n\n","category":"function"},{"location":"internals/state_estim/#StateEstimator-Internals","page":"State Estimators","title":"StateEstimator Internals","text":"","category":"section"},{"location":"internals/state_estim/","page":"State Estimators","title":"State Estimators","text":"ModelPredictiveControl.init_estimstoch\nModelPredictiveControl.augment_model\nModelPredictiveControl.f̂\nModelPredictiveControl.ĥ","category":"page"},{"location":"internals/state_estim/#ModelPredictiveControl.init_estimstoch","page":"State Estimators","title":"ModelPredictiveControl.init_estimstoch","text":"init_estimstoch(i_ym, nint_ym::Vector{Int})\n\nCalc stochastic model matrices from output integrators specifications for state estimation.\n\nFor closed-loop state estimators. nint_ym is a vector providing how many integrator should  be added for each measured output mathbfy^m. The argument generates the Asm and  Csm matrices:\n\nbeginaligned\nmathbfx_s(k+1) = mathbfA_s^m x_s(k) + mathbfB_s^m e(k) \nmathbfy_s^m(k) = mathbfC_s^m x_s(k)\nendaligned\n\nwhere mathbfe(k) is a conceptual and unknown zero mean white noise.  mathbfB_s^m is not used for closed-loop state estimators thus ignored.\n\n\n\n\n\n","category":"function"},{"location":"internals/state_estim/#ModelPredictiveControl.augment_model","page":"State Estimators","title":"ModelPredictiveControl.augment_model","text":"augment_model(model::LinModel, As, Cs)\n\nAugment LinModel state-space matrices with the stochastic ones As and Cs.\n\nIf mathbfx_d are model.x states, and mathbfx_s, the states defined at init_estimstoch, we define an augmented state vector mathbfx =   beginsmallmatrix mathbfx_d  mathbfx_s endsmallmatrix . The method returns the augmented matrices Â, B̂u, Ĉ, B̂d and D̂d:\n\nbeginaligned\n    mathbfx(k+1) = mathbfA x(k) + mathbfB_u u(k) + mathbfB_d d(k) \n    mathbfy(k)   = mathbfC x(k) + mathbfD_d d(k)\nendaligned\n\n\n\n\n\n","category":"function"},{"location":"internals/state_estim/#ModelPredictiveControl.f̂","page":"State Estimators","title":"ModelPredictiveControl.f̂","text":"f̂(estim::StateEstimator, x̂, u, d)\n\nState function mathbff of the augmented model.\n\nBy introducing an augmented state vector mathbfx like in augment_model, the function returns the next state of the augmented model, defined as:\n\nbeginaligned\n    mathbfx(k+1) = mathbffBig(mathbfx(k) mathbfu(k) mathbfd(k)Big) \n    mathbfy(k)   = mathbfhBig(mathbfx(k) mathbfd(k)Big) \nendaligned\n\n\n\n\n\n","category":"function"},{"location":"internals/state_estim/#ModelPredictiveControl.ĥ","page":"State Estimators","title":"ModelPredictiveControl.ĥ","text":"ĥ(estim::StateEstimator, x̂, d)\n\nOutput function mathbfh of the augmented model, see f̂ for details.\n\n\n\n\n\n","category":"function"},{"location":"internals/state_estim/#KalmanFilter","page":"State Estimators","title":"KalmanFilter","text":"","category":"section"},{"location":"internals/state_estim/","page":"State Estimators","title":"State Estimators","text":"ModelPredictiveControl.updatestate_kf!","category":"page"},{"location":"internals/state_estim/#ModelPredictiveControl.updatestate_kf!","page":"State Estimators","title":"ModelPredictiveControl.updatestate_kf!","text":"updatestate_kf!(estim::KalmanFilter, u, ym, d)\n\nUpdate KalmanFilter state estim.x̂ and estimation error covariance estim.P̂.\n\nIt implements the time-varying Kalman Filter in its predictor (observer) form :\n\nbeginaligned\n    mathbfM(k)       = mathbfP_k-1(k)mathbfC^m\n                           mathbfC^m P_k-1(k)mathbfC^m + R^-1                 \n    mathbfK(k)       = mathbfA M(k)                                                \n    mathbfy^m(k)     = mathbfC^m x_k-1(k) + mathbfD_d^m d(k)                  \n    mathbfx_k(k+1) = mathbfA x_k-1(k) + mathbfB_u u(k) + mathbfB_d d(k) \n                           + mathbfK(k)mathbfy^m(k) - mathbfy^m(k)             \n    mathbfP_k(k+1) = mathbfAmathbfP_k-1(k) - \n                           mathbfM(k)mathbfC^m P_k-1(k)mathbfA + mathbfQ\nendaligned\n\nbased on the process model described in SteadyKalmanFilter. The notation  mathbfx_k-1(k) refers to the state for the current time k estimated at the last  control period k-1. See [1] for details.\n\n[1]: Boyd S., \"Lecture 8 : The Kalman Filter\" (Winter 2008-09) [course slides], EE363:   Linear Dynamical Systems, https://web.stanford.edu/class/ee363/lectures/kf.pdf.\n\n\n\n\n\n","category":"function"},{"location":"internals/state_estim/#UnscentedKalmanFilter","page":"State Estimators","title":"UnscentedKalmanFilter","text":"","category":"section"},{"location":"internals/state_estim/","page":"State Estimators","title":"State Estimators","text":"ModelPredictiveControl.init_ukf\nModelPredictiveControl.updatestate_ukf!","category":"page"},{"location":"internals/state_estim/#ModelPredictiveControl.init_ukf","page":"State Estimators","title":"ModelPredictiveControl.init_ukf","text":"init_ukf(nx̂, α, β, κ)\n\nCompute the UnscentedKalmanFilter constants from α β and κ.\n\nWith n_mathbfx elements in the state vector mathbfx and  n_σ = 2 n_mathbfx + 1 sigma points, the scaling factor applied on standard deviation  matrices sqrtmathbfP is:\n\n    γ = α sqrt n_mathbfx + κ \n\nThe weight vector (n_σ  1) for the mean and the weight matrix (n_σ  n_σ) for the  covariance are respectively:\n\nbeginaligned\n    mathbfm = beginbmatrix 1 - tfracn_mathbfxγ^2  tfrac12γ^2  tfrac12γ^2  cdots  tfrac12γ^2 endbmatrix \n    mathbfS = mathrmdiagbig( 2 - α^2 + β - tfracn_mathbfxγ^2  tfrac12γ^2  tfrac12γ^2  cdots  tfrac12γ^2 big)\nendaligned\n\nSee updatestate_ukf! for other details.\n\n\n\n\n\n","category":"function"},{"location":"internals/state_estim/#ModelPredictiveControl.updatestate_ukf!","page":"State Estimators","title":"ModelPredictiveControl.updatestate_ukf!","text":"updatestate_ukf!(estim::UnscentedKalmanFilter, u, ym, d)\n\nUpdate UnscentedKalmanFilter state estim.x̂ and covariance estimate estim.P̂.\n\nIt implements the unscented Kalman Filter in its predictor (observer) form, based on the  generalized unscented transform[2]. See init_ukf for the definition of the  constants mathbfm S and γ. \n\nDenoting mathbfx_k-1(k) as the state for the current time k estimated at the  last period k-1, mathbf0, a null vector, n_σ = 2 n_mathbfx + 1, the number of sigma points, and mathbfX_k-1^j(k), the vector at the jth column of  mathbfX_k-1(k), the estimator updates the states with:\n\nbeginaligned\n    mathbfX_k-1(k) = biggbeginmatrix mathbfx_k-1(k)  mathbfx_k-1(k)  cdots  mathbfx_k-1(k)  endmatrixbigg + biggbeginmatrix mathbf0  γ sqrtmathbfP_k-1(k)  -γ sqrtmathbfP_k-1(k) endmatrixbigg \n    mathbfY^m(k)     = biggbeginmatrix mathbfh^mBig( mathbfX_k-1^1(k) Big)  mathbfh^mBig( mathbfX_k-1^2(k) Big)  cdots  mathbfh^mBig( mathbfX_k-1^n_σ(k) Big) endmatrixbigg \n    mathbfy^m(k)     = mathbfY^m(k) mathbfm \n    mathbfX_k-1(k) = beginbmatrix mathbfX_k-1^1(k) - mathbfx_k-1(k)  mathbfX_k-1^2(k) - mathbfx_k-1(k)  cdots  mathbfX_k-1^n_σ(k) - mathbfx_k-1(k) endbmatrix \n    mathbfY^m(k)     = beginbmatrix mathbfY^m^1(k)     - mathbfy^m(k)      mathbfY^m^2(k)     - mathbfy^m(k)      cdots  mathbfY^m^n_σ(k)     - mathbfy^m(k)     endbmatrix \n    mathbfM(k)       = mathbfY^m(k) mathbfS mathbfY^m(k) + mathbfR \n    mathbfK(k)       = mathbfX_k-1(k) mathbfS mathbfY^m(k) mathbfM(k)^-1 \n    mathbfx_k(k)     = mathbfx_k-1(k) + mathbfK(k) big mathbfy^m(k) - mathbfy^m(k) big \n    mathbfP_k(k)     = mathbfP_k-1(k) - mathbfK(k) mathbfM(k) mathbfK(k) \n    mathbfX_k(k)     = biggbeginmatrix mathbfx_k(k)  mathbfx_k(k)  cdots  mathbfx_k(k) endmatrixbigg + biggbeginmatrix mathbf0  gamma sqrtmathbfP_k(k)  - gamma sqrtmathbfP_k(k) endmatrixbigg \n    mathbfX_k(k+1) = biggbeginmatrix mathbffBig( mathbfX_k^1(k) mathbfu(k) mathbfd(k) Big)  mathbffBig( mathbfX_k^2(k) mathbfu(k) mathbfd(k) Big)  cdots  mathbffBig( mathbfX_k^n_σ(k) mathbfu(k) mathbfd(k) Big) endmatrixbigg \n    mathbfx_k(k+1) = mathbfX_k(k+1)mathbfm \n    mathbfX_k(k+1)   = beginbmatrix mathbfX_k^1(k+1) - mathbfx_k(k+1)  mathbfX_k^2(k+1) - mathbfx_k(k+1)  cdots  mathbfX_k^n_σ(k+1) - mathbfx_k(k+1) endbmatrix \n    mathbfP_k(k+1)   = mathbfX_k(k+1) mathbfS mathbfX_k(k+1) + mathbfQ\nendaligned \n\nby using the lower triangular factor of cholesky to compute sqrtmathbfP_k-1(k) and sqrtmathbfP_k(k).  The matrices  mathbfP Q R are the covariance of the estimation error, process noise and sensor  noise, respectively.\n\n[2]: Simon, D. 2006, \"Chapter 14: The unscented Kalman filter\" in \"Optimal State Estimation:   Kalman, H∞, and Nonlinear Approaches\", John Wiley & Sons, p. 433–459, https://doi.org/10.1002/0470045345.ch14,   ISBN9780470045343.\n\n\n\n\n\n","category":"function"},{"location":"internals/state_estim/#InternalModel","page":"State Estimators","title":"InternalModel","text":"","category":"section"},{"location":"internals/state_estim/","page":"State Estimators","title":"State Estimators","text":"ModelPredictiveControl.init_internalmodel","category":"page"},{"location":"internals/state_estim/#ModelPredictiveControl.init_internalmodel","page":"State Estimators","title":"ModelPredictiveControl.init_internalmodel","text":"init_internalmodel(As, Bs, Cs, Ds)\n\nCalc stochastic model update matrices Âs and B̂s for InternalModel estimator.\n\nAs, Bs, Cs and Ds are the stochastic model matrices :\n\nbeginaligned\n    mathbfx_s(k+1) = mathbfA_s x_s(k) + mathbfB_s e(k) \n    mathbfy_s(k)   = mathbfC_s x_s(k) + mathbfD_s e(k)\nendaligned\n\nwhere mathbfe(k) is conceptual and unknown zero mean white noise. Its optimal estimation is mathbfe=0, the expected value. Thus, the Âs and B̂s matrices that  optimally update the stochastic estimate mathbfx_s are:\n\nbeginaligned\n    mathbfx_s(k+1) \n        = mathbf(A_s - B_s D_s^-1 C_s) x_s(k) + mathbf(B_s D_s^-1) y_s(k) \n        = mathbfA_s x_s(k) + mathbfB_s y_s(k)\nendaligned\n\nwith current stochastic outputs estimation mathbfy_s(k), composed of the measured  mathbfy_s^m(k) = mathbfy^m(k) - mathbfy_d^m(k) and unmeasured  mathbfy_s^u = 0 outputs. See [3].\n\n[3]: Desbiens, A., D. Hodouin & É. Plamondon. 2000, \"Global predictive control : a unified control structure for decoupling setpoint tracking, feedforward compensation and  disturbance rejection dynamics\", IEE Proceedings - Control Theory and Applications,  vol. 147, no 4, https://doi.org/10.1049/ip-cta:20000443, p. 465–475, ISSN 1350-2379.\n\n\n\n\n\n","category":"function"},{"location":"public/state_estim/#State-Estimators","page":"State Estimators","title":"State Estimators","text":"","category":"section"},{"location":"public/state_estim/","page":"State Estimators","title":"State Estimators","text":"Pages = [\"state_estim.md\"]","category":"page"},{"location":"public/state_estim/","page":"State Estimators","title":"State Estimators","text":"This module includes many state estimators (or state observer), both for deterministic and stochastic systems. The implementations focus on control applications, that is, relying on the estimates to compute a full state feedback (predictive controllers, in this package). They all incorporates some kind of integral action by default, since it is generally desired to eliminate the steady-state error with closed-loop control (offset-free tracking).","category":"page"},{"location":"public/state_estim/","page":"State Estimators","title":"State Estimators","text":"info: Info\nIf you plan to use the estimators for other contexts than this specific package (e.g. : filter, parameter estimation, etc.), careful must be taken at construction since the integral action is not necessarily desired. The option nint_ym=0 disable it.","category":"page"},{"location":"public/state_estim/","page":"State Estimators","title":"State Estimators","text":"The estimators are all implemented in the predictor form (a.k.a. observer form), that is, they all estimates at each discrete time k the states of the next period mathbfx_k(k+1). In contrast, the filter form that estimates mathbfx_k(k) is sometimes slightly more accurate.","category":"page"},{"location":"public/state_estim/","page":"State Estimators","title":"State Estimators","text":"The predictor form comes in handy for control applications since the estimations come after the controller computations, without introducing any additional delays. Moreover, the moveinput! method of the predictive controllers does not automatically update the estimates with updatestate!. This allows applying the calculated inputs on the real plant before starting the potentially expensive estimator computations (see Manual for examples).","category":"page"},{"location":"public/state_estim/","page":"State Estimators","title":"State Estimators","text":"info: Info\nAll the estimators support measured mathbfy^m and unmeasured mathbfy^u model outputs, where mathbfy refers to all of them.","category":"page"},{"location":"public/state_estim/#StateEstimator","page":"State Estimators","title":"StateEstimator","text":"","category":"section"},{"location":"public/state_estim/","page":"State Estimators","title":"State Estimators","text":"StateEstimator","category":"page"},{"location":"public/state_estim/#ModelPredictiveControl.StateEstimator","page":"State Estimators","title":"ModelPredictiveControl.StateEstimator","text":"Abstract supertype of all state estimators.\n\n\n\n(estim::StateEstimator)(d=Float64[])\n\nFunctor allowing callable StateEstimator object as an alias for evaloutput.\n\nExamples\n\njulia> kf = KalmanFilter(setop!(LinModel(tf(3, [10, 1]), 2), yop=[20]));\n\njulia> ŷ = kf() \n1-element Vector{Float64}:\n 20.0\n\n\n\n\n\n","category":"type"},{"location":"public/state_estim/#SteadyKalmanFilter","page":"State Estimators","title":"SteadyKalmanFilter","text":"","category":"section"},{"location":"public/state_estim/","page":"State Estimators","title":"State Estimators","text":"SteadyKalmanFilter","category":"page"},{"location":"public/state_estim/#ModelPredictiveControl.SteadyKalmanFilter","page":"State Estimators","title":"ModelPredictiveControl.SteadyKalmanFilter","text":"SteadyKalmanFilter(model::LinModel; <keyword arguments>)\n\nConstruct a steady-state Kalman Filter with the LinModel model.\n\nThe steady-state (or asymptotic) Kalman filter is based on the process model :\n\nbeginaligned\n    mathbfx(k+1) = \n            mathbfA x(k) + mathbfB_u u(k) + mathbfB_d d(k) + mathbfw(k) \n    mathbfy^m(k) = mathbfC^m x(k) + mathbfD_d^m d(k) + mathbfv(k) \n    mathbfy^u(k) = mathbfC^u x(k) + mathbfD_d^u d(k)\nendaligned\n\nwith sensor mathbfv(k) and process mathbfw(k) noises as uncorrelated zero mean  white noise vectors, with a respective covariance of mathbfR and mathbfQ.  The arguments are in standard deviations σ, i.e. same units than outputs and states. The  matrices mathbfA B_u B_d C D_d are model matrices augmented with the stochastic model, which is specified by the numbers of output integrator nint_ym (see Extended Help).  Likewise, the covariance matrices are augmented with mathbfQ = textdiag(Q Q_int)  and mathbfR = R. The matrices mathbfC^m D_d^m are the rows of  mathbfC D_d that correspond to measured outputs mathbfy^m (and unmeasured  ones, for mathbfC^u D_d^u).\n\nArguments\n\nmodel::LinModel : (deterministic) model for the estimations.\ni_ym=1:model.ny : model output indices that are measured mathbfy^m, the rest    are unmeasured mathbfy^u.\nσQ=fill(0.1,model.nx) : main diagonal of the process noise covariance mathbfQ of   model, specified as a standard deviation vector.\nσR=fill(0.1,length(i_ym)) : main diagonal of the sensor noise covariance mathbfR   of model measured outputs, specified as a standard deviation vector.\nnint_ym=fill(1,length(i_ym)) : integrator quantity per measured outputs (vector) for the    stochastic model, use nint_ym=0 for no integrator at all.\nσQ_int=fill(0.1,sum(nint_ym)) : same than σQ but for the stochastic model covariance   mathbfQ_int (composed of output integrators).\n\nExamples\n\njulia> model = LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 0.5);\n\njulia> estim = SteadyKalmanFilter(model, i_ym=[2], σR=[1], σQ_int=[0.01])\nSteadyKalmanFilter estimator with a sample time Ts = 0.5 s, LinModel and:\n 1 manipulated inputs u\n 3 states x̂\n 1 measured outputs ym\n 1 unmeasured outputs yu\n 0 measured disturbances d\n\nExtended Help\n\nThe model augmentation with nint_ym vector produces the integral action when the estimator is used in a controller as state feedback. The default is 1 integrator per measured outputs, resulting in an offset-free tracking for \"step-like\" unmeasured output disturbances. Use 2  integrators for \"ramp-like\" disturbances. See init_estimstoch.\n\ntip: Tip\nIncreasing σQ_int values increases the integral action \"gain\".\n\nThe constructor pre-compute the steady-state Kalman gain K with the kalman function. It can sometimes fail, for example when model is integrating. In such a case, you can use 0 integrator on model integrating outputs, or the alternative time-varying  KalmanFilter.\n\n\n\n\n\n","category":"type"},{"location":"public/state_estim/#KalmanFilter","page":"State Estimators","title":"KalmanFilter","text":"","category":"section"},{"location":"public/state_estim/","page":"State Estimators","title":"State Estimators","text":"KalmanFilter","category":"page"},{"location":"public/state_estim/#ModelPredictiveControl.KalmanFilter","page":"State Estimators","title":"ModelPredictiveControl.KalmanFilter","text":"KalmanFilter(model::LinModel; <keyword arguments>)\n\nConstruct a time-varying Kalman Filter with the LinModel model.\n\nThe process model is identical to SteadyKalmanFilter. The matrix  mathbfP_k(k+1) is the estimation error covariance of model states augmented with the stochastic ones (specified by nint_ym). Two keyword arguments modify its initial value with mathbfP_-1(0) = mathrmdiag mathbfP(0) mathbfP_int(0) .\n\nArguments\n\nmodel::LinModel : (deterministic) model for the estimations.\nσP0=fill(10,model.nx) : main diagonal of the initial estimate covariance    mathbfP(0), specified as a standard deviation vector.\nσP0_int=fill(10,sum(nint_ym)) : same than σP0 but for the stochastic model   covariance mathbfP_int(0) (composed of output integrators).\n<keyword arguments> of SteadyKalmanFilter constructor.\n\nExamples\n\njulia> model = LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 0.5);\n\njulia> estim = KalmanFilter(model, i_ym=[2], σR=[1], σP0=[100, 100], σQ_int=[0.01])\nKalmanFilter estimator with a sample time Ts = 0.5 s, LinModel and:\n 1 manipulated inputs u\n 3 states x̂\n 1 measured outputs ym\n 1 unmeasured outputs yu\n 0 measured disturbances d\n\n\n\n\n\n","category":"type"},{"location":"public/state_estim/#UnscentedKalmanFilter","page":"State Estimators","title":"UnscentedKalmanFilter","text":"","category":"section"},{"location":"public/state_estim/","page":"State Estimators","title":"State Estimators","text":"UnscentedKalmanFilter","category":"page"},{"location":"public/state_estim/#ModelPredictiveControl.UnscentedKalmanFilter","page":"State Estimators","title":"ModelPredictiveControl.UnscentedKalmanFilter","text":"UnscentedKalmanFilter(model::SimModel; <keyword arguments>)\n\nConstruct an unscented Kalman Filter with the SimModel model.\n\nBoth LinModel and NonLinModel are supported. The unscented Kalman filter is based on the process model :\n\nbeginaligned\n    mathbfx(k+1) = mathbffBig(mathbfx(k) mathbfu(k) mathbfd(k)Big) \n                        + mathbfw(k)                                                   \n    mathbfy^m(k) = mathbfh^mBig(mathbfx(k) mathbfd(k)Big) + mathbfv(k) \n    mathbfy^u(k) = mathbfh^uBig(mathbfx(k) mathbfd(k)Big)                 \nendaligned\n\nSee SteadyKalmanFilter for details on mathbfv(k) mathbfw(k) noises and  mathbfR mathbfQ covariances. The functions mathbff h are model  state-space functions augmented with the stochastic model, which is specified by the numbers of output integrator nint_ym (see SteadyKalmanFilter for details). The  mathbfh^m function represents the measured outputs of mathbfh function (and  unmeasured ones, for mathbfh^u).\n\nArguments\n\nmodel::SimModel : (deterministic) model for the estimations.\nα=1e-3 : alpha parameter, spread of the state distribution (0  α  1).\nβ=2 : beta parameter, skewness and kurtosis of the states distribution (β  0).\nκ=0 : kappa parameter, another spread parameter (0  κ  3).\n<keyword arguments> of SteadyKalmanFilter constructor.\n<keyword arguments> of KalmanFilter constructor.\n\nExamples\n\njulia> model = NonLinModel((x,u,_)->0.1x+u, (x,_)->2x, 10, 1, 1, 1);\n\njulia> estim = UnscentedKalmanFilter(model, σR=[1], nint_ym=[2], σP0_int=[1, 1])\nUnscentedKalmanFilter estimator with a sample time Ts = 10.0 s, NonLinModel and:\n 1 manipulated inputs u\n 3 states x̂\n 1 measured outputs ym\n 0 unmeasured outputs yu\n 0 measured disturbances d\n\n\n\n\n\n","category":"type"},{"location":"public/state_estim/#InternalModel","page":"State Estimators","title":"InternalModel","text":"","category":"section"},{"location":"public/state_estim/","page":"State Estimators","title":"State Estimators","text":"InternalModel","category":"page"},{"location":"public/state_estim/#ModelPredictiveControl.InternalModel","page":"State Estimators","title":"ModelPredictiveControl.InternalModel","text":"InternalModel(model::SimModel; i_ym=1:model.ny, stoch_ym=ss(1,1,1,1,model.Ts).*I)\n\nConstruct an internal model estimator based on model (LinModel or NonLinModel).\n\ni_ym provides the model output indices that are measured mathbfy^m, the rest are  unmeasured mathbfy^u. model evaluates the deterministic predictions  mathbfy_d, and stoch_ym, the stochastic predictions of the measured outputs  mathbfy_s^m (the unmeasured ones being mathbfy_s^u=0). The predicted outputs sum both values : mathbfy = y_d + y_s.\n\nwarning: Warning\nInternalModel estimator does not work if model is integrating or unstable. The  constructor verifies these aspects for LinModel but not for NonLinModel. Uses any  other state estimator in such cases.\n\nExamples\n\njulia> estim = InternalModel(LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 0.5), i_ym=[2])\nInternalModel estimator with a sample time Ts = 0.5 s, LinModel and:\n 1 manipulated inputs u\n 2 states x̂\n 1 measured outputs ym\n 1 unmeasured outputs yu\n 0 measured disturbances d\n\nExtended Help\n\nstoch_ym is a TransferFunction or StateSpace object that models disturbances on mathbfy^m. Its input is a hypothetical zero mean white noise vector. stoch_ym  supposes 1 integrator per measured outputs by default, assuming that the current stochastic estimate mathbfy_s^m(k) = mathbfy^m(k) - mathbfy_d^m(k) is constant in the  future. This is the dynamic matrix control (DMC) strategy, which is simple but sometimes too aggressive. Additional poles and zeros in stoch_ym can mitigate this.\n\n\n\n\n\n","category":"type"},{"location":"func_index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"func_index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#Installation","page":"Manual","title":"Installation","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"To install the ModelPredictiveControl package, run this command in the Julia REPL:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using Pkg; Pkg.add(\"ModelPredictiveControl\")","category":"page"},{"location":"manual/#Predictive-Controller-Design","page":"Manual","title":"Predictive Controller Design","text":"","category":"section"},{"location":"manual/#Linear-Model","page":"Manual","title":"Linear Model","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The considered plant is well-stirred tank with a cold and hot water inlet. The water flows out of an opening at the bottom of the tank. The manipulated inputs are the cold u_c and hot u_h water flow rate, and the measured outputs are the liquid level y_L and temperature y_T:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"beginaligned\n    mathbfu = beginbmatrix u_c  u_h endbmatrix \n    mathbfy = beginbmatrix y_L  y_T endbmatrix\nendaligned","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"At the steady-state operating points:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"beginaligned\n    mathbfu_op = beginbmatrix 10  10 endbmatrix \n    mathbfy_op = beginbmatrix 50  30 endbmatrix \nendaligned","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"the following linear model accurately describes the plant dynamics:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"beginbmatrix\n    y_L(s)  y_T(s)\nendbmatrix = \nbeginbmatrix\n    frac19018s + 1  frac19018s + 1 3pt\n    frac-0748s + 1  frac0748s + 1\nendbmatrix\nbeginbmatrix\n    u_c(s)  u_h(s)\nendbmatrix","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"We want to design a predictive feedback that controls both the water level y_L and temperature y_T in the tank, at a sampling time of 4 s. The tank level should also never fall below 45:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"y_L  45","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"We first need to construct a LinModel objet with setop! to handle the operating points:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using ModelPredictiveControl, ControlSystemsBase\nsys = [ tf(1.90, [18, 1]) tf(1.90, [18, 1]);\n        tf(-0.74,[8, 1])  tf(0.74, [8, 1]) ]\nTs = 4.0\nmodel = setop!(LinModel(sys, Ts), uop=[10, 10], yop=[50, 30])","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The model object will be used for two purposes : to construct our controller, and as a plant simulator to test the design. We design our LinMPC controllers by including the level constraint with setconstraint!:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"mpc = setconstraint!(LinMPC(model, Hp=15, Hc=2), ŷmin=[45, -Inf])","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"By default, LinMPC controllers use a SteadyKalmanFilter to estimate the plant states. Before closing the loop, we call initstate! with the actual plant inputs and measurements to ensure a bumpless transfer. Since model simulates our plant here, its output will initialize the states. LinModel objects are callable for this purpose (an alias for evaloutput):","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"u = model.uop\ny = model() # or equivalently : y = evaloutput(model)\ninitstate!(mpc, u, y)\nnothing # hide","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"We can then close the loop and test mpc performance on the simulator by imposing step changes on output setpoints mathbfr_y and on a load disturbance mathbfu_d:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"function test_mpc(mpc, model)\n    N = 100\n    ry, ud = [50, 30], [0, 0]\n    u_data  = zeros(model.nu, N)\n    y_data  = zeros(model.ny, N)\n    ry_data = zeros(model.ny, N)\n    for k = 0:N-1\n        y = model() # simulated measurements\n        k == 25 && (ry = [50, 35])\n        k == 50 && (ry = [55, 30])\n        k == 75 && (ud = [-15, 0])\n        u = mpc(ry) # or equivalently : u = moveinput!(mpc, ry)\n        u_data[:,k+1]  = u\n        y_data[:,k+1]  = y\n        ry_data[:,k+1] = ry \n        updatestate!(mpc, u, y) # update mpc state estimate\n        updatestate!(model, u + ud) # update simulator with disturbance\n    end\n    return u_data, y_data, ry_data\nend\nu_data, y_data, ry_data = test_mpc(mpc, model)\nt_data = Ts*(0:(size(y_data,2)-1))\nnothing # hide","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The LinMPC objects are also callable as an alternative syntax for moveinput!. Calling updatestate! on the mpc object updates its internal state for the NEXT control period (this is by design, see State Estimators for justifications). That is why the call is done at the end of the for loop. The same logic applies for model.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Lastly, we plot the closed-loop test with the Plots package:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using Plots\np1 = plot(t_data, y_data[1,:], label=\"level\"); ylabel!(\"level\")\nplot!(t_data, ry_data[1,:], label=\"setpoint\", linestyle=:dash, linetype=:steppost)\nplot!(t_data, fill(45,size(t_data)), label=\"min\", linestyle=:dot, linetype=:steppost)\np2 = plot(t_data, y_data[2,:], label=\"temp.\"); ylabel!(\"temp.\")\nplot!(t_data, ry_data[2,:],label=\"setpoint\", linestyle=:dash, linetype=:steppost)\np3 = plot(t_data,u_data[1,:],label=\"cold\", linetype=:steppost); ylabel!(\"flow rate\")\nplot!(t_data,u_data[2,:],label=\"hot\", linetype=:steppost); xlabel!(\"time (s)\")\np = plot(p1, p2, p3, layout=(3,1), fmt=:svg)","category":"page"},{"location":"public/sim_model/#Plant-Models","page":"Plant Models","title":"Plant Models","text":"","category":"section"},{"location":"public/sim_model/","page":"Plant Models","title":"Plant Models","text":"Pages = [\"sim_model.md\"]","category":"page"},{"location":"public/sim_model/","page":"Plant Models","title":"Plant Models","text":"The SimModel types represents discrete state-space models that can be used to construct StateEstimators and PredictiveControllers, or as plant simulators by calling evaloutput and updatestate! methods on SimModel objects (to test estimator/controller designs). For time simulations, the states x are stored inside SimModel objects. Use setstate! method to manually modify them.","category":"page"},{"location":"public/sim_model/#SimModel","page":"Plant Models","title":"SimModel","text":"","category":"section"},{"location":"public/sim_model/","page":"Plant Models","title":"Plant Models","text":"SimModel","category":"page"},{"location":"public/sim_model/#ModelPredictiveControl.SimModel","page":"Plant Models","title":"ModelPredictiveControl.SimModel","text":"Abstract supertype of LinModel and NonLinModel types.\n\n\n\n(model::SimModel)(d=Float64[])\n\nFunctor allowing callable SimModel object as an alias for evaloutput.\n\nExamples\n\njulia> model = NonLinModel((x,u,_)->-x + u, (x,_)->x .+ 20, 10, 1, 1, 1);\n\njulia> y = model()\n1-element Vector{Float64}:\n 20.0\n\n\n\n\n\n","category":"type"},{"location":"public/sim_model/#LinModel","page":"Plant Models","title":"LinModel","text":"","category":"section"},{"location":"public/sim_model/","page":"Plant Models","title":"Plant Models","text":"LinModel","category":"page"},{"location":"public/sim_model/#ModelPredictiveControl.LinModel","page":"Plant Models","title":"ModelPredictiveControl.LinModel","text":"LinModel(sys::StateSpace[, Ts]; i_u=1:size(sys,2), i_d=Int[])\n\nConstruct a linear model from state-space model sys with sampling time Ts in second.\n\nTs can be omitted when sys is discrete-time. Its state-space matrices are:\n\nbeginaligned\n    mathbfx(k+1) = mathbfA x(k) + mathbfB z(k) \n    mathbfy(k)   = mathbfC x(k) + mathbfD z(k)\nendaligned\n\nwith the state mathbfx and output mathbfy vectors. The mathbfz vector  comprises the manipulated inputs mathbfu and measured disturbances mathbfd,  in any order. i_u provides the indices of mathbfz that are manipulated, and i_d,  the measured disturbances. See Extended Help if sys is continuous-time, or discrete-time and Ts ≠ sys.Ts.\n\nSee also ss, tf.\n\nExamples\n\njulia> model = LinModel(ss(0.4, 0.2, 0.3, 0, 0.1))\nDiscrete-time linear model with a sample time Ts = 0.1 s and:\n 1 manipulated inputs u\n 1 states x\n 1 outputs y\n 0 measured disturbances d\n\nExtended Help\n\nState-space matrices are similar if sys is continuous (replace mathbfx(k+1) with  mathbfx(t) and k with t on the LHS). In such a case, it's discretized with  c2d and :zoh for manipulated inputs, and :tustin, for measured disturbances. Lastly, if  sys is discrete and the provided argument Ts ≠ sys.Ts, the system is resampled by using  the aforementioned discretization methods.\n\nThe constructor transforms the system to a more practical form (mathbfD_u=0 because  of the zero-order hold):\n\nbeginaligned\n    mathbfx(k+1) =  mathbfA x(k) + mathbfB_u u(k) + mathbfB_d d(k) \n    mathbfy(k)   =  mathbfC x(k) + mathbfD_d d(k)\nendaligned\n\n\n\n\n\nLinModel(sys::TransferFunction[, Ts]; i_u=1:size(sys,2), i_d=Int[])\n\nConvert to minimal realization state-space when sys is a transfer function.\n\nsys is equal to fracmathbfy(s)mathbfz(s) for continuous-time, and  fracmathbfy(z)mathbfz(z), for discrete-time.\n\nExamples\n\njulia> model = LinModel([tf(3, [30, 1]) tf(-2, [5, 1])], 0.5, i_d=[2])\nDiscrete-time linear model with a sample time Ts = 0.5 s and:\n 1 manipulated inputs u\n 2 states x\n 1 outputs y\n 1 measured disturbances d\n\n\n\n\n\nLinModel(sys::DelayLtiSystem, Ts; i_u=1:size(sys,2), i_d=Int[])\n\nDiscretize with zero-order hold when sys is a continuous system with delays.\n\nThe delays must be multiples of the sample time Ts.\n\nExamples\n\njulia> model = LinModel(tf(4, [10, 1])*delay(2), 0.5)\nDiscrete-time linear model with a sample time Ts = 0.5 s and:\n 1 manipulated inputs u\n 5 states x\n 1 outputs y\n 0 measured disturbances d\n\n\n\n\n\n","category":"type"},{"location":"public/sim_model/#NonLinModel","page":"Plant Models","title":"NonLinModel","text":"","category":"section"},{"location":"public/sim_model/","page":"Plant Models","title":"Plant Models","text":"NonLinModel","category":"page"},{"location":"public/sim_model/#ModelPredictiveControl.NonLinModel","page":"Plant Models","title":"ModelPredictiveControl.NonLinModel","text":"NonLinModel(f::Function, h::Function, Ts, nu, nx, ny, nd=0)\n\nConstruct a nonlinear model from discrete-time state-space functions f and h.\n\nThe state update mathbff and output mathbfh functions are defined as :\n\n    beginaligned\n    mathbfx(k+1) = mathbffBig( mathbfx(k) mathbfu(k) mathbfd(k) Big) \n    mathbfy(k)   = mathbfhBig( mathbfx(k) mathbfd(k) Big)\n    endaligned\n\nTs is the sampling time in second. nu, nx, ny and nd are the respective number of  manipulated inputs, states, outputs and measured disturbances. \n\ntip: Tip\nReplace the d argument with _ if nd = 0 (see Examples below).\n\nNonlinear continuous-time state-space functions are not supported for now. In such a case,  manually call a differential equation solver in the f function (e.g.: Euler method).\n\nwarning: Warning\nf and h must be pure Julia functions to use the model in NonLinMPC.\n\nSee also LinModel.\n\nExamples\n\njulia> model = NonLinModel((x,u,_)->0.1x+u, (x,_)->2x, 10, 1, 1, 1)\nDiscrete-time nonlinear model with a sample time Ts = 10.0 s and:\n 1 manipulated inputs u\n 1 states x\n 1 outputs y\n 0 measured disturbances d\n\n\n\n\n\n","category":"type"},{"location":"public/sim_model/#Set-Operating-Points","page":"Plant Models","title":"Set Operating Points","text":"","category":"section"},{"location":"public/sim_model/","page":"Plant Models","title":"Plant Models","text":"setop!","category":"page"},{"location":"public/sim_model/#ModelPredictiveControl.setop!","page":"Plant Models","title":"ModelPredictiveControl.setop!","text":"setop!(model::SimModel; uop=nothing, yop=nothing, dop=nothing)\n\nSet model inputs uop, outputs yop and measured disturbances dop operating points.\n\nThe state-space model with operating points (a.k.a. nominal values) is:\n\nbeginaligned\n    mathbfx(k+1) =  mathbfA x(k) + mathbfB_u u_0(k) + mathbfB_d d_0(k) \n    mathbfy_0(k) =  mathbfC x(k) + mathbfD_d d_0(k)\nendaligned\n\nin which the uop, yop and dop vectors evaluate:\n\nbeginaligned\n    mathbfu_0(k) = mathbfu(k) - mathbfu_op \n    mathbfy_0(k) = mathbfy(k) - mathbfy_op \n    mathbfd_0(k) = mathbfd(k) - mathbfd_op \nendaligned\n\nThe structure is similar if model is a NonLinModel:\n\nbeginaligned\n    mathbfx(k+1) = mathbffBig(mathbfx(k) mathbfu_0(k) mathbfd_0(k)Big)\n    mathbfy_0(k) = mathbfhBig(mathbfx(k) mathbfd_0(k)Big)\nendaligned\n\nExamples\n\njulia> model = setop!(LinModel(tf(3, [10, 1]), 2), uop=[50], yop=[20])\nDiscrete-time linear model with a sample time Ts = 2.0 s and:\n 1 manipulated inputs u\n 1 states x\n 1 outputs y\n 0 measured disturbances d\n\n\n\n\n\n","category":"function"},{"location":"public/generic_func/#Generic-Functions","page":"Generic Functions","title":"Generic Functions","text":"","category":"section"},{"location":"public/generic_func/","page":"Generic Functions","title":"Generic Functions","text":"Pages = [\"generic_func.md\"]","category":"page"},{"location":"public/generic_func/#Evaluate-Output-y","page":"Generic Functions","title":"Evaluate Output y","text":"","category":"section"},{"location":"public/generic_func/","page":"Generic Functions","title":"Generic Functions","text":"evaloutput","category":"page"},{"location":"public/generic_func/#ModelPredictiveControl.evaloutput","page":"Generic Functions","title":"ModelPredictiveControl.evaloutput","text":"evaloutput(model::SimModel, d=Float64[])\n\nEvaluate SimModel outputs y from model.x states and measured disturbances d.\n\nCalling a SimModel object calls this evaloutput method.\n\nExamples\n\njulia> model = setop!(LinModel(tf(2, [10, 1]), 5), yop=[20]);\n\njulia> y = evaloutput(model)\n1-element Vector{Float64}:\n 20.0\n\n\n\n\n\nevaloutput(estim::StateEstimator, d=Float64[])\n\nEvaluate StateEstimator outputs ŷ from estim.x̂ states and disturbances d.\n\nCalling a StateEstimator object calls this evaloutput method.\n\nExamples\n\njulia> kf = SteadyKalmanFilter(setop!(LinModel(tf(2, [10, 1]), 5), yop=[20]));\n\njulia> ŷ = evaloutput(kf)\n1-element Vector{Float64}:\n 20.0\n\n\n\n\n\nevaloutput(estim::InternalModel, ym, d=Float64[])\n\nEvaluate InternalModel outputs ŷ from estim.x̂d states and measured outputs ym.\n\nInternalModel estimator needs current measured outputs mathbfy^m(k) to  estimate its outputs mathbfy(k), since the strategy imposes that  mathbfy^m(k) = mathbfy^m(k) is always true.\n\n\n\n\n\n","category":"function"},{"location":"public/generic_func/#Update-State-x","page":"Generic Functions","title":"Update State x","text":"","category":"section"},{"location":"public/generic_func/","page":"Generic Functions","title":"Generic Functions","text":"updatestate!","category":"page"},{"location":"public/generic_func/#ModelPredictiveControl.updatestate!","page":"Generic Functions","title":"ModelPredictiveControl.updatestate!","text":"updatestate!(model::SimModel, u, d=Float64[])\n\nUpdate model.x states with current inputs u and measured disturbances d.\n\nExamples\n\njulia> model = LinModel(ss(1, 1, 1, 0, 1));\n\njulia> x = updatestate!(model, [1])\n1-element Vector{Float64}:\n 1.0\n\n\n\n\n\nupdatestate!(estim::SteadyKalmanFilter, u, ym, d=Float64[])\n\nUpdate estim.x̂ estimate with current inputs u, measured outputs ym and dist. d.\n\nThe SteadyKalmanFilter updates it with the precomputed Kalman gain mathbfK:\n\nmathbfx_k(k+1) = mathbfA x_k-1(k) + mathbfB_u u(k) + mathbfB_d d(k) \n               + mathbfKmathbfy^m(k) - mathbfC^m x_k-1(k) - mathbfD_d^m d(k)\n\nExamples\n\njulia> kf = SteadyKalmanFilter(LinModel(ss(1, 1, 1, 0, 1)));\n\njulia> x̂ = updatestate!(kf, [1], [0]) # x̂[2] is the integrator state (nint_ym argument)\n2-element Vector{Float64}:\n 1.0\n 0.0\n\n\n\n\n\nupdatestate!(estim::KalmanFilter, u, ym, d=Float64[])\n\nUpdate estim.x̂ \\ P̂ with current inputs u, measured outputs ym and dist. d.\n\nSee updatestate_kf! for the implementation details.\n\n\n\n\n\nupdatestate!(estim::UnscentedKalmanFilter, u, ym, d=Float64[])\n\nSame than KalmanFilter but using the unscented estimator.\n\nSee updatestate_ukf! for the implementation details.\n\n\n\n\n\nupdatestate!(estim::InternalModel, u, ym, d=Float64[])\n\nUpdate estim.x̂ \\ x̂d \\ x̂s with current inputs u, measured outputs ym and dist. d.\n\n\n\n\n\nupdatestate!(mpc::PredictiveController, u, ym, d=Float64[])\n\nCall updatestate! on mpc.estim StateEstimator.\n\n\n\n\n\n","category":"function"},{"location":"public/generic_func/#Init-State-x","page":"Generic Functions","title":"Init State x","text":"","category":"section"},{"location":"public/generic_func/","page":"Generic Functions","title":"Generic Functions","text":"initstate!","category":"page"},{"location":"public/generic_func/#ModelPredictiveControl.initstate!","page":"Generic Functions","title":"ModelPredictiveControl.initstate!","text":"initstate!(estim::StateEstimator, u, ym, d=Float64[])\n\nInit estim.x̂ states from current inputs u, measured outputs ym and disturbances d.\n\nThe method tries to find a good steady-state to initialize estim.x̂ estimate :\n\nIf estim.model is a LinModel, it evaluates estim.model steady-state (using steadystate) with current inputs u and measured disturbances d, and saves the result to estim.x̂[1:nx].\nElse, the current deterministic states estim.x̂[1:nx] are left unchanged (use  setstate! to manually modify them). \n\nIt then estimates the measured outputs ŷm from these states, and the residual offset with  current measured outputs (ym - ŷm) initializes the integrators of the stochastic model. This approach ensures that mathbfy^m(0) = mathbfy^m(0). For LinModel, it  also ensures that the estimator starts at steady-state, resulting in a bumpless manual to  automatic transfer for control applications.\n\nExamples\n\njulia> estim = SteadyKalmanFilter(LinModel(tf(3, [10, 1]), 0.5), nint_ym=[2]);\n\njulia> x̂ = initstate!(estim, [1], [3 - 0.1])\n3-element Vector{Float64}:\n  5.0000000000000115\n  0.0\n -0.10000000000000675\n\n\n\n\n\ninitstate!(estim::Union{KalmanFilter, UnscentedKalmanFilter}, u, ym, d=Float64[])\n\nInitialize covariance estim.P̂ and invoke initstate!(::StateEstimator).\n\n\n\n\n\ninitstate!(estim::InternalModel, u, ym, d=Float64[])\n\nInit estim.x̂d / x̂s states from current inputs u, meas. outputs ym and disturb. d.\n\nThe deterministic state estim.x̂d initialization method is identical to  initstate!(::StateEstimator). The stochastic states estim.x̂s are init at 0. \n\n\n\n\n\ninitstate!(mpc::PredictiveController, u, ym, d=Float64[])\n\nInit mpc.ΔŨ for warm-starting and the states of mpc.estim StateEstimator.\n\n\n\n\n\n","category":"function"},{"location":"public/generic_func/#Set-State-x","page":"Generic Functions","title":"Set State x","text":"","category":"section"},{"location":"public/generic_func/","page":"Generic Functions","title":"Generic Functions","text":"setstate!","category":"page"},{"location":"public/generic_func/#ModelPredictiveControl.setstate!","page":"Generic Functions","title":"ModelPredictiveControl.setstate!","text":"setstate!(model::SimModel, x)\n\nSet model.x states to values specified by x. \n\n\n\n\n\nsetstate!(estim::StateEstimator, x̂)\n\nSet estim.x̂ states to values specified by x̂. \n\n\n\n\n\nsetstate!(mpc::PredictiveController, x̂)\n\nSet the estimate at mpc.estim.x̂.\n\n\n\n\n\n","category":"function"},{"location":"public/generic_func/#Quick-Simulation","page":"Generic Functions","title":"Quick Simulation","text":"","category":"section"},{"location":"public/generic_func/","page":"Generic Functions","title":"Generic Functions","text":"sim","category":"page"},{"location":"public/generic_func/#ModelPredictiveControl.sim","page":"Generic Functions","title":"ModelPredictiveControl.sim","text":"sim(\n    mpc::PredictiveController, \n    N::Int, \n    ry = mpc.estim.model.yop .+ 1, \n    d  = mpc.estim.model.dop; \n    <keyword arguments>\n)\n\nClosed-loop simulation of mpc controller for N time steps, default to setpoint bumps.\n\nSee Arguments for the option list. The noise arguments are in standard deviations σ. The  sensor and process noises of the simulated plant are specified by y_noise and x_noise  arguments, respectively.\n\nArguments\n\nmpc::PredictiveController : predictive controller to simulate\nN::Int : simulation length in time steps\nry = mpc.estim.model.yop .+ 1 : plant output setpoint mathbfr_y value\nd = mpc.estim.model.dop : plant measured disturbance mathbfd value\nplant::SimModel = mpc.estim.model : simulated plant model\nu_step  = zeros(plant.nu) : step disturbance on manipulated input mathbfu\nu_noise = zeros(plant.nu) : additive gaussian noise on manipulated input mathbfu\ny_step  = zeros(plant.ny) : step disturbance on plant outputs mathbfy\ny_noise = zeros(plant.ny) : additive gaussian noise on plant outputs mathbfy\nd_step  = zeros(plant.nd) : step disturbance on measured dist. mathbfd\nd_noise = zeros(plant.nd) : additive gaussian noise on measured dist. mathbfd\nx_noise = zeros(plant.nx) : additive gaussian noise on plant states mathbfx\nx0 = zeros(plant.nx) : plant initial state mathbfx(0)\nx̂0 = nothing : mpc.estim state estimator initial state mathbfx(0), if nothing  then mathbfx is initialized with initstate!\nlastu = plant.uop : last plant input mathbfu for mathbfx initialization\n\n\n\n\n\n","category":"function"},{"location":"#ModelPredictiveControl.jl","page":"Home","title":"ModelPredictiveControl.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A model predictive control package for Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package depends on ControlSystemsBase.jl for the linear systems and JuMP.jl for the solvers.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"index.md\",\n    \"manual.md\",\n    \"public/sim_model.md\",\n    \"public/state_estim.md\",\n    \"public/predictive_control.md\",\n    \"public/generic_func.md\",\n    \"internals/sim_model.md\",\n    \"internals/state_estim.md\",\n    \"internals/predictive_control.md\",\n    \"func_index.md\"\n]","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"#Legend","page":"Home","title":"Legend","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"✅ implemented feature   ⬜ planned feature","category":"page"},{"location":"#Model-Predictive-Control-Features","page":"Home","title":"Model Predictive Control Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"✅ linear and nonlinear plant models exploiting multiple dispatch\n✅ model predictive controllers based on:\n✅ linear plant models\n✅ nonlinear plant models\n✅ supported objective function terms:\n✅ output setpoint tracking\n✅ move suppression\n✅ input setpoint tracking\n✅ economic costs (economic model predictive control)\n⬜ terminal cost to ensure nominal stability\n✅ soft and hard constraints on:\n✅ output predictions\n✅ manipulated inputs\n✅ manipulated inputs increments\n⬜ custom manipulated input constraints that are a function of the predictions\n✅ supported feedback strategy:\n✅ state estimator (see State Estimation features)\n✅ internal model structure with a custom stochastic model\n✅ offset-free tracking with a single or multiple integrators on measured outputs\n✅ support for unmeasured model outputs\n✅ feedforward action with measured disturbances that supports direct transmission\n✅ custom predictions for:\n✅ output setpoints\n✅ measured disturbances\n✅ easy integration with Plots.jl\n✅ optimization based on JuMP.jl:\n✅ quickly compare multiple optimizers\n✅ nonlinear solvers relying on automatic differentiation (exact derivative)\n✅ additional information about the optimum to ease troubleshooting","category":"page"},{"location":"#State-Estimation-Features","page":"Home","title":"State Estimation Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"⬜ supported state estimators/observers:\n✅ steady-state Kalman filter\n✅ Kalman filter\n⬜ Luenberger observer\n✅ internal model structure\n⬜ extended Kalman filter\n✅ unscented Kalman filter\n⬜ moving horizon estimator\n✅ observers in predictor form to ease  control applications\n⬜ moving horizon estimator that supports:\n⬜ inequality state constraints\n⬜ zero process noise equality constraint to reduce the problem size","category":"page"},{"location":"public/predictive_control/#Predictive-Controllers","page":"Predictive Controllers","title":"Predictive Controllers","text":"","category":"section"},{"location":"public/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"Pages = [\"predictive_control.md\"]","category":"page"},{"location":"public/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"All the predictive controllers in this module rely on a state estimator to compute the predictions. The default LinMPC estimator is a SteadyKalmanFilter, and NonLinMPC with nonlinear models, an UnscentedKalmanFilter. For simpler and more classical designs, an InternalModel structure is also available, that assumes by default that the current model mismatch estimation is constant in the future (same approach than dynamic matrix control, DMC).","category":"page"},{"location":"public/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"info: Info\nThe nomenclature uses hats for the predictions (or estimations, for the state estimators) e.g. mathbfY encompasses the future model outputs mathbfy over the prediction horizon H_p.","category":"page"},{"location":"public/predictive_control/#PredictiveController","page":"Predictive Controllers","title":"PredictiveController","text":"","category":"section"},{"location":"public/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"PredictiveController","category":"page"},{"location":"public/predictive_control/#ModelPredictiveControl.PredictiveController","page":"Predictive Controllers","title":"ModelPredictiveControl.PredictiveController","text":"Abstract supertype of all predictive controllers.\n\n\n\n(mpc::PredictiveController)(ry, d=Float64[]; kwargs...)\n\nFunctor allowing callable PredictiveController object as an alias for moveinput!.\n\nExamples\n\njulia> mpc = LinMPC(LinModel(tf(5, [2, 1]), 3), Nwt=[0], Hp=1000, Hc=1);\n\njulia> u = mpc([5]); round.(u, digits=3)\n1-element Vector{Float64}:\n 1.0\n\n\n\n\n\n","category":"type"},{"location":"public/predictive_control/#LinMPC","page":"Predictive Controllers","title":"LinMPC","text":"","category":"section"},{"location":"public/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"LinMPC","category":"page"},{"location":"public/predictive_control/#ModelPredictiveControl.LinMPC","page":"Predictive Controllers","title":"ModelPredictiveControl.LinMPC","text":"LinMPC(model::LinModel; <keyword arguments>)\n\nConstruct a linear predictive controller based on LinModel model.\n\nThe controller minimizes the following objective function at each discrete time k:\n\nmin_mathbfΔU ϵ    mathbf(R_y - Y) mathbfM_H_p mathbf(R_y - Y)   \n                       + mathbf(ΔU)      mathbfN_H_c mathbf(ΔU)  \n                       + mathbf(R_u - U) mathbfL_H_p mathbf(R_u - U) \n                       + C ϵ^2\n\nin which the weight matrices are repeated H_p or H_c times:\n\nbeginaligned\n    mathbfM_H_p = textdiagmathbf(MMM)     \n    mathbfN_H_c = textdiagmathbf(NNN)     \n    mathbfL_H_p = textdiagmathbf(LLL)     \nendaligned\n\nand with the following nomenclature:\n\nVARIABLE DESCRIPTION SIZE\nH_p prediction horizon (integer) ()\nH_c control horizon (integer) ()\nmathbfΔU manipulated input increments over H_c (nu*Hc,)\nmathbfY predicted outputs over H_p (ny*Hp,)\nmathbfU manipulated inputs over H_p (nu*Hp,)\nmathbfR_y predicted output setpoints over H_p (ny*Hp,)\nmathbfR_u predicted manipulated input setpoints over H_p (nu*Hp,)\nmathbfM output setpoint tracking weights (ny*Hp, ny*Hp)\nmathbfN manipulated input increment weights (nu*Hc, nu*Hc)\nmathbfL manipulated input setpoint tracking weights (nu*Hp, nu*Hp)\nC slack variable weight ()\nϵ slack variable for constraint softening ()\n\nThe mathbfΔU vector includes the manipulated input increments mathbfΔu(k+j) =  mathbfu(k+j) - mathbfu(k+j-1) from j=0 to H_c-1, the mathbfY vector,  the output predictions mathbfy(k+j) from j=1 to H_p, and the mathbfU  vector, the manipulated inputs mathbfu(k+j) from j=0 to H_p-1. The  manipulated input setpoint predictions mathbfR_u are constant at mathbfr_u.\n\nThis method uses the default state estimator, a SteadyKalmanFilter with default arguments.\n\nArguments\n\nmodel::LinModel : model used for controller predictions and state estimations.\nHp=10+nk: prediction horizon H_p, nk is the number of delays in model.\nHc=2 : control horizon H_c.\nMwt=fill(1.0,model.ny) : main diagonal of mathbfM weight matrix (vector)\nNwt=fill(0.1,model.nu) : main diagonal of mathbfN weight matrix (vector)\nLwt=fill(0.0,model.nu) : main diagonal of mathbfL weight matrix (vector)\nCwt=1e5 : slack variable weight C (scalar), use Cwt=Inf for hard constraints only\nru=model.uop : manipulated input setpoints mathbfr_u (vector)\noptim=JuMP.Model(OSQP.MathOptInterfaceOSQP.Optimizer) : quadratic optimizer used in the predictive controller, provided as a JuMP.Model (default to OSQP.jl optimizer)\n\nExamples\n\njulia> model = LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 4);\n\njulia> mpc = LinMPC(model, Mwt=[0, 1], Nwt=[0.5], Hp=30, Hc=1)\nLinMPC controller with a sample time Ts = 4.0 s, SteadyKalmanFilter estimator and:\n 1 manipulated inputs u\n 4 states x̂\n 2 measured outputs ym\n 0 unmeasured outputs yu\n 0 measured disturbances d\n\nExtended Help\n\nManipulated inputs setpoints mathbfr_u are not common but they can be interesting for over-actuated systems, when nu > ny (e.g. prioritize solutions with lower economical  costs). The default Lwt value implies that this feature is disabled by default.\n\n\n\n\n\nLinMPC(estim::StateEstimator; <keyword arguments>)\n\nUse custom state estimator estim to construct LinMPC.\n\nestim.model must be a LinModel. Else, a NonLinMPC is required. \n\nExamples\n\njulia> estim = KalmanFilter(LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 4), i_ym=[2]);\n\njulia> mpc = LinMPC(estim, Mwt=[0, 1], Nwt=[0.5], Hp=30, Hc=1)\nLinMPC controller with a sample time Ts = 4.0 s, KalmanFilter estimator and:\n 1 manipulated inputs u\n 3 states x̂\n 1 measured outputs ym\n 1 unmeasured outputs yu\n 0 measured disturbances d\n\n\n\n\n\n","category":"type"},{"location":"public/predictive_control/#NonLinMPC","page":"Predictive Controllers","title":"NonLinMPC","text":"","category":"section"},{"location":"public/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"NonLinMPC","category":"page"},{"location":"public/predictive_control/#ModelPredictiveControl.NonLinMPC","page":"Predictive Controllers","title":"ModelPredictiveControl.NonLinMPC","text":"NonLinMPC(model::SimModel; <keyword arguments>)\n\nConstruct a nonlinear predictive controller based on SimModel model.\n\nBoth NonLinModel and LinModel are supported (see Extended Help). The  controller minimizes the following objective function at each discrete time k:\n\nmin_mathbfΔU ϵ    mathbf(R_y - Y) mathbfM_H_p mathbf(R_y - Y)   \n                       + mathbf(ΔU)      mathbfN_H_c mathbf(ΔU)  \n                       + mathbf(R_u - U) mathbfL_H_p mathbf(R_u - U) \n                       + C ϵ^2  +  E J_E(mathbfU_E mathbfY_E mathbfD_E)\n\nSee LinMPC for the variable definitions. The custom economic function J_E can penalizes solutions with high economic costs. Setting all the weights to 0 except E  creates a pure economic model predictive controller (EMPC). The arguments of J_E are  the manipulated inputs, the predicted outputs and measured disturbances from k to  k+H_p inclusively:\n\n    mathbfU_E = beginbmatrix mathbfU       mathbfu(k+H_p-1)   endbmatrix  text qquad\n    mathbfY_E = beginbmatrix mathbfy(k)    mathbfY            endbmatrix  text qquad\n    mathbfD_E = beginbmatrix mathbfd(k)    mathbfD            endbmatrix\n\nsince H_c  H_p implies that mathbfu(k+H_p) = mathbfu(k+H_p-1). The vector mathbfD includes the predicted measured disturbance over H_p.\n\ntip: Tip\nReplace any of the 3 arguments with _ if not needed (see JE default value below).\n\nThis method uses the default state estimator :\n\nif model is a LinModel, a SteadyKalmanFilter with default arguments;\nelse, an UnscentedKalmanFilter with default arguments. \n\nwarning: Warning\nSee Extended Help if you get an error like MethodError: no method matching  Float64(::ForwardDiff.Dual).\n\nArguments\n\nmodel::SimModel : model used for controller predictions and state estimations.\nHp=10: prediction horizon H_p.\nHc=2 : control horizon H_c.\nMwt=fill(1.0,model.ny) : main diagonal of mathbfM weight matrix (vector)\nNwt=fill(0.1,model.nu) : main diagonal of mathbfN weight matrix (vector)\nLwt=fill(0.0,model.nu) : main diagonal of mathbfL weight matrix (vector)\nCwt=1e5 : slack variable weight C (scalar), use Cwt=Inf for hard constraints only\nEwt=0.0 : economic costs weight E (scalar). \nJE=(_,_,_)->0.0 : economic function J_E(mathbfU_E mathbfD_E mathbfY_E).\nru=model.uop : manipulated input setpoints mathbfr_u (vector)\noptim=JuMP.Model(Ipopt.Optimizer) : nonlinear optimizer used in the predictive   controller, provided as a JuMP.Model  (default to Ipopt.jl optimizer)\n\nExamples\n\njulia> model = NonLinModel((x,u,_)->0.5x+u, (x,_)->2x, 10, 1, 1, 1);\n\njulia> mpc = NonLinMPC(model, Hp=20, Hc=1, Cwt=1e6)\nNonLinMPC controller with a sample time Ts = 10.0 s, UnscentedKalmanFilter estimator and:\n 1 manipulated inputs u\n 2 states x̂\n 1 measured outputs ym\n 0 unmeasured outputs yu\n 0 measured disturbances d\n\nExtended Help\n\nNonLinMPC controllers based on LinModel compute the predictions with matrix  algebra instead of a for loop. This feature can accelerate the optimization and is not  available in any other package, to my knowledge.\n\nThe optimizations rely on JuMP.jl automatic  differentiation (AD) to compute the objective and constraint derivatives. Optimizers  generally benefit from exact derivatives like AD. However, the NonLinModel f  and h functions must be compatible with this feature. See Automatic differentiation for common mistakes when writing these functions.\n\n\n\n\n\nNonLinMPC(estim::StateEstimator; <keyword arguments>)\n\nUse custom state estimator estim to construct NonLinMPC.\n\nExamples\n\njulia> model = NonLinModel((x,u,_)->0.5x+u, (x,_)->2x, 10, 1, 1, 1);\n\njulia> estim = UnscentedKalmanFilter(model, σQ_int=[0.05]);\n\njulia> mpc = NonLinMPC(estim, Hp=20, Hc=1, Cwt=1e6)\nNonLinMPC controller with a sample time Ts = 10.0 s, UnscentedKalmanFilter estimator and:\n 1 manipulated inputs u\n 2 states x̂\n 1 measured outputs ym\n 0 unmeasured outputs yu\n 0 measured disturbances d\n\n\n\n\n\n","category":"type"},{"location":"public/predictive_control/#Set-Constraint","page":"Predictive Controllers","title":"Set Constraint","text":"","category":"section"},{"location":"public/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"setconstraint!","category":"page"},{"location":"public/predictive_control/#ModelPredictiveControl.setconstraint!","page":"Predictive Controllers","title":"ModelPredictiveControl.setconstraint!","text":"setconstraint!(mpc::PredictiveController; <keyword arguments>)\n\nSet the constraint parameters of mpc predictive controller.\n\nThe predictive controllers support both soft and hard constraints, defined by:\n\nbeginalignat*3\n    mathbfu_min  - c_u_min  ϵ  mathbfu(k+j)   mathbfu_max  + c_u_max  ϵ qquad j = 0 1  H_c - 1 \n    mathbfΔu_min - c_Δu_min ϵ  mathbfΔu(k+j)  mathbfΔu_max + c_Δu_max ϵ qquad j = 0 1  H_c - 1 \n    mathbfy_min  - c_y_min  ϵ  mathbfy(k+j)   mathbfy_max  + c_y_max  ϵ qquad j = 1 2  H_p \nendalignat*\n\nand also ϵ  0. All the constraint parameters are vector. Use ±Inf values when there  is no bound. The constraint softness parameters mathbfc, also called equal concern  for relaxation, are non-negative values that specify the softness of the associated bound.  Use 0.0 values for hard constraints. The predicted output constraints mathbfy_min  and mathbfy_max are soft by default.\n\nArguments\n\ninfo: Info\nThe default constraints are mentioned here for clarity but omitting a keyword argument  will not re-assign to its default value (defaults are set at construction only).\n\numin=fill(-Inf,nu) : manipulated input lower bounds mathbfu_min \numax=fill(+Inf,nu) : manipulated input upper bounds mathbfu_max \nΔumin=fill(-Inf,nu) : manipulated input increment lower bounds mathbfΔu_min \nΔumax=fill(+Inf,nu) : manipulated input increment upper bounds mathbfΔu_max \nŷmin=fill(-Inf,ny) : predicted output lower bounds mathbfy_min \nŷmax=fill(+Inf,ny) : predicted output upper bounds mathbfy_max \nc_umin=fill(0.0,nu) : umin softness weights mathbfc_u_min \nc_umax=fill(0.0,nu) : umax softness weights mathbfc_u_max \nc_Δumin=fill(0.0,nu) : Δumin softness weights mathbfc_Δu_min \nc_Δumax=fill(0.0,nu) : Δumax softness weights mathbfc_Δu_max \nc_ŷmin=fill(1.0,ny) : ŷmin softness weights mathbfc_y_min \nc_ŷmax=fill(1.0,ny) : ŷmax softness weights mathbfc_y_max\n\n\n\n\n\n","category":"function"},{"location":"public/predictive_control/#Move-Manipulated-Input","page":"Predictive Controllers","title":"Move Manipulated Input","text":"","category":"section"},{"location":"public/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"moveinput!","category":"page"},{"location":"public/predictive_control/#ModelPredictiveControl.moveinput!","page":"Predictive Controllers","title":"ModelPredictiveControl.moveinput!","text":"moveinput!(\n    mpc::PredictiveController, \n    ry, \n    d  = Float64[];\n    R̂y = repeat(ry, mpc.Hp), \n    D̂  = repeat(d,  mpc.Hp), \n    ym = nothing\n)\n\nCompute the optimal manipulated input value u for the current control period.\n\nSolve the optimization problem of mpc PredictiveController and return the  results mathbfu(k). Following the receding horizon principle, the algorithm discards  the optimal future manipulated inputs mathbfu(k+1) mathbfu(k+2)... The  arguments ry and d are current output setpoints mathbfr_y(k) and measured  disturbances mathbfd(k). The predicted output setpoint R̂y and measured disturbances  D̂ are defined as:\n\n    mathbfR_y = beginbmatrix\n        mathbfr_y(k+1)   \n        mathbfr_y(k+2)   \n        vdots              \n        mathbfr_y(k+H_p)\n    endbmatrix                   qquad textand qquad\n    mathbfD   = beginbmatrix\n        mathbfd(k+1)     \n        mathbfd(k+2)     \n        vdots              \n        mathbfd(k+H_p)\n    endbmatrix\n\nThey are assumed constant in the future by default, that is  mathbfr_y(k+j) = mathbfr_y(k) and mathbfd(k+j) = mathbfd(k) for j=1 to H_p. Current measured outputs ym (keyword argument) are only required if  mpc.estim is a InternalModel.\n\nSee also LinMPC, NonLinMPC.\n\nExamples\n\njulia> mpc = LinMPC(LinModel(tf(5, [2, 1]), 3), Nwt=[0], Hp=1000, Hc=1);\n\njulia> u = moveinput!(mpc, [5]); round.(u, digits=3)\n1-element Vector{Float64}:\n 1.0\n\n\n\n\n\n","category":"function"},{"location":"public/predictive_control/#Get-Additional-Information","page":"Predictive Controllers","title":"Get Additional Information","text":"","category":"section"},{"location":"public/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"getinfo","category":"page"},{"location":"public/predictive_control/#ModelPredictiveControl.getinfo","page":"Predictive Controllers","title":"ModelPredictiveControl.getinfo","text":"getinfo(mpc::PredictiveController)\n\nGet additional information about mpc controller optimum to ease troubleshooting.\n\nReturn the dictionary info with the additional information, and sol_summary, the optimizer solution summary that can be printed. The dictionary info has the following  fields:\n\n:ΔU : optimal manipulated input increments over Hc (mathbfΔU)\n:ϵ  : optimal slack variable (ϵ)\n:J  : objective value optimum (J)\n:U  : optimal manipulated inputs over Hp (mathbfU)\n:u  : current optimal manipulated input (mathbfu)\n:d  : current measured disturbance (mathbfd)\n:D̂  : predicted measured disturbances over Hp (mathbfD)\n:ŷ  : current estimated output (mathbfy)\n:Ŷ  : optimal predicted outputs over Hp (mathbfY = Y_d + Y_s)\n:Ŷd : optimal predicted deterministic output over Hp (mathbfY_d)\n:Ŷs : predicted stochastic output over Hp (mathbfY_s)\n:R̂y : predicted output setpoint over Hp (mathbfR_y)\n:R̂u : predicted manipulated input setpoint over Hp (mathbfR_u)\n\nExamples\n\njulia> mpc = LinMPC(LinModel(tf(5, [2, 1]), 3), Nwt=[0], Hp=1000, Hc=1);\n\njulia> u = moveinput!(mpc, [5]);\n\njulia> info, sol_summary = getinfo(mpc); round.(info[:Ŷ][end], digits=2)\n5.0\n\n\n\n\n\ngetinfo(mpc::NonLinMPC)\n\nInvoke getinfo(::PredictiveController) and add :JE the economic optimum J_E.\n\n\n\n\n\n","category":"function"},{"location":"internals/sim_model/#SimModel-Internals","page":"Plant Models","title":"SimModel Internals","text":"","category":"section"},{"location":"internals/sim_model/","page":"Plant Models","title":"Plant Models","text":"ModelPredictiveControl.steadystate\nModelPredictiveControl.f\nModelPredictiveControl.h","category":"page"},{"location":"internals/sim_model/#ModelPredictiveControl.steadystate","page":"Plant Models","title":"ModelPredictiveControl.steadystate","text":"steadystate(model::LinModel, u, d=Float64[])\n\nEvaluate the steady-state vector when model is a LinModel.\n\nOmitting the operating points, the method evaluates the equilibrium mathbfx() from:\n\n    mathbfx() = mathbf(I - A)^-1(B_u u + B_d d)\n\nwith the manipulated inputs held constant at mathbfu and, the measured disturbances,  at mathbfd. The Moore-Penrose pseudo-inverse computes mathbf(I - A)^-1 to support integrating model (integrator states will be 0).\n\n\n\n\n\n","category":"function"},{"location":"internals/sim_model/#ModelPredictiveControl.f","page":"Plant Models","title":"ModelPredictiveControl.f","text":"f(model::LinModel, x, u, d)\n\nEvaluate mathbfA x + B_u u + B_d d when model is a LinModel.\n\n\n\n\n\nCall mathbff(x u d) with model.f function for NonLinModel.\n\n\n\n\n\n","category":"function"},{"location":"internals/sim_model/#ModelPredictiveControl.h","page":"Plant Models","title":"ModelPredictiveControl.h","text":"h(model::LinModel, x, u, d)\n\nEvaluate mathbfC x + D_d d when model is a LinModel.\n\n\n\n\n\nCall mathbfh(x d) with model.h function for NonLinModel.\n\n\n\n\n\n","category":"function"}]
}
