<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>State Estimators · ModelPredictiveControl.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelPredictiveControl.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../manual/">Manual</a></li><li><span class="tocitem">Functions</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox" checked/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Public</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../sim_model/">Plant Models</a></li><li class="is-active"><a class="tocitem" href>State Estimators</a><ul class="internal"><li><a class="tocitem" href="#StateEstimator"><span>StateEstimator</span></a></li><li><a class="tocitem" href="#SteadyKalmanFilter"><span>SteadyKalmanFilter</span></a></li><li><a class="tocitem" href="#KalmanFilter"><span>KalmanFilter</span></a></li><li><a class="tocitem" href="#UnscentedKalmanFilter"><span>UnscentedKalmanFilter</span></a></li><li><a class="tocitem" href="#InternalModel"><span>InternalModel</span></a></li></ul></li><li><a class="tocitem" href="../predictive_control/">Predictive Controllers</a></li><li><a class="tocitem" href="../generic_func/">Generic Functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../internals/sim_model/">Plant Models</a></li><li><a class="tocitem" href="../../internals/state_estim/">State Estimators</a></li><li><a class="tocitem" href="../../internals/predictive_control/">Predictive Controllers</a></li></ul></li></ul></li><li><a class="tocitem" href="../../func_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functions</a></li><li><a class="is-disabled">Public</a></li><li class="is-active"><a href>State Estimators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>State Estimators</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/franckgaga/ModelPredictiveControl.jl/blob/main/docs/src/public/state_estim.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="State-Estimators"><a class="docs-heading-anchor" href="#State-Estimators">State Estimators</a><a id="State-Estimators-1"></a><a class="docs-heading-anchor-permalink" href="#State-Estimators" title="Permalink"></a></h1><ul><li><a href="#State-Estimators">State Estimators</a></li><li class="no-marker"><ul><li><a href="#StateEstimator">StateEstimator</a></li><li><a href="#SteadyKalmanFilter">SteadyKalmanFilter</a></li><li><a href="#KalmanFilter">KalmanFilter</a></li><li><a href="#UnscentedKalmanFilter">UnscentedKalmanFilter</a></li><li><a href="#InternalModel">InternalModel</a></li></ul></li></ul><p>This module includes many state estimators (or state observer), both for deterministic and stochastic systems. The implementations focus on control applications, that is, relying on the estimates to compute a <a href="https://en.wikipedia.org/wiki/Full_state_feedback">full state feedback</a> (predictive controllers, in this package). They all incorporates some kind of integral action by default, since it is generally desired to eliminate the steady-state error with closed-loop control (offset-free tracking).</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>If you plan to use the estimators for other contexts than this specific package (e.g. : filter, parameter estimation, etc.), careful must be taken at construction since the integral action is not necessarily desired. The option <code>nint_ym=0</code> disable it.</p></div></div><p>The estimators are all implemented in the predictor form (a.k.a. observer form), that is, they all estimates at each discrete time <span>$k$</span> the states of the next period <span>$\mathbf{x̂}_k(k+1)$</span>. In contrast, the filter form that estimates <span>$\mathbf{x̂}_k(k)$</span> is sometimes slightly more accurate.</p><p>The predictor form comes in handy for control applications since the estimations come after the controller computations, without introducing any additional delays. Moreover, the <a href="../predictive_control/#ModelPredictiveControl.moveinput!"><code>moveinput!</code></a> method of the predictive controllers does not automatically update the estimates with <a href="../generic_func/#ModelPredictiveControl.updatestate!"><code>updatestate!</code></a>. This allows applying the calculated inputs on the real plant before starting the potentially expensive estimator computations (see <a href="../../manual/#Manual">Manual</a> for examples).</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>All the estimators support measured <span>$\mathbf{y^m}$</span> and unmeasured <span>$\mathbf{y^u}$</span> model outputs, where <span>$\mathbf{y}$</span> refers to all of them.</p></div></div><h2 id="StateEstimator"><a class="docs-heading-anchor" href="#StateEstimator">StateEstimator</a><a id="StateEstimator-1"></a><a class="docs-heading-anchor-permalink" href="#StateEstimator" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelPredictiveControl.StateEstimator" href="#ModelPredictiveControl.StateEstimator"><code>ModelPredictiveControl.StateEstimator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract supertype of all state estimators.</p><hr/><pre><code class="nohighlight hljs">(estim::StateEstimator)(d=Float64[])</code></pre><p>Functor allowing callable <code>StateEstimator</code> object as an alias for <a href="../generic_func/#ModelPredictiveControl.evaloutput"><code>evaloutput</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; kf = KalmanFilter(setop!(LinModel(tf(3, [10, 1]), 2), yop=[20]));

julia&gt; ŷ = kf() 
1-element Vector{Float64}:
 20.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/franckgaga/ModelPredictiveControl.jl/blob/097d43054054ba50b1d99fd1d12090d988fcbcce/src/state_estim.jl#L1-L18">source</a></section></article><h2 id="SteadyKalmanFilter"><a class="docs-heading-anchor" href="#SteadyKalmanFilter">SteadyKalmanFilter</a><a id="SteadyKalmanFilter-1"></a><a class="docs-heading-anchor-permalink" href="#SteadyKalmanFilter" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelPredictiveControl.SteadyKalmanFilter" href="#ModelPredictiveControl.SteadyKalmanFilter"><code>ModelPredictiveControl.SteadyKalmanFilter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SteadyKalmanFilter(model::LinModel; &lt;keyword arguments&gt;)</code></pre><p>Construct a steady-state Kalman Filter with the <a href="../sim_model/#ModelPredictiveControl.LinModel"><code>LinModel</code></a> <code>model</code>.</p><p>The steady-state (or asymptotic) Kalman filter is based on the process model :</p><p class="math-container">\[\begin{aligned}
    \mathbf{x}(k+1) &amp;= 
            \mathbf{Â x}(k) + \mathbf{B̂_u u}(k) + \mathbf{B̂_d d}(k) + \mathbf{w}(k) \\
    \mathbf{y^m}(k) &amp;= \mathbf{Ĉ^m x}(k) + \mathbf{D̂_d^m d}(k) + \mathbf{v}(k) \\
    \mathbf{y^u}(k) &amp;= \mathbf{Ĉ^u x}(k) + \mathbf{D̂_d^u d}(k)
\end{aligned}\]</p><p>with sensor <span>$\mathbf{v}(k)$</span> and process <span>$\mathbf{w}(k)$</span> noises as uncorrelated zero mean  white noise vectors, with a respective covariance of <span>$\mathbf{R̂}$</span> and <span>$\mathbf{Q̂}$</span>.  The arguments are in standard deviations σ, i.e. same units than outputs and states. The  matrices <span>$\mathbf{Â, B̂_u, B̂_d, Ĉ, D̂_d}$</span> are <code>model</code> matrices augmented with the stochastic model, which is specified by the numbers of output integrator <code>nint_ym</code> (see Extended Help).  Likewise, the covariance matrices are augmented with <span>$\mathbf{Q̂ = \text{diag}(Q, Q_{int})}$</span>  and <span>$\mathbf{R̂ = R}$</span>. The matrices <span>$\mathbf{Ĉ^m, D̂_d^m}$</span> are the rows of  <span>$\mathbf{Ĉ, D̂_d}$</span> that correspond to measured outputs <span>$\mathbf{y^m}$</span> (and unmeasured  ones, for <span>$\mathbf{Ĉ^u, D̂_d^u}$</span>).</p><p><strong>Arguments</strong></p><ul><li><code>model::LinModel</code> : (deterministic) model for the estimations.</li><li><code>i_ym=1:model.ny</code> : <code>model</code> output indices that are measured <span>$\mathbf{y^m}$</span>, the rest    are unmeasured <span>$\mathbf{y^u}$</span>.</li><li><code>σQ=fill(0.1,model.nx)</code> : main diagonal of the process noise covariance <span>$\mathbf{Q}$</span> of   <code>model</code>, specified as a standard deviation vector.</li><li><code>σR=fill(0.1,length(i_ym))</code> : main diagonal of the sensor noise covariance <span>$\mathbf{R}$</span>   of <code>model</code> measured outputs, specified as a standard deviation vector.</li><li><code>nint_ym=fill(1,length(i_ym))</code> : integrator quantity per measured outputs (vector) for the    stochastic model, use <code>nint_ym=0</code> for no integrator at all.</li><li><code>σQ_int=fill(0.1,sum(nint_ym))</code> : same than <code>σQ</code> but for the stochastic model covariance   <span>$\mathbf{Q_{int}}$</span> (composed of output integrators).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 0.5);

julia&gt; estim = SteadyKalmanFilter(model, i_ym=[2], σR=[1], σQ_int=[0.01])
SteadyKalmanFilter estimator with a sample time Ts = 0.5 s and:
 1 manipulated inputs u
 3 states x̂
 1 measured outputs ym
 1 unmeasured outputs yu
 0 measured disturbances d</code></pre><p><strong>Extended Help</strong></p><p>The model augmentation with <code>nint_ym</code> vector produces the integral action when the estimator is used in a controller as state feedback. The default is 1 integrator per measured outputs, resulting in an offset-free tracking for &quot;step-like&quot; unmeasured output disturbances. Use 2  integrators for &quot;ramp-like&quot; disturbances. See <a href="../../internals/state_estim/#ModelPredictiveControl.init_estimstoch"><code>init_estimstoch</code></a>.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Increasing <code>σQ_int</code> values increases the integral action &quot;gain&quot;.</p></div></div><p>The constructor pre-compute the steady-state Kalman gain <code>K</code> with the <a href="https://juliacontrol.github.io/ControlSystems.jl/stable/lib/synthesis/#ControlSystemsBase.kalman-Tuple{Any,%20Any,%20Any,%20Any,%20Any,%20Vararg{Any}}"><code>kalman</code></a> function. It can sometimes fail, for example when <code>model</code> is integrating. In such a case, you can use 0 integrator on <code>model</code> integrating outputs, or the alternative time-varying  <a href="#ModelPredictiveControl.KalmanFilter"><code>KalmanFilter</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/franckgaga/ModelPredictiveControl.jl/blob/097d43054054ba50b1d99fd1d12090d988fcbcce/src/estimator/kalman.jl#L60-L123">source</a></section></article><h2 id="KalmanFilter"><a class="docs-heading-anchor" href="#KalmanFilter">KalmanFilter</a><a id="KalmanFilter-1"></a><a class="docs-heading-anchor-permalink" href="#KalmanFilter" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelPredictiveControl.KalmanFilter" href="#ModelPredictiveControl.KalmanFilter"><code>ModelPredictiveControl.KalmanFilter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KalmanFilter(model::LinModel; &lt;keyword arguments&gt;)</code></pre><p>Construct a time-varying Kalman Filter with the <a href="../sim_model/#ModelPredictiveControl.LinModel"><code>LinModel</code></a> <code>model</code>.</p><p>The process model is identical to <a href="#ModelPredictiveControl.SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a>. The matrix  <span>$\mathbf{P̂}_k(k+1)$</span> is the estimation error covariance of <code>model</code> states augmented with the stochastic ones (specified by <code>nint_ym</code>). Two keyword arguments modify its initial value with <span>$\mathbf{P̂}_{-1}(0) = \mathrm{diag}\{ \mathbf{P}(0), \mathbf{P_{int}}(0) \}$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>model::LinModel</code> : (deterministic) model for the estimations.</li><li><code>σP0=fill(10,model.nx)</code> : main diagonal of the initial estimate covariance    <span>$\mathbf{P}(0)$</span>, specified as a standard deviation vector.</li><li><code>σP0_int=fill(10,sum(nint_ym))</code> : same than <code>σP0</code> but for the stochastic model   covariance <span>$\mathbf{P_{int}}(0)$</span> (composed of output integrators).</li><li><code>&lt;keyword arguments&gt;</code> of <a href="#ModelPredictiveControl.SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a> constructor.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 0.5);

julia&gt; estim = KalmanFilter(model, i_ym=[2], σR=[1], σP0=[100, 100], σQ_int=[0.01])
KalmanFilter estimator with a sample time Ts = 0.5 s and:
 1 manipulated inputs u
 3 states x̂
 1 measured outputs ym
 1 unmeasured outputs yu
 0 measured disturbances d</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/franckgaga/ModelPredictiveControl.jl/blob/097d43054054ba50b1d99fd1d12090d988fcbcce/src/estimator/kalman.jl#L224-L254">source</a></section></article><h2 id="UnscentedKalmanFilter"><a class="docs-heading-anchor" href="#UnscentedKalmanFilter">UnscentedKalmanFilter</a><a id="UnscentedKalmanFilter-1"></a><a class="docs-heading-anchor-permalink" href="#UnscentedKalmanFilter" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelPredictiveControl.UnscentedKalmanFilter" href="#ModelPredictiveControl.UnscentedKalmanFilter"><code>ModelPredictiveControl.UnscentedKalmanFilter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UnscentedKalmanFilter(model::SimModel; &lt;keyword arguments&gt;)</code></pre><p>Construct an unscented Kalman Filter with the <a href="../sim_model/#ModelPredictiveControl.SimModel"><code>SimModel</code></a> <code>model</code>.</p><p>Both <a href="../sim_model/#ModelPredictiveControl.LinModel"><code>LinModel</code></a> and <a href="../sim_model/#ModelPredictiveControl.NonLinModel"><code>NonLinModel</code></a> are supported. The unscented Kalman filter is based on the process model :</p><p class="math-container">\[\begin{aligned}
    \mathbf{x}(k+1) &amp;= \mathbf{f̂}\Big(\mathbf{x̂}(k), \mathbf{u}(k), \mathbf{d}(k)\Big) 
                        + \mathbf{w}(k)                                                   \\
    \mathbf{y^m}(k) &amp;= \mathbf{ĥ^m}\Big(\mathbf{x̂}(k), \mathbf{d}(k)\Big) + \mathbf{v}(k) \\
    \mathbf{y^u}(k) &amp;= \mathbf{ĥ^u}\Big(\mathbf{x̂}(k), \mathbf{d}(k)\Big)                 \\
\end{aligned}\]</p><p>See <a href="#ModelPredictiveControl.SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a> for details on <span>$\mathbf{v}(k), \mathbf{w}(k)$</span> noises and  <span>$\mathbf{R̂}, \mathbf{Q̂}$</span> covariances. The functions <span>$\mathbf{f̂, ĥ}$</span> are <code>model</code>  state-space functions augmented with the stochastic model, which is specified by the numbers of output integrator <code>nint_ym</code> (see <a href="#ModelPredictiveControl.SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a> for details). The  <span>$\mathbf{ĥ^m}$</span> function represents the measured outputs of <span>$\mathbf{ĥ}$</span> function (and  unmeasured ones, for <span>$\mathbf{ĥ^u}$</span>).</p><p><strong>Arguments</strong></p><ul><li><code>model::SimModel</code> : (deterministic) model for the estimations.</li><li><code>α=1e-3</code> : alpha parameter, spread of the state distribution <span>$(0 ≤ α ≤ 1)$</span>.</li><li><code>β=2</code> : beta parameter, skewness and kurtosis of the states distribution <span>$(β ≥ 0)$</span>.</li><li><code>κ=0</code> : kappa parameter, another spread parameter <span>$(0 ≤ κ ≤ 3)$</span>.</li><li><code>&lt;keyword arguments&gt;</code> of <a href="#ModelPredictiveControl.SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a> constructor.</li><li><code>&lt;keyword arguments&gt;</code> of <a href="#ModelPredictiveControl.KalmanFilter"><code>KalmanFilter</code></a> constructor.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = NonLinModel((x,u,_)-&gt;0.1x+u, (x,_)-&gt;2x, 10, 1, 1, 1);

julia&gt; estim = UnscentedKalmanFilter(model, σR=[1], nint_ym=[2], σP0_int=[1, 1])
UnscentedKalmanFilter{NonLinModel} estimator with a sample time Ts = 10.0 s and:
 1 manipulated inputs u
 3 states x̂
 1 measured outputs ym
 0 unmeasured outputs yu
 0 measured disturbances d</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/franckgaga/ModelPredictiveControl.jl/blob/097d43054054ba50b1d99fd1d12090d988fcbcce/src/estimator/kalman.jl#L375-L417">source</a></section></article><h2 id="InternalModel"><a class="docs-heading-anchor" href="#InternalModel">InternalModel</a><a id="InternalModel-1"></a><a class="docs-heading-anchor-permalink" href="#InternalModel" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelPredictiveControl.InternalModel" href="#ModelPredictiveControl.InternalModel"><code>ModelPredictiveControl.InternalModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InternalModel(model::SimModel; i_ym=1:model.ny, stoch_ym=ss(1,1,1,1,model.Ts).*I)</code></pre><p>Construct an internal model estimator based on <code>model</code> (<a href="../sim_model/#ModelPredictiveControl.LinModel"><code>LinModel</code></a> or <a href="../sim_model/#ModelPredictiveControl.NonLinModel"><code>NonLinModel</code></a>).</p><p><code>i_ym</code> provides the <code>model</code> output indices that are measured <span>$\mathbf{y^m}$</span>, the rest are  unmeasured <span>$\mathbf{y^u}$</span>. <code>model</code> evaluates the deterministic predictions  <span>$\mathbf{ŷ_d}$</span>, and <code>stoch_ym</code>, the stochastic predictions of the measured outputs  <span>$\mathbf{ŷ_s^m}$</span> (the unmeasured ones being <span>$\mathbf{ŷ_s^u=0}$</span>). The predicted outputs sum both values : <span>$\mathbf{ŷ = ŷ_d + ŷ_s}$</span>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>InternalModel</code> estimator does not work if <code>model</code> is integrating or unstable. The  constructor verifies these aspects for <code>LinModel</code> but not for <code>NonLinModel</code>. Uses any  other state estimator in such cases.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; estim = InternalModel(LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 0.5), i_ym=[2])
InternalModel{LinModel} estimator with a sample time Ts = 0.5 s and:
 1 manipulated inputs u
 2 states x̂
 1 measured outputs ym
 1 unmeasured outputs yu
 0 measured disturbances d</code></pre><p><strong>Extended Help</strong></p><p><code>stoch_ym</code> is a <code>TransferFunction</code> or <code>StateSpace</code> object that models disturbances on <span>$\mathbf{y^m}$</span>. Its input is a hypothetical zero mean white noise vector. <code>stoch_ym</code>  supposes 1 integrator per measured outputs by default, assuming that the current stochastic estimate <span>$\mathbf{ŷ_s^m}(k) = \mathbf{y^m}(k) - \mathbf{ŷ_d^m}(k)$</span> is constant in the  future. This is the dynamic matrix control (DMC) strategy, which is simple but sometimes too aggressive. Additional poles and zeros in <code>stoch_ym</code> can mitigate this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/franckgaga/ModelPredictiveControl.jl/blob/097d43054054ba50b1d99fd1d12090d988fcbcce/src/estimator/internal_model.jl#L47-L81">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sim_model/">« Plant Models</a><a class="docs-footer-nextpage" href="../predictive_control/">Predictive Controllers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 7 April 2023 16:42">Friday 7 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
