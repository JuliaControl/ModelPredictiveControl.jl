<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Nonlinear Design · ModelPredictiveControl.jl</title><meta name="title" content="Nonlinear Design · ModelPredictiveControl.jl"/><meta property="og:title" content="Nonlinear Design · ModelPredictiveControl.jl"/><meta property="twitter:title" content="Nonlinear Design · ModelPredictiveControl.jl"/><meta name="description" content="Documentation for ModelPredictiveControl.jl."/><meta property="og:description" content="Documentation for ModelPredictiveControl.jl."/><meta property="twitter:description" content="Documentation for ModelPredictiveControl.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="ModelPredictiveControl.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="ModelPredictiveControl.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelPredictiveControl.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../installation/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../linmpc/">Linear Design</a></li><li class="is-active"><a class="tocitem" href>Nonlinear Design</a><ul class="internal"><li><a class="tocitem" href="#Nonlinear-Model"><span>Nonlinear Model</span></a></li><li><a class="tocitem" href="#Nonlinear-Model-Predictive-Controller"><span>Nonlinear Model Predictive Controller</span></a></li><li><a class="tocitem" href="#Economic-Model-Predictive-Controller"><span>Economic Model Predictive Controller</span></a></li><li><a class="tocitem" href="#Linearizing-the-Model"><span>Linearizing the Model</span></a></li></ul></li></ul></li></ul></li><li><span class="tocitem">Functions</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Public</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../public/sim_model/">Plant Models</a></li><li><a class="tocitem" href="../../public/state_estim/">State Estimators</a></li><li><a class="tocitem" href="../../public/predictive_control/">Predictive Controllers</a></li><li><a class="tocitem" href="../../public/generic_func/">Generic Functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../internals/sim_model/">Plant Models</a></li><li><a class="tocitem" href="../../internals/state_estim/">State Estimators</a></li><li><a class="tocitem" href="../../internals/predictive_control/">Predictive Controllers</a></li></ul></li></ul></li><li><a class="tocitem" href="../../func_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Nonlinear Design</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Nonlinear Design</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/franckgaga/ModelPredictiveControl.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/franckgaga/ModelPredictiveControl.jl/blob/main/docs/src/manual/nonlinmpc.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="man_nonlin"><a class="docs-heading-anchor" href="#man_nonlin">Manual: Nonlinear Design</a><a id="man_nonlin-1"></a><a class="docs-heading-anchor-permalink" href="#man_nonlin" title="Permalink"></a></h1><ul><li><a href="#man_nonlin">Manual: Nonlinear Design</a></li><li class="no-marker"><ul><li><a href="#Nonlinear-Model">Nonlinear Model</a></li><li><a href="#Nonlinear-Model-Predictive-Controller">Nonlinear Model Predictive Controller</a></li><li><a href="#Economic-Model-Predictive-Controller">Economic Model Predictive Controller</a></li><li><a href="#Linearizing-the-Model">Linearizing the Model</a></li></ul></li></ul><h2 id="Nonlinear-Model"><a class="docs-heading-anchor" href="#Nonlinear-Model">Nonlinear Model</a><a id="Nonlinear-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-Model" title="Permalink"></a></h2><p>In this example, the goal is to control the angular position <span>$θ$</span> of a pendulum attached to a motor. Knowing that the manipulated input is the motor torque <span>$τ$</span>, the I/O vectors are:</p><p class="math-container">\[\begin{aligned}
    \mathbf{u} &amp;= τ \\
    \mathbf{y} &amp;= θ
\end{aligned}\]</p><p>The following figure presents the system:</p><p><img src="../../assets/pendulum.svg" alt="pendulum" width=200 style="background-color:white; 
    border:20px solid white; display: block; margin-left: auto; margin-right: auto;"/></p><p>The plant model is nonlinear:</p><p class="math-container">\[\begin{aligned}
    \dot{θ}(t) &amp;= ω(t) \\
    \dot{ω}(t) &amp;= -\frac{g}{L}\sin\big( θ(t) \big) - \frac{K}{m} ω(t) + \frac{1}{m L^2} τ(t)
\end{aligned}\]</p><p>in which <span>$g$</span> is the gravitational acceleration in m/s², <span>$L$</span>, the pendulum length in m, <span>$K$</span>, the friction coefficient at the pivot point in kg/s, and <span>$m$</span>, the mass attached at the end of the pendulum in kg. Here, the explicit Euler method discretizes the system to construct a <a href="../../public/sim_model/#ModelPredictiveControl.NonLinModel"><code>NonLinModel</code></a>:</p><pre><code class="language-julia hljs">using ModelPredictiveControl
function pendulum(par, x, u)
    g, L, K, m = par        # [m/s²], [m], [kg/s], [kg]
    θ, ω = x[1], x[2]       # [rad], [rad/s]
    τ  = u[1]               # [N m]
    dθ = ω
    dω = -g/L*sin(θ) - K/m*ω + τ/m/L^2
    return [dθ, dω]
end
# declared constants, to avoid type-instability in the f function, for speed:
const par, Ts = (9.8, 0.4, 1.2, 0.3), 0.1
f(x, u, _ ) = x + Ts*pendulum(par, x, u) # Euler method
h(x, _ )    = [180/π*x[1]]  # [°]
nu, nx, ny = 1, 2, 1
model = NonLinModel(f, h, Ts, nu, nx, ny)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Discrete-time nonlinear model with a sample time Ts = 0.1 s and:
 1 manipulated inputs u
 2 states x
 1 outputs y
 0 measured disturbances d</code></pre><p>The output function <span>$\mathbf{h}$</span> converts the <span>$θ$</span> angle to degrees. Note that special characters like <span>$θ$</span> can be typed in the Julia REPL or VS Code by typing <code>\theta</code> and pressing the <code>&lt;TAB&gt;</code> key. The tuple <code>par</code> and <code>Ts</code> are declared as constants here to improve the <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-untyped-global-variables">performance</a>. It is good practice to first simulate <code>model</code> using <a href="../../public/generic_func/#ModelPredictiveControl.sim!"><code>sim!</code></a> as a quick sanity check:</p><pre><code class="language-julia hljs">using Plots
u = [0.5]
N = 35
res = sim!(model, N, u)
plot(res, plotu=false)</code></pre><p><img src="../plot1_NonLinMPC.svg" alt="plot1_NonLinMPC"/></p><h2 id="Nonlinear-Model-Predictive-Controller"><a class="docs-heading-anchor" href="#Nonlinear-Model-Predictive-Controller">Nonlinear Model Predictive Controller</a><a id="Nonlinear-Model-Predictive-Controller-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-Model-Predictive-Controller" title="Permalink"></a></h2><p>An <a href="../../public/state_estim/#ModelPredictiveControl.UnscentedKalmanFilter"><code>UnscentedKalmanFilter</code></a> estimates the plant state :</p><pre><code class="language-julia hljs">σQ=[0.1, 0.5]; σR=[0.5]; nint_u=[1]; σQint_u=[0.1]
estim = UnscentedKalmanFilter(model; σQ, σR, nint_u, σQint_u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">UnscentedKalmanFilter estimator with a sample time Ts = 0.1 s, NonLinModel and:
 1 manipulated inputs u (1 integrating states)
 3 states x̂
 1 measured outputs ym (0 integrating states)
 0 unmeasured outputs yu
 0 measured disturbances d</code></pre><p>The vectors <code>σQ</code> and σR <code>σR</code> are the standard deviations of the process and sensor noises, respectively. The value for the velocity <span>$ω$</span> is higher here (<code>σQ</code> second value) since <span>$\dot{ω}(t)$</span> equation includes an uncertain parameter: the friction coefficient <span>$K$</span>. Also, the argument <code>nint_u</code> explicitly adds one integrating state at the model input, the motor torque <span>$τ$</span> , with an associated standard deviation <code>σQint_u</code> of 0.1 N m. The estimator tuning is tested on a plant with a 25 % larger friction coefficient <span>$K$</span>:</p><pre><code class="language-julia hljs">const par_plant = (par[1], par[2], 1.25*par[3], par[4])
f_plant(x, u, _) = x + Ts*pendulum(par_plant, x, u)
plant = NonLinModel(f_plant, h, Ts, nu, nx, ny)
res = sim!(estim, N, [0.5], plant=plant, y_noise=[0.5])
plot(res, plotu=false, plotxwithx̂=true)</code></pre><p><img src="../plot2_NonLinMPC.svg" alt="plot2_NonLinMPC"/></p><p>The estimate <span>$x̂_3$</span> is the integrating state on the torque <span>$τ$</span> that compensates for static errors. The Kalman filter performance seems sufficient for control.</p><p>As the motor torque is limited to -1.5 to 1.5 N m, we incorporate the input constraints in a <a href="../../public/predictive_control/#ModelPredictiveControl.NonLinMPC"><code>NonLinMPC</code></a>:</p><pre><code class="language-julia hljs">nmpc = NonLinMPC(estim, Hp=20, Hc=2, Mwt=[0.5], Nwt=[2.5])
nmpc = setconstraint!(nmpc, umin=[-1.5], umax=[+1.5])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NonLinMPC controller with a sample time Ts = 0.1 s, Ipopt optimizer, UnscentedKalmanFilter estimator and:
 20 prediction steps Hp
  2 control steps Hc
  1 manipulated inputs u (1 integrating states)
  3 states x̂
  1 measured outputs ym (0 integrating states)
  0 unmeasured outputs yu
  0 measured disturbances d</code></pre><p>We test <code>mpc</code> performance on <code>plant</code> by imposing an angular setpoint of 180° (inverted position):</p><pre><code class="language-julia hljs">res_ry = sim!(nmpc, N, [180.0], plant=plant, x0=[0, 0], x̂0=[0, 0, 0])
plot(res_ry)</code></pre><p><img src="../plot3_NonLinMPC.svg" alt="plot3_NonLinMPC"/></p><p>The controller seems robust enough to variations on <span>$K$</span> coefficient. Starting from this inverted position, the closed-loop response to a step disturbances of 10° is also satisfactory:</p><pre><code class="language-julia hljs">res_yd = sim!(nmpc, N, [180.0], plant=plant, x0=[π, 0], x̂0=[π, 0, 0], y_step=[10])
plot(res_yd)</code></pre><p><img src="../plot4_NonLinMPC.svg" alt="plot4_NonLinMPC"/></p><h2 id="Economic-Model-Predictive-Controller"><a class="docs-heading-anchor" href="#Economic-Model-Predictive-Controller">Economic Model Predictive Controller</a><a id="Economic-Model-Predictive-Controller-1"></a><a class="docs-heading-anchor-permalink" href="#Economic-Model-Predictive-Controller" title="Permalink"></a></h2><p>Economic MPC can achieve the same objective but with lower economical costs. For this case study, the controller will aim to reduce the energy consumed by the motor. The power (W) transmitted by the motor to the pendulum is:</p><p class="math-container">\[Ẇ(t) = τ(t) ω(t)\]</p><p>Thus, the work (J) done by the motor from <span>$t = t_0$</span> to <span>$t_{end}$</span> is:</p><p class="math-container">\[W = \int_{t_0}^{t_{end}} Ẇ(t) \mathrm{d}t = \int_{t_0}^{t_{end}} τ(t) ω(t) \mathrm{d}t\]</p><p>With the sampling time <span>$T_s$</span> in s, the prediction horizon <span>$H_p$</span>, the limits defined as <span>$t_0 = k T_s$</span> and <span>$t_{end} = (k+H_p) T_s$</span>, and the left-endpoint rectangle method for the integral, we get:</p><p class="math-container">\[W ≈ T_s \sum_{j=0}^{H_p-1} τ(k + j) ω(k + j)\]</p><p>The objective function will now include an additive term that penalizes the work done by the motor <span>$W$</span> to reduce the energy consumption. Notice that <span>$W$</span> is a function of the manipulated input <span>$τ$</span> and the angular speed <span>$ω$</span>, a state that is not measured (only the angle <span>$θ$</span> is measured here). As the arguments of <a href="../../public/predictive_control/#ModelPredictiveControl.NonLinMPC"><code>NonLinMPC</code></a> economic function <code>JE</code> do not include the states, the speed is now defined as an unmeasured output to design a Kalman Filter similar to the previous one (<span>$\mathbf{y^m} = θ$</span> and <span>$\mathbf{y^u} = ω$</span>):</p><pre><code class="language-julia hljs">h2(x, _ ) = [180/π*x[1], x[2]]
nu, nx, ny = 1, 2, 2
model2 = NonLinModel(f      , h2, Ts, nu, nx, ny)
plant2 = NonLinModel(f_plant, h2, Ts, nu, nx, ny)
estim2 = UnscentedKalmanFilter(model2; σQ, σR, nint_u, σQint_u, i_ym=[1])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">UnscentedKalmanFilter estimator with a sample time Ts = 0.1 s, NonLinModel and:
 1 manipulated inputs u (1 integrating states)
 3 states x̂
 1 measured outputs ym (0 integrating states)
 1 unmeasured outputs yu
 0 measured disturbances d</code></pre><p>The <code>plant2</code> object based on <code>h2</code> is also required since <a href="../../public/generic_func/#ModelPredictiveControl.sim!"><code>sim!</code></a> expects that the output vector of <code>plant</code> argument corresponds to the model output vector in <code>mpc</code> argument. We can now define the <span>$J_E$</span> function and the <code>empc</code> controller:</p><pre><code class="language-julia hljs">function JE(UE, ŶE, _ )
    τ, ω = UE[1:end-1], ŶE[2:2:end-1]
    return Ts*sum(τ.*ω)
end
empc = NonLinMPC(estim2, Hp=20, Hc=2, Mwt=[0.5, 0], Nwt=[2.5], Ewt=4.5e3, JE=JE)
empc = setconstraint!(empc, umin=[-1.5], umax=[+1.5])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NonLinMPC controller with a sample time Ts = 0.1 s, Ipopt optimizer, UnscentedKalmanFilter estimator and:
 20 prediction steps Hp
  2 control steps Hc
  1 manipulated inputs u (1 integrating states)
  3 states x̂
  1 measured outputs ym (0 integrating states)
  1 unmeasured outputs yu
  0 measured disturbances d</code></pre><p>The keyword argument <code>Ewt</code> weights the economic costs relative to the other terms in the objective function. The term must be large enough to be significant but a too high value can lead to a static error on the angle setpoint. The second element of <code>Mwt</code> is zero since the speed <span>$ω$</span> is not requested to track a setpoint. The closed-loop response to a 180° setpoint is:</p><pre><code class="language-julia hljs">res2_ry = sim!(empc, N, [180, 0], plant=plant2, x0=[0, 0], x̂0=[0, 0, 0])
plot(res2_ry)</code></pre><p><img src="../plot5_NonLinMPC.svg" alt="plot5_NonLinMPC"/></p><p>and the energy consumption is slightly lower:</p><pre><code class="language-julia hljs">function calcW(res)
    τ, ω = res.U_data[1, 1:end-1], res.X_data[2, 1:end-1]
    return Ts*sum(τ.*ω)
end
Dict(:W_nmpc =&gt; calcW(res_ry), :W_empc =&gt; calcW(res2_ry))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Symbol, Float64} with 2 entries:
  :W_empc =&gt; 4.19004
  :W_nmpc =&gt; 4.22099</code></pre><p>Also, for a 10° step disturbance:</p><pre><code class="language-julia hljs">res2_yd = sim!(empc, N, [180; 0]; plant=plant2, x0=[π, 0], x̂0=[π, 0, 0], y_step=[10, 0])
plot(res2_yd)</code></pre><p><img src="../plot6_NonLinMPC.svg" alt="plot6_NonLinMPC"/></p><p>the new controller is able to recuperate more energy from the pendulum (i.e. negative work):</p><pre><code class="language-julia hljs">Dict(:W_nmpc =&gt; calcW(res_yd), :W_empc =&gt; calcW(res2_yd))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Symbol, Float64} with 2 entries:
  :W_empc =&gt; -0.135262
  :W_nmpc =&gt; -0.0844752</code></pre><p>Of course, this gain is only exploitable if the motor electronic includes some kind of regenerative circuitry.</p><h2 id="Linearizing-the-Model"><a class="docs-heading-anchor" href="#Linearizing-the-Model">Linearizing the Model</a><a id="Linearizing-the-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Linearizing-the-Model" title="Permalink"></a></h2><p>Nonlinear MPC are more computationally expensive than <a href="../../public/predictive_control/#ModelPredictiveControl.LinMPC"><code>LinMPC</code></a>. Solving the problem should always be faster than the sampling time <span>$T_s = 0.1$</span> s for real-time operation. This requirement is sometimes hard to meet on electronics or mechanical systems because of fast dynamics. To ease the design and comparison with <a href="../../public/predictive_control/#ModelPredictiveControl.LinMPC"><code>LinMPC</code></a>, the <a href="../../public/sim_model/#ModelPredictiveControl.linearize"><code>linearize</code></a> function allows automatic linearization of <a href="../../public/sim_model/#ModelPredictiveControl.NonLinModel"><code>NonLinModel</code></a> based on <a href="https://juliadiff.org/ForwardDiff.jl/stable/"><code>ForwardDiff.jl</code></a>. We first linearize <code>model</code> at the point <span>$θ = π$</span> rad and <span>$ω = τ = 0$</span> (inverted position):</p><pre><code class="language-julia hljs">linmodel = linearize(model, x=[π, 0], u=[0])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Discrete-time linear model with a sample time Ts = 0.1 s and:
 1 manipulated inputs u
 2 states x
 1 outputs y
 0 measured disturbances d</code></pre><p>It is worth mentioning that the Euler method in <code>model</code> object is not the best choice for linearization since its accuracy is low (approximation of a poor approximation). A <a href="../../public/state_estim/#ModelPredictiveControl.SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a> and a <a href="../../public/predictive_control/#ModelPredictiveControl.LinMPC"><code>LinMPC</code></a> are designed from <code>linmodel</code>:</p><pre><code class="language-julia hljs">kf  = SteadyKalmanFilter(linmodel; σQ, σR, nint_u, σQint_u)
mpc = LinMPC(kf, Hp=20, Hc=2, Mwt=[0.5], Nwt=[2.5])
mpc = setconstraint!(mpc, umin=[-1.5], umax=[+1.5])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LinMPC controller with a sample time Ts = 0.1 s, OSQP optimizer, SteadyKalmanFilter estimator and:
 20 prediction steps Hp
  2 control steps Hc
  1 manipulated inputs u (1 integrating states)
  3 states x̂
  1 measured outputs ym (0 integrating states)
  0 unmeasured outputs yu
  0 measured disturbances d</code></pre><p>The linear controller has difficulties to reject the 10° step disturbance:</p><pre><code class="language-julia hljs">res_lin = sim!(mpc, N, [180.0]; plant, x0=[π, 0], y_step=[10])
plot(res_lin)</code></pre><p><img src="../plot7_NonLinMPC.svg" alt="plot7_NonLinMPC"/></p><p>Solving the optimization problem of <code>mpc</code> with <a href="https://darnstrom.github.io/daqp/"><code>DAQP</code></a> optimizer instead of the default <code>OSQP</code> solver can help here. It is indeed documented that <code>DAQP</code> can perform better on small/medium dense matrices and unstable poles<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>, which is obviously the case here (absolute value of unstable poles are greater than one):</p><pre><code class="language-julia hljs">using LinearAlgebra; poles = eigvals(linmodel.A)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 0.26614608739843437
 1.3338539126015654</code></pre><p>To install the solver, run:</p><pre><code class="language-text hljs">using Pkg; Pkg.add(&quot;DAQP&quot;)</code></pre><p>Constructing a <a href="../../public/predictive_control/#ModelPredictiveControl.LinMPC"><code>LinMPC</code></a> with <code>DAQP</code>:</p><pre><code class="language-julia hljs">using JuMP, DAQP
daqp = Model(DAQP.Optimizer, add_bridges=false)
mpc2 = LinMPC(kf, Hp=20, Hc=2, Mwt=[0.5], Nwt=[2.5], optim=daqp)
mpc2 = setconstraint!(mpc2, umin=[-1.5], umax=[+1.5])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LinMPC controller with a sample time Ts = 0.1 s, DAQP optimizer, SteadyKalmanFilter estimator and:
 20 prediction steps Hp
  2 control steps Hc
  1 manipulated inputs u (1 integrating states)
  3 states x̂
  1 measured outputs ym (0 integrating states)
  0 unmeasured outputs yu
  0 measured disturbances d</code></pre><p>does improve the rejection of the step disturbance:</p><pre><code class="language-julia hljs">res_lin2 = sim!(mpc2, N, [180.0]; plant, x0=[π, 0], y_step=[10])
plot(res_lin2)</code></pre><p><img src="../plot8_NonLinMPC.svg" alt="plot8_NonLinMPC"/></p><p>The closed-loop performance is still lower than the nonlinear controller, as expected, but computations are about 2000 times faster (0.00002 s versus 0.04 s per time steps, on average). Note that <code>linmodel</code> is only valid for angular positions near 180°. Multiple linearized models and controllers are required for large deviations from this operating point. This is known as gain scheduling.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Arnström, D., Bemporad, A., and Axehill, D. (2022). A dual active-set solver for embedded quadratic programming using recursive LDLᵀ updates. IEEE Trans. Autom. Contr., 67(8). https://doi.org/doi:10.1109/TAC.2022.3176430.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../linmpc/">« Linear Design</a><a class="docs-footer-nextpage" href="../../public/sim_model/">Plant Models »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Friday 17 November 2023 02:27">Friday 17 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
