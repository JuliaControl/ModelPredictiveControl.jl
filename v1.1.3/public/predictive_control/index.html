<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Predictive Controllers · ModelPredictiveControl.jl</title><meta name="title" content="Predictive Controllers · ModelPredictiveControl.jl"/><meta property="og:title" content="Predictive Controllers · ModelPredictiveControl.jl"/><meta property="twitter:title" content="Predictive Controllers · ModelPredictiveControl.jl"/><meta name="description" content="Documentation for ModelPredictiveControl.jl."/><meta property="og:description" content="Documentation for ModelPredictiveControl.jl."/><meta property="twitter:description" content="Documentation for ModelPredictiveControl.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="ModelPredictiveControl.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="ModelPredictiveControl.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelPredictiveControl.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/installation/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/linmpc/">Linear Design</a></li><li><a class="tocitem" href="../../manual/nonlinmpc/">Nonlinear Design</a></li><li><a class="tocitem" href="../../manual/mtk/">ModelingToolkit</a></li></ul></li></ul></li><li><span class="tocitem">Functions</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox" checked/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Public</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../sim_model/">Plant Models</a></li><li><a class="tocitem" href="../state_estim/">State Estimators</a></li><li class="is-active"><a class="tocitem" href>Predictive Controllers</a><ul class="internal"><li><a class="tocitem" href="#PredictiveController"><span>PredictiveController</span></a></li><li><a class="tocitem" href="#LinMPC"><span>LinMPC</span></a></li><li><a class="tocitem" href="#ExplicitMPC"><span>ExplicitMPC</span></a></li><li><a class="tocitem" href="#NonLinMPC"><span>NonLinMPC</span></a></li><li><a class="tocitem" href="#Move-Manipulated-Input-u"><span>Move Manipulated Input u</span></a></li></ul></li><li><a class="tocitem" href="../generic_func/">Generic Functions</a></li><li><a class="tocitem" href="../plot_sim/">Simulations and Plots</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../internals/sim_model/">Plant Models</a></li><li><a class="tocitem" href="../../internals/state_estim/">State Estimators</a></li><li><a class="tocitem" href="../../internals/predictive_control/">Predictive Controllers</a></li></ul></li></ul></li><li><a class="tocitem" href="../../func_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functions</a></li><li><a class="is-disabled">Public</a></li><li class="is-active"><a href>Predictive Controllers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Predictive Controllers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaControl/ModelPredictiveControl.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/main/docs/src/public/predictive_control.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions:-Predictive-Controllers"><a class="docs-heading-anchor" href="#Functions:-Predictive-Controllers">Functions: Predictive Controllers</a><a id="Functions:-Predictive-Controllers-1"></a><a class="docs-heading-anchor-permalink" href="#Functions:-Predictive-Controllers" title="Permalink"></a></h1><ul><li><a href="#Functions:-Predictive-Controllers">Functions: Predictive Controllers</a></li><li class="no-marker"><ul><li><a href="#PredictiveController">PredictiveController</a></li><li><a href="#LinMPC">LinMPC</a></li><li><a href="#ExplicitMPC">ExplicitMPC</a></li><li><a href="#NonLinMPC">NonLinMPC</a></li><li><a href="#Move-Manipulated-Input-u">Move Manipulated Input u</a></li></ul></li></ul><p>All the predictive controllers in this module rely on a state estimator to compute the predictions. The default <a href="#LinMPC"><code>LinMPC</code></a> estimator is a <a href="../state_estim/#SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a>, and <a href="#NonLinMPC"><code>NonLinMPC</code></a> with nonlinear models, an <a href="../state_estim/#UnscentedKalmanFilter"><code>UnscentedKalmanFilter</code></a>. For simpler and more classical designs, an <a href="../state_estim/#InternalModel"><code>InternalModel</code></a> structure is also available, that assumes by default that the current model mismatch estimation is constant in the future (same approach as dynamic matrix control, DMC).</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The nomenclature uses boldfaces for vectors or matrices, capital boldface letters for vectors representing time series (and also for matrices), and hats for the predictions (and also for the observer estimations).</p></div></div><p>To be precise, at the <span>$k$</span>th control period, the vectors that encompass the future measured disturbances <span>$\mathbf{d̂}$</span>, model outputs <span>$\mathbf{ŷ}$</span> and setpoints <span>$\mathbf{r̂_y}$</span> over the prediction horizon <span>$H_p$</span> are defined as:</p><p class="math-container">\[    \mathbf{D̂} = \begin{bmatrix}
        \mathbf{d̂}(k+1)   \\ \mathbf{d̂}(k+2)   \\ \vdots  \\ \mathbf{d̂}(k+H_p)
    \end{bmatrix} \: , \quad
    \mathbf{Ŷ} = \begin{bmatrix}
        \mathbf{ŷ}(k+1)   \\ \mathbf{ŷ}(k+2)   \\ \vdots  \\ \mathbf{ŷ}(k+H_p)
    \end{bmatrix} \quad \text{and} \quad
    \mathbf{R̂_y} = \begin{bmatrix}
        \mathbf{r̂_y}(k+1) \\ \mathbf{r̂_y}(k+2) \\ \vdots  \\ \mathbf{r̂_y}(k+H_p)
    \end{bmatrix}\]</p><p>in which <span>$\mathbf{D̂}$</span>, <span>$\mathbf{Ŷ}$</span> and  <span>$\mathbf{R̂_y}$</span> are vectors of <code>nd*Hp</code>, <code>ny*Hp</code> and <code>ny*Hp</code> elements, respectively. The vectors for the manipulated input <span>$\mathbf{u}$</span> are shifted by one time step:</p><p class="math-container">\[    \mathbf{U} = \begin{bmatrix}
        \mathbf{u}(k+0)   \\ \mathbf{u}(k+1)   \\ \vdots  \\ \mathbf{u}(k+H_p-1)
    \end{bmatrix} \quad \text{and} \quad
    \mathbf{R̂_u} = \begin{bmatrix}
        \mathbf{r̂_u}(k+0) \\ \mathbf{r̂_u}(k+1) \\ \vdots  \\ \mathbf{r̂_u}(k+H_p-1)
    \end{bmatrix}\]</p><p>in which <span>$\mathbf{U}$</span> and <span>$\mathbf{R̂_u}$</span> are both vectors of <code>nu*Hp</code> elements. Defining the manipulated input increment as <span>$\mathbf{Δu}(k+j) = \mathbf{u}(k+j) - \mathbf{u}(k+j-1)$</span>, the control horizon <span>$H_c$</span> enforces that <span>$\mathbf{Δu}(k+j) = \mathbf{0}$</span> for <span>$j ≥ H_c$</span>. For this reason, the vector that collects them is truncated up to <span>$k+H_c-1$</span>:</p><p class="math-container">\[    \mathbf{ΔU} =
    \begin{bmatrix}
        \mathbf{Δu}(k+0) \\ \mathbf{Δu}(k+1) \\ \vdots  \\ \mathbf{Δu}(k+H_c-1)
    \end{bmatrix}\]</p><p>in which <span>$\mathbf{ΔU}$</span> is a vector of <code>nu*Hc</code> elements.</p><h2 id="PredictiveController"><a class="docs-heading-anchor" href="#PredictiveController">PredictiveController</a><a id="PredictiveController-1"></a><a class="docs-heading-anchor-permalink" href="#PredictiveController" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.PredictiveController" href="#ModelPredictiveControl.PredictiveController"><code>ModelPredictiveControl.PredictiveController</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract supertype of all predictive controllers.</p><hr/><pre><code class="nohighlight hljs">(mpc::PredictiveController)(ry, d=[]; kwargs...) -&gt; u</code></pre><p>Functor allowing callable <code>PredictiveController</code> object as an alias for <a href="#ModelPredictiveControl.moveinput!"><code>moveinput!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mpc = LinMPC(LinModel(tf(5, [2, 1]), 3), Nwt=[0], Hp=1000, Hc=1, direct=false);

julia&gt; u = mpc([5]); round.(u, digits=3)
1-element Vector{Float64}:
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/b5bc3f7c27ae455a411196e51229580368bfa8ac/src/predictive_control.jl#L1-L19">source</a></section></article><h2 id="LinMPC"><a class="docs-heading-anchor" href="#LinMPC">LinMPC</a><a id="LinMPC-1"></a><a class="docs-heading-anchor-permalink" href="#LinMPC" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.LinMPC" href="#ModelPredictiveControl.LinMPC"><code>ModelPredictiveControl.LinMPC</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinMPC(model::LinModel; &lt;keyword arguments&gt;)</code></pre><p>Construct a linear predictive controller based on <a href="../sim_model/#LinModel"><code>LinModel</code></a> <code>model</code>.</p><p>The controller minimizes the following objective function at each discrete time <span>$k$</span>:</p><p class="math-container">\[\begin{aligned}
\min_{\mathbf{ΔU}, ϵ}   \mathbf{(R̂_y - Ŷ)}&#39; \mathbf{M}_{H_p} \mathbf{(R̂_y - Ŷ)}
                      + \mathbf{(ΔU)}&#39;      \mathbf{N}_{H_c} \mathbf{(ΔU)}        \\
                      + \mathbf{(R̂_u - U)}&#39; \mathbf{L}_{H_p} \mathbf{(R̂_u - U)} 
                      + C ϵ^2
\end{aligned}\]</p><p>subject to <a href="../generic_func/#ModelPredictiveControl.setconstraint!"><code>setconstraint!</code></a> bounds, and in which the weight matrices are repeated  <span>$H_p$</span> or <span>$H_c$</span> times by default:</p><p class="math-container">\[\begin{aligned}
    \mathbf{M}_{H_p} &amp;= \text{diag}\mathbf{(M,M,...,M)}     \\
    \mathbf{N}_{H_c} &amp;= \text{diag}\mathbf{(N,N,...,N)}     \\
    \mathbf{L}_{H_p} &amp;= \text{diag}\mathbf{(L,L,...,L)}     
\end{aligned}\]</p><p>Time-varying and non-diagonal weights are also supported. Modify the last block in  <span>$\mathbf{M}_{H_p}$</span> to specify a terminal weight. The <span>$\mathbf{ΔU}$</span> includes the input  increments <span>$\mathbf{Δu}(k+j) = \mathbf{u}(k+j) - \mathbf{u}(k+j-1)$</span> from <span>$j=0$</span> to <span>$H_c-1$</span>, the <span>$\mathbf{Ŷ}$</span> vector, the output predictions <span>$\mathbf{ŷ}(k+j)$</span> from <span>$j=1$</span> to <span>$H_p$</span>, and the <span>$\mathbf{U}$</span> vector, the manipulated inputs <span>$\mathbf{u}(k+j)$</span> from <span>$j=0$</span> to <span>$H_p-1$</span>. The slack variable <span>$ϵ$</span> relaxes the constraints, as described in <a href="../generic_func/#ModelPredictiveControl.setconstraint!"><code>setconstraint!</code></a> documentation. See Extended Help for a detailed nomenclature. </p><p>This method uses the default state estimator, a <a href="../state_estim/#SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a> with default arguments.</p><p><strong>Arguments</strong></p><ul><li><p><code>model::LinModel</code> : model used for controller predictions and state estimations.</p></li><li><p><code>Hp=10+nk</code>: prediction horizon <span>$H_p$</span>, <code>nk</code> is the number of delays in <code>model</code>.</p></li><li><p><code>Hc=2</code> : control horizon <span>$H_c$</span>.</p></li><li><p><code>Mwt=fill(1.0,model.ny)</code> : main diagonal of <span>$\mathbf{M}$</span> weight matrix (vector).</p></li><li><p><code>Nwt=fill(0.1,model.nu)</code> : main diagonal of <span>$\mathbf{N}$</span> weight matrix (vector).</p></li><li><p><code>Lwt=fill(0.0,model.nu)</code> : main diagonal of <span>$\mathbf{L}$</span> weight matrix (vector).</p></li><li><p><code>M_Hp=diagm(repeat(Mwt,Hp))</code> : positive semidefinite symmetric matrix <span>$\mathbf{M}_{H_p}$</span>.</p></li><li><p><code>N_Hc=diagm(repeat(Nwt,Hc))</code> : positive semidefinite symmetric matrix <span>$\mathbf{N}_{H_c}$</span>.</p></li><li><p><code>L_Hp=diagm(repeat(Lwt,Hp))</code> : positive semidefinite symmetric matrix <span>$\mathbf{L}_{H_p}$</span>.</p></li><li><p><code>Cwt=1e5</code> : slack variable weight <span>$C$</span> (scalar), use <code>Cwt=Inf</code> for hard constraints only.</p></li><li><p><code>optim=JuMP.Model(OSQP.MathOptInterfaceOSQP.Optimizer)</code> : quadratic optimizer used in the predictive controller, provided as a <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.Model"><code>JuMP.Model</code></a> (default to <a href="https://osqp.org/docs/parsers/jump.html"><code>OSQP</code></a> optimizer).</p></li><li><p>additional keyword arguments are passed to <a href="../state_estim/#SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a> constructor.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 4);

julia&gt; mpc = LinMPC(model, Mwt=[0, 1], Nwt=[0.5], Hp=30, Hc=1)
LinMPC controller with a sample time Ts = 4.0 s, OSQP optimizer, SteadyKalmanFilter estimator and:
 30 prediction steps Hp
  1 control steps Hc
  1 slack variable ϵ (control constraints)
  1 manipulated inputs u (0 integrating states)
  4 estimated states x̂
  2 measured outputs ym (2 integrating states)
  0 unmeasured outputs yu
  0 measured disturbances d</code></pre><p><strong>Extended Help</strong></p><details class="admonition is-details"><summary class="admonition-header">Extended Help</summary><div class="admonition-body"><p>Manipulated inputs setpoints <span>$\mathbf{r_u}$</span> are not common but they can be interesting for over-actuated systems, when <code>nu &gt; ny</code> (e.g. prioritize solutions with lower  economical costs). The default <code>Lwt</code> value implies that this feature is disabled by default.</p><p>The objective function follows this nomenclature:</p><table><tr><th style="text-align: left">VARIABLE</th><th style="text-align: left">DESCRIPTION</th><th style="text-align: left">SIZE</th></tr><tr><td style="text-align: left"><span>$H_p$</span></td><td style="text-align: left">prediction horizon (integer)</td><td style="text-align: left"><code>()</code></td></tr><tr><td style="text-align: left"><span>$H_c$</span></td><td style="text-align: left">control horizon (integer)</td><td style="text-align: left"><code>()</code></td></tr><tr><td style="text-align: left"><span>$\mathbf{ΔU}$</span></td><td style="text-align: left">manipulated input increments over <span>$H_c$</span></td><td style="text-align: left"><code>(nu*Hc,)</code></td></tr><tr><td style="text-align: left"><span>$\mathbf{D̂}$</span></td><td style="text-align: left">predicted measured disturbances over <span>$H_p$</span></td><td style="text-align: left"><code>(nd*Hp,)</code></td></tr><tr><td style="text-align: left"><span>$\mathbf{Ŷ}$</span></td><td style="text-align: left">predicted outputs over <span>$H_p$</span></td><td style="text-align: left"><code>(ny*Hp,)</code></td></tr><tr><td style="text-align: left"><span>$\mathbf{U}$</span></td><td style="text-align: left">manipulated inputs over <span>$H_p$</span></td><td style="text-align: left"><code>(nu*Hp,)</code></td></tr><tr><td style="text-align: left"><span>$\mathbf{R̂_y}$</span></td><td style="text-align: left">predicted output setpoints over <span>$H_p$</span></td><td style="text-align: left"><code>(ny*Hp,)</code></td></tr><tr><td style="text-align: left"><span>$\mathbf{R̂_u}$</span></td><td style="text-align: left">predicted manipulated input setpoints over <span>$H_p$</span></td><td style="text-align: left"><code>(nu*Hp,)</code></td></tr><tr><td style="text-align: left"><span>$\mathbf{M}_{H_p}$</span></td><td style="text-align: left">output setpoint tracking weights over <span>$H_p$</span></td><td style="text-align: left"><code>(ny*Hp, ny*Hp)</code></td></tr><tr><td style="text-align: left"><span>$\mathbf{N}_{H_c}$</span></td><td style="text-align: left">manipulated input increment weights over <span>$H_c$</span></td><td style="text-align: left"><code>(nu*Hc, nu*Hc)</code></td></tr><tr><td style="text-align: left"><span>$\mathbf{L}_{H_p}$</span></td><td style="text-align: left">manipulated input setpoint tracking weights over <span>$H_p$</span></td><td style="text-align: left"><code>(nu*Hp, nu*Hp)</code></td></tr><tr><td style="text-align: left"><span>$C$</span></td><td style="text-align: left">slack variable weight</td><td style="text-align: left"><code>()</code></td></tr><tr><td style="text-align: left"><span>$ϵ$</span></td><td style="text-align: left">slack variable for constraint softening</td><td style="text-align: left"><code>()</code></td></tr></table></div></details></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/b5bc3f7c27ae455a411196e51229580368bfa8ac/src/controller/linmpc.jl#L88-L178">source</a></section><section><div><pre><code class="language-julia hljs">LinMPC(estim::StateEstimator; &lt;keyword arguments&gt;)</code></pre><p>Use custom state estimator <code>estim</code> to construct <code>LinMPC</code>.</p><p><code>estim.model</code> must be a <a href="../sim_model/#LinModel"><code>LinModel</code></a>. Else, a <a href="#NonLinMPC"><code>NonLinMPC</code></a> is required. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; estim = KalmanFilter(LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 4), i_ym=[2]);

julia&gt; mpc = LinMPC(estim, Mwt=[0, 1], Nwt=[0.5], Hp=30, Hc=1)
LinMPC controller with a sample time Ts = 4.0 s, OSQP optimizer, KalmanFilter estimator and:
 30 prediction steps Hp
  1 control steps Hc
  1 slack variable ϵ (control constraints)
  1 manipulated inputs u (0 integrating states)
  3 estimated states x̂
  1 measured outputs ym (1 integrating states)
  1 unmeasured outputs yu
  0 measured disturbances d</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/b5bc3f7c27ae455a411196e51229580368bfa8ac/src/controller/linmpc.jl#L198-L220">source</a></section></article><h2 id="ExplicitMPC"><a class="docs-heading-anchor" href="#ExplicitMPC">ExplicitMPC</a><a id="ExplicitMPC-1"></a><a class="docs-heading-anchor-permalink" href="#ExplicitMPC" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.ExplicitMPC" href="#ModelPredictiveControl.ExplicitMPC"><code>ModelPredictiveControl.ExplicitMPC</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ExplicitMPC(model::LinModel; &lt;keyword arguments&gt;)</code></pre><p>Construct an explicit linear predictive controller based on <a href="../sim_model/#LinModel"><code>LinModel</code></a> <code>model</code>.</p><p>The controller minimizes the following objective function at each discrete time <span>$k$</span>:</p><p class="math-container">\[\begin{aligned}
\min_{\mathbf{ΔU}}   \mathbf{(R̂_y - Ŷ)}&#39; \mathbf{M}_{H_p} \mathbf{(R̂_y - Ŷ)}     
                   + \mathbf{(ΔU)}&#39;      \mathbf{N}_{H_c} \mathbf{(ΔU)}        \\
                   + \mathbf{(R̂_u - U)}&#39; \mathbf{L}_{H_p} \mathbf{(R̂_u - U)} 
\end{aligned}\]</p><p>See <a href="#LinMPC"><code>LinMPC</code></a> for the variable definitions. This controller does not support constraints but the computational costs are extremely low (array division), therefore  suitable for applications that require small sample times. The keyword arguments are identical to <a href="#LinMPC"><code>LinMPC</code></a>, except for <code>Cwt</code> and <code>optim</code> which are not supported. </p><p>This method uses the default state estimator, a <a href="../state_estim/#SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a> with default arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 4);

julia&gt; mpc = ExplicitMPC(model, Mwt=[0, 1], Nwt=[0.5], Hp=30, Hc=1)
ExplicitMPC controller with a sample time Ts = 4.0 s, SteadyKalmanFilter estimator and:
 30 prediction steps Hp
  1 control steps Hc
  1 manipulated inputs u (0 integrating states)
  4 estimated states x̂
  2 measured outputs ym (2 integrating states)
  0 unmeasured outputs yu
  0 measured disturbances d</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/b5bc3f7c27ae455a411196e51229580368bfa8ac/src/controller/explicitmpc.jl#L83-L120">source</a></section><section><div><pre><code class="language-julia hljs">ExplicitMPC(estim::StateEstimator; &lt;keyword arguments&gt;)</code></pre><p>Use custom state estimator <code>estim</code> to construct <code>ExplicitMPC</code>.</p><p><code>estim.model</code> must be a <a href="../sim_model/#LinModel"><code>LinModel</code></a>. Else, a <a href="#NonLinMPC"><code>NonLinMPC</code></a> is required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/b5bc3f7c27ae455a411196e51229580368bfa8ac/src/controller/explicitmpc.jl#L137-L143">source</a></section></article><h2 id="NonLinMPC"><a class="docs-heading-anchor" href="#NonLinMPC">NonLinMPC</a><a id="NonLinMPC-1"></a><a class="docs-heading-anchor-permalink" href="#NonLinMPC" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.NonLinMPC" href="#ModelPredictiveControl.NonLinMPC"><code>ModelPredictiveControl.NonLinMPC</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NonLinMPC(model::SimModel; &lt;keyword arguments&gt;)</code></pre><p>Construct a nonlinear predictive controller based on <a href="../sim_model/#SimModel"><code>SimModel</code></a> <code>model</code>.</p><p>Both <a href="../sim_model/#NonLinModel"><code>NonLinModel</code></a> and <a href="../sim_model/#LinModel"><code>LinModel</code></a> are supported (see Extended Help). The  controller minimizes the following objective function at each discrete time <span>$k$</span>:</p><p class="math-container">\[\begin{aligned}
\min_{\mathbf{ΔU}, ϵ}\ &amp; \mathbf{(R̂_y - Ŷ)}&#39; \mathbf{M}_{H_p} \mathbf{(R̂_y - Ŷ)}   
                       + \mathbf{(ΔU)}&#39;      \mathbf{N}_{H_c} \mathbf{(ΔU)}        \\&amp;
                       + \mathbf{(R̂_u - U)}&#39; \mathbf{L}_{H_p} \mathbf{(R̂_u - U)} 
                       + C ϵ^2  
                       + E J_E(\mathbf{U_e}, \mathbf{Ŷ_e}, \mathbf{D̂_e}, \mathbf{p})
\end{aligned}\]</p><p>subject to <a href="../generic_func/#ModelPredictiveControl.setconstraint!"><code>setconstraint!</code></a> bounds, and the custom inequality constraints:</p><p class="math-container">\[\mathbf{g_c}(\mathbf{U_e}, \mathbf{Ŷ_e}, \mathbf{D̂_e}, \mathbf{p}, ϵ) ≤ \mathbf{0}\]</p><p>The economic function <span>$J_E$</span> can penalizes solutions with high economic costs. Setting all the weights to 0 except <span>$E$</span>  creates a pure economic model predictive controller (EMPC).  As a matter of fact, <span>$J_E$</span> can be any nonlinear function to customize the objective, even if there is no economic interpretation to it. The arguments of <span>$J_E$</span> and <span>$\mathbf{g_c}$</span> include the manipulated inputs, predicted outputs and measured disturbances, extended from <span>$k$</span> to <span>$k + H_p$</span> (inclusively, see Extended Help for more details):</p><p class="math-container">\[    \mathbf{U_e} = \begin{bmatrix} \mathbf{U}      \\ \mathbf{u}(k+H_p-1)   \end{bmatrix}  , \quad
    \mathbf{Ŷ_e} = \begin{bmatrix} \mathbf{ŷ}(k)   \\ \mathbf{Ŷ}            \end{bmatrix}  , \quad
    \mathbf{D̂_e} = \begin{bmatrix} \mathbf{d}(k)   \\ \mathbf{D̂}            \end{bmatrix}\]</p><p>The argument <span>$\mathbf{p}$</span> is a custom parameter object of any type, but use a mutable one if you want to modify it later e.g.: a vector. See <a href="#LinMPC"><code>LinMPC</code></a> Extended Help for the definition of the other variables.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Replace any of the arguments of <span>$J_E$</span> and <span>$\mathbf{g_c}$</span> functions with <code>_</code> if not needed (see e.g. the default value of <code>JE</code> below).</p></div></div><p>This method uses the default state estimator:</p><ul><li>if <code>model</code> is a <a href="../sim_model/#LinModel"><code>LinModel</code></a>, a <a href="../state_estim/#SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a> with default arguments;</li><li>else, an <a href="../state_estim/#UnscentedKalmanFilter"><code>UnscentedKalmanFilter</code></a> with default arguments. </li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>See Extended Help if you get an error like:     <code>MethodError: no method matching Float64(::ForwardDiff.Dual)</code>.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>model::SimModel</code> : model used for controller predictions and state estimations.</li><li><code>Hp=nothing</code>: prediction horizon <span>$H_p$</span>, must be specified for <a href="../sim_model/#NonLinModel"><code>NonLinModel</code></a>.</li><li><code>Hc=2</code> : control horizon <span>$H_c$</span>.</li><li><code>Mwt=fill(1.0,model.ny)</code> : main diagonal of <span>$\mathbf{M}$</span> weight matrix (vector).</li><li><code>Nwt=fill(0.1,model.nu)</code> : main diagonal of <span>$\mathbf{N}$</span> weight matrix (vector).</li><li><code>Lwt=fill(0.0,model.nu)</code> : main diagonal of <span>$\mathbf{L}$</span> weight matrix (vector).</li><li><code>M_Hp=diagm(repeat(Mwt,Hp))</code> : positive semidefinite symmetric matrix <span>$\mathbf{M}_{H_p}$</span>.</li><li><code>N_Hc=diagm(repeat(Nwt,Hc))</code> : positive semidefinite symmetric matrix <span>$\mathbf{N}_{H_c}$</span>.</li><li><code>L_Hp=diagm(repeat(Lwt,Hp))</code> : positive semidefinite symmetric matrix <span>$\mathbf{L}_{H_p}$</span>.</li><li><code>Cwt=1e5</code> : slack variable weight <span>$C$</span> (scalar), use <code>Cwt=Inf</code> for hard constraints only.</li><li><code>Ewt=0.0</code> : economic costs weight <span>$E$</span> (scalar). </li><li><code>JE=(_,_,_,_)-&gt;0.0</code> : economic or custom cost function <span>$J_E(\mathbf{U_e}, \mathbf{Ŷ_e},  \mathbf{D̂_e}, \mathbf{p})$</span>.</li><li><code>gc=(_,_,_,_,_,_)-&gt;nothing</code> or <code>gc!</code> : custom inequality constraint function   <span>$\mathbf{g_c}(\mathbf{U_e}, \mathbf{Ŷ_e}, \mathbf{D̂_e}, \mathbf{p}, ϵ)$</span>, mutating or   not (details in Extended Help).</li><li><code>nc=0</code> : number of custom inequality constraints.</li><li><code>p=model.p</code> : <span>$J_E$</span> and <span>$\mathbf{g_c}$</span> functions parameter <span>$\mathbf{p}$</span> (any type).</li><li><code>optim=JuMP.Model(Ipopt.Optimizer)</code> : nonlinear optimizer used in the predictive  controller, provided as a <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.Model"><code>JuMP.Model</code></a>  (default to <a href="https://github.com/jump-dev/Ipopt.jl"><code>Ipopt</code></a> optimizer).</li><li>additional keyword arguments are passed to <a href="../state_estim/#UnscentedKalmanFilter"><code>UnscentedKalmanFilter</code></a> constructor  (or <a href="../state_estim/#SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a>, for <a href="../sim_model/#LinModel"><code>LinModel</code></a>).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = NonLinModel((x,u,_,_)-&gt;0.5x+u, (x,_,_)-&gt;2x, 10.0, 1, 1, 1, solver=nothing);

julia&gt; mpc = NonLinMPC(model, Hp=20, Hc=1, Cwt=1e6)
NonLinMPC controller with a sample time Ts = 10.0 s, Ipopt optimizer, UnscentedKalmanFilter estimator and:
 20 prediction steps Hp
  1 control steps Hc
  1 slack variable ϵ (control constraints)
  1 manipulated inputs u (0 integrating states)
  2 estimated states x̂
  1 measured outputs ym (1 integrating states)
  0 unmeasured outputs yu
  0 measured disturbances d</code></pre><p><strong>Extended Help</strong></p><details class="admonition is-details"><summary class="admonition-header">Extended Help</summary><div class="admonition-body"><p><code>NonLinMPC</code> controllers based on <a href="../sim_model/#LinModel"><code>LinModel</code></a> compute the predictions with matrix  algebra instead of a <code>for</code> loop. This feature can accelerate the optimization, especially for the constraint handling, and is not available in any other package, to my knowledge.</p><p>The economic cost <span>$J_E$</span> and custom constraint <span>$\mathbf{g_c}$</span> functions receive the extended vectors <span>$\mathbf{U_e}$</span> (<code>nu*Hp+nu</code> elements), <span>$\mathbf{Ŷ_e}$</span> (<code>ny+ny*Hp</code> elements) and  <span>$\mathbf{D̂_e}$</span> (<code>nd+nd*Hp</code> elements) as arguments. They all include the values from <span>$k$</span> to <span>$k + H_p$</span> (inclusively). The custom constraint also receives the slack <span>$ϵ$</span> (scalar), which is always zero if <code>Cwt=Inf</code>.</p><p>More precisely, the last two time steps in <span>$\mathbf{U_e}$</span> are forced to be equal, i.e. <span>$\mathbf{u}(k+H_p) = \mathbf{u}(k+H_p-1)$</span>, since <span>$H_c ≤ H_p$</span> implies that <span>$\mathbf{Δu}(k+H_p) = \mathbf{0}$</span>. The vectors <span>$\mathbf{ŷ}(k)$</span> and <span>$\mathbf{d}(k)$</span> are the current state estimator output and measured disturbance, respectively, and  <span>$\mathbf{Ŷ}$</span> and <span>$\mathbf{D̂}$</span>, their respective predictions from <span>$k+1$</span> to <span>$k+H_p$</span>.  If <code>LHS</code> represents the result of the left-hand side in the inequality  <span>$\mathbf{g_c}(\mathbf{U_e}, \mathbf{Ŷ_e}, \mathbf{D̂_e}, \mathbf{p}, ϵ) ≤ \mathbf{0}$</span>, the function <code>gc</code> can be implemented in two possible ways:</p><ol><li><strong>Non-mutating function</strong> (out-of-place): define it as <code>gc(Ue, Ŷe, D̂e, p, ϵ) -&gt; LHS</code>. This syntax is simple and intuitive but it allocates more memory.</li><li><strong>Mutating function</strong> (in-place): define it as <code>gc!(LHS, Ue, Ŷe, D̂e, p, ϵ) -&gt; nothing</code>. This syntax reduces the allocations and potentially the computational burden as well.</li></ol><p>The keyword argument <code>nc</code> is the number of elements in <code>LHS</code>, and <code>gc!</code>, an alias for the <code>gc</code> argument (both <code>gc</code> and <code>gc!</code> accepts non-mutating and mutating functions). </p><p>The optimization relies on <a href="https://github.com/jump-dev/JuMP.jl"><code>JuMP</code></a> automatic  differentiation (AD) to compute the objective and constraint derivatives. Optimizers  generally benefit from exact derivatives like AD. However, the <a href="../sim_model/#NonLinModel"><code>NonLinModel</code></a>  state-space functions must be compatible with this feature. See <a href="https://jump.dev/JuMP.jl/stable/manual/nlp/#Automatic-differentiation">Automatic differentiation</a> for common mistakes when writing these functions.</p><p>Note that if <code>Cwt≠Inf</code>, the attribute <code>nlp_scaling_max_gradient</code> of <code>Ipopt</code> is set to  <code>10/Cwt</code> (if not already set), to scale the small values of <span>$ϵ$</span>.</p></div></details></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/b5bc3f7c27ae455a411196e51229580368bfa8ac/src/controller/nonlinmpc.jl#L103-L229">source</a></section><section><div><pre><code class="language-julia hljs">NonLinMPC(estim::StateEstimator; &lt;keyword arguments&gt;)</code></pre><p>Use custom state estimator <code>estim</code> to construct <code>NonLinMPC</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = NonLinModel((x,u,_,_)-&gt;0.5x+u, (x,_,_)-&gt;2x, 10.0, 1, 1, 1, solver=nothing);

julia&gt; estim = UnscentedKalmanFilter(model, σQint_ym=[0.05]);

julia&gt; mpc = NonLinMPC(estim, Hp=20, Hc=1, Cwt=1e6)
NonLinMPC controller with a sample time Ts = 10.0 s, Ipopt optimizer, UnscentedKalmanFilter estimator and:
 20 prediction steps Hp
  1 control steps Hc
  1 slack variable ϵ (control constraints)
  1 manipulated inputs u (0 integrating states)
  2 estimated states x̂
  1 measured outputs ym (1 integrating states)
  0 unmeasured outputs yu
  0 measured disturbances d</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/b5bc3f7c27ae455a411196e51229580368bfa8ac/src/controller/nonlinmpc.jl#L285-L307">source</a></section></article><h2 id="Move-Manipulated-Input-u"><a class="docs-heading-anchor" href="#Move-Manipulated-Input-u">Move Manipulated Input u</a><a id="Move-Manipulated-Input-u-1"></a><a class="docs-heading-anchor-permalink" href="#Move-Manipulated-Input-u" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.moveinput!" href="#ModelPredictiveControl.moveinput!"><code>ModelPredictiveControl.moveinput!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">moveinput!(mpc::PredictiveController, ry=mpc.estim.model.yop, d=[]; &lt;keyword args&gt;) -&gt; u</code></pre><p>Compute the optimal manipulated input value <code>u</code> for the current control period.</p><p>Solve the optimization problem of <code>mpc</code> <a href="#PredictiveController"><code>PredictiveController</code></a> and return the results <span>$\mathbf{u}(k)$</span>. Following the receding horizon principle, the algorithm discards the optimal future manipulated inputs <span>$\mathbf{u}(k+1), \mathbf{u}(k+2), ...$</span> Note that the method mutates <code>mpc</code> internal data but it does not modifies <code>mpc.estim</code> states. Call <a href="../generic_func/#ModelPredictiveControl.preparestate!"><code>preparestate!(mpc, ym, d)</code></a> before <code>moveinput!</code>, and <a href="../generic_func/#ModelPredictiveControl.updatestate!"><code>updatestate!(mpc, u, ym, d)</code></a> after, to update <code>mpc</code> state estimates.</p><p>Calling a <a href="#PredictiveController"><code>PredictiveController</code></a> object calls this method.</p><p>See also <a href="#LinMPC"><code>LinMPC</code></a>, <a href="#ExplicitMPC"><code>ExplicitMPC</code></a>, <a href="#NonLinMPC"><code>NonLinMPC</code></a>.</p><p><strong>Arguments</strong></p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Keyword arguments with <em><code>emphasis</code></em> are non-Unicode alternatives.</p></div></div><ul><li><code>mpc::PredictiveController</code> : solve optimization problem of <code>mpc</code>.</li><li><code>ry=mpc.estim.model.yop</code> : current output setpoints <span>$\mathbf{r_y}(k)$</span>.</li><li><code>d=[]</code> : current measured disturbances <span>$\mathbf{d}(k)$</span>.</li><li><code>D̂=repeat(d, mpc.Hp)</code> or <em><code>Dhat</code></em> : predicted measured disturbances <span>$\mathbf{D̂}$</span>, constant  in the future by default or <span>$\mathbf{d̂}(k+j)=\mathbf{d}(k)$</span> for <span>$j=1$</span> to <span>$H_p$</span>.</li><li><code>R̂y=repeat(ry, mpc.Hp)</code> or <em><code>Rhaty</code></em> : predicted output setpoints <span>$\mathbf{R̂_y}$</span>, constant  in the future by default or <span>$\mathbf{r̂_y}(k+j)=\mathbf{r_y}(k)$</span> for <span>$j=1$</span> to <span>$H_p$</span>.</li><li><code>R̂u=mpc.Uop</code> or <em><code>Rhatu</code></em> : predicted manipulated input setpoints, constant in the future   by default or <span>$\mathbf{r̂_u}(k+j)=\mathbf{u_{op}}$</span> for <span>$j=0$</span> to <span>$H_p-1$</span>. </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mpc = LinMPC(LinModel(tf(5, [2, 1]), 3), Nwt=[0], Hp=1000, Hc=1);

julia&gt; preparestate!(mpc, [0]); ry = [5];

julia&gt; u = moveinput!(mpc, ry); round.(u, digits=3)
1-element Vector{Float64}:
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/b5bc3f7c27ae455a411196e51229580368bfa8ac/src/controller/execute.jl#L11-L51">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../state_estim/">« State Estimators</a><a class="docs-footer-nextpage" href="../generic_func/">Generic Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Wednesday 11 December 2024 16:51">Wednesday 11 December 2024</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
