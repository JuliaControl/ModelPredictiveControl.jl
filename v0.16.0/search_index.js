var documenterSearchIndex = {"docs":
[{"location":"manual/installation/#Manual:-Installation","page":"Installation","title":"Manual: Installation","text":"","category":"section"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"To install the ModelPredictiveControl package, run this command in the Julia REPL:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"using Pkg; Pkg.activate(); Pkg.add(\"ModelPredictiveControl\")","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"Doing so will install the package to default Julia environnement, that is, accessible anywhere. To facilitate sharing of code and reproducibility of results, it is recommended to install packages in a project environnement. To generate a new project named MPCproject with this package in the current working directory, write this in the REPL:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"using Pkg; Pkg.generate(\"MPCproject\"); Pkg.activate(\".\"); Pkg.add(\"ModelPredictiveControl\")","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"Note that that the construction of linear models typically requires ss or tf functions, it is thus advised to load the package with:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"using ModelPredictiveControl, ControlSystemsBase","category":"page"},{"location":"internals/predictive_control/#Functions:-PredictiveController-Internals","page":"Predictive Controllers","title":"Functions: PredictiveController Internals","text":"","category":"section"},{"location":"internals/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"Pages = [\"predictive_control.md\"]","category":"page"},{"location":"internals/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"The prediction methodology of this module is mainly based on Maciejowski textbook [1].","category":"page"},{"location":"internals/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"[1]: Maciejowski, J. 2000, \"Predictive control : with constraints\", 1st ed., Prentice Hall,  ISBN 978-0201398236.","category":"page"},{"location":"internals/predictive_control/#Controller-Construction","page":"Predictive Controllers","title":"Controller Construction","text":"","category":"section"},{"location":"internals/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"ModelPredictiveControl.init_predmat\nModelPredictiveControl.init_ΔUtoU\nModelPredictiveControl.init_quadprog\nModelPredictiveControl.init_stochpred\nModelPredictiveControl.init_matconstraint_mpc","category":"page"},{"location":"internals/predictive_control/#ModelPredictiveControl.init_predmat","page":"Predictive Controllers","title":"ModelPredictiveControl.init_predmat","text":"init_predmat(estim, ::LinModel, Hp, Hc) -> E, G, J, K, V, ex̂, fx̂, gx̂, jx̂, kx̂, vx̂\n\nConstruct the prediction matrices for LinModel model.\n\nThe linear model predictions are evaluated by :\n\nbeginaligned\n    mathbfY = mathbfE ΔU + mathbfG d(k) + mathbfJ D \n                                + mathbfK x_k-1(k) + mathbfV u(k-1) \n               = mathbfE ΔU + mathbfF\nendaligned\n\nwhere the predicted outputs mathbfY and measured disturbances mathbfD are from  k + 1 to k + H_p. Input increments mathbfΔU are from k to k + H_c - 1. The vector mathbfx_k-1(k) is the state estimated at the last  control period. The method also computes similar matrices but for the predicted terminal  states at k+H_p:\n\nbeginaligned\n    mathbfx_k-1(k+H_p) \n            = mathbfe_x ΔU + mathbfg_x d(k) + mathbfj_x D \n                               + mathbfk_x x_k-1(k) + mathbfv_x u(k-1) \n            = mathbfe_x ΔU + mathbff_x\nendaligned\n\nOperating points on mathbfu, mathbfd and mathbfy are omitted in above equations.\n\nExtended Help\n\ndetails: Extended Help\nUsing the augmented matrices mathbfA B_u C B_d D_d in estim and the function mathbfW(j) = mathbfC ( _i=0^j mathbfA^i ) mathbfB_u, the prediction matrices are computed by :beginaligned\nmathbfE = beginbmatrix\n    mathbfW(0)       mathbf0         cdots  mathbf0              \n    mathbfW(1)       mathbfW(0)      cdots  mathbf0              \n    vdots              vdots             ddots  vdots                  \n    mathbfW(H_p-1)   mathbfW(H_p-2)  cdots  mathbfW(H_p-H_c+1)   endbmatrix \nmathbfG = beginbmatrix\n    mathbfCmathbfA^0 mathbfB_d      \n    mathbfCmathbfA^1 mathbfB_d      \n    vdots                                    \n    mathbfCmathbfA^H_p-1 mathbfB_d endbmatrix \nmathbfJ = beginbmatrix\n    mathbfD_d                               mathbf0                                 cdots  mathbf0    \n    mathbfCmathbfA^0 mathbfB_d      mathbfD_d                               cdots  mathbf0    \n    vdots                                     vdots                                     ddots  vdots       \n    mathbfCmathbfA^H_p-2 mathbfB_d  mathbfCmathbfA^H_p-3 mathbfB_d  cdots  mathbfD_d endbmatrix \nmathbfK = beginbmatrix\n    mathbfCmathbfA^1      \n    mathbfCmathbfA^2      \n    vdots                        \n    mathbfCmathbfA^H_p    endbmatrix \nmathbfV = beginbmatrix\n    mathbfW(0)        \n    mathbfW(1)        \n    vdots               \n    mathbfW(H_p-1)    endbmatrix\nendalignedFor the terminal constraints, the matrices are computed with the function mathbfw_x(j) = ( _i=0^j mathbfA^i ) mathbfB_u and:beginaligned\nmathbfe_x = beginbmatrix mathbfw_x(H_p-1)  mathbfw_x(H_p-2)  cdots  mathbfw_x(H_p-H_c+1) endbmatrix \nmathbfg_x = mathbfA^H_p-1 mathbfB_d \nmathbfj_x = beginbmatrix mathbfA^H_p-2 mathbfB_d  mathbfA^H_p-3 mathbfB_d  cdots  mathbf0 endbmatrix \nmathbfk_x = mathbfA^H_p \nmathbfv_x = mathbfw_x(H_p-1)\nendaligned\n\n\n\n\n\nReturn empty matrices if model is not a LinModel\n\n\n\n\n\n","category":"function"},{"location":"internals/predictive_control/#ModelPredictiveControl.init_ΔUtoU","page":"Predictive Controllers","title":"ModelPredictiveControl.init_ΔUtoU","text":"init_ΔUtoU(model, Hp, Hc) -> S, T\n\nInit manipulated input increments to inputs conversion matrices.\n\nThe conversion from the input increments mathbfΔU to manipulated inputs over H_p  are calculated by:\n\nmathbfU = mathbfS mathbfΔU + mathbfT mathbfu(k-1) \n\n\n\n\n\n","category":"function"},{"location":"internals/predictive_control/#ModelPredictiveControl.init_quadprog","page":"Predictive Controllers","title":"ModelPredictiveControl.init_quadprog","text":"init_quadprog(model::LinModel, Ẽ, S, M_Hp, N_Hc, L_Hp) -> H̃, q̃, p\n\nInit the quadratic programming optimization matrix H̃ and q̃ for MPC.\n\nThe matrices appear in the quadratic general form :\n\n    J = min_mathbfΔU frac12mathbf(ΔU)H(ΔU) + mathbfq(ΔU) + p \n\nmathbfH is constant if the model and weights are linear and time invariant (LTI). The  vector mathbfq and scalar p need recalculation each control period k. p does not impact the minima position. It is thus useless at optimization but required to  evaluate the minimal J value.\n\n\n\n\n\nReturn empty matrices if model is not a LinModel.\n\n\n\n\n\n","category":"function"},{"location":"internals/predictive_control/#ModelPredictiveControl.init_stochpred","page":"Predictive Controllers","title":"ModelPredictiveControl.init_stochpred","text":"init_stochpred(estim::InternalModel, Hp) -> Ks, Ps\n\nInit the stochastic prediction matrices for InternalModel.\n\nKs and Ps matrices are defined as:\n\n    mathbfY_s = mathbfK_s x_s(k) + mathbfP_s y_s(k)\n\nCurrent stochastic outputs mathbfy_s(k) comprises the measured outputs  mathbfy_s^m(k) = mathbfy^m(k) - mathbfy_d^m(k) and unmeasured  mathbfy_s^u(k) = mathbf0. See [2].\n\n[2]: Desbiens, A., D. Hodouin & É. Plamondon. 2000, \"Global predictive control : a unified control structure for decoupling setpoint tracking, feedforward compensation and  disturbance rejection dynamics\", IEE Proceedings - Control Theory and Applications,  vol. 147, no 4, https://doi.org/10.1049/ip-cta:20000443, p. 465–475, ISSN 1350-2379.\n\n\n\n\n\nReturn empty matrices if estim is not a InternalModel.\n\n\n\n\n\n","category":"function"},{"location":"internals/predictive_control/#ModelPredictiveControl.init_matconstraint_mpc","page":"Predictive Controllers","title":"ModelPredictiveControl.init_matconstraint_mpc","text":"init_matconstraint_mpc(model::LinModel,\n    i_Umin, i_Umax, i_ΔŨmin, i_ΔŨmax, i_Ymin, i_Ymax, i_x̂min, i_x̂max, args...\n) -> i_b, i_g, A\n\nInit i_b, i_g and A matrices for the linear and nonlinear inequality constraints.\n\nThe linear and nonlinear inequality constraints are respectively defined as:\n\nbeginaligned \n    mathbfA ΔU   mathbfb  \n    mathbfg(ΔU)  mathbf0\nendaligned\n\ni_b is a BitVector including the indices of mathbfb that are finite numbers.  i_g is a similar vector but for the indices of mathbfg (empty if model is a  LinModel). The method also returns the mathbfA matrix if args is provided. In such a case, args  needs to contain all the inequality constraint matrices:  A_Umin, A_Umax, A_ΔŨmin, A_ΔŨmax, A_Ymin, A_Ymax, A_x̂min, A_x̂max.\n\n\n\n\n\nInit i_b, A without outputs and terminal constraints if model is not a LinModel.\n\n\n\n\n\n","category":"function"},{"location":"internals/predictive_control/#Constraint-Relaxation","page":"Predictive Controllers","title":"Constraint Relaxation","text":"","category":"section"},{"location":"internals/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"ModelPredictiveControl.relaxU\nModelPredictiveControl.relaxΔU\nModelPredictiveControl.relaxŶ\nModelPredictiveControl.relaxterminal","category":"page"},{"location":"internals/predictive_control/#ModelPredictiveControl.relaxU","page":"Predictive Controllers","title":"ModelPredictiveControl.relaxU","text":"relaxU(model, C, C_umin, C_umax, S) -> A_Umin, A_Umax, S̃\n\nAugment manipulated inputs constraints with slack variable ϵ for softening.\n\nDenoting the input increments augmented with the slack variable mathbfΔU = beginsmallmatrix mathbfΔU  ϵ endsmallmatrix, it returns the augmented conversion matrix mathbfS, similar to the one described at init_ΔUtoU. It also returns the mathbfA matrices for the inequality constraints:\n\nbeginbmatrix \n    mathbfA_U_min  \n    mathbfA_U_max \nendbmatrix mathbfΔU \nbeginbmatrix\n    - mathbfU_min + T mathbfu(k-1) \n    + mathbfU_max - T mathbfu(k-1)\nendbmatrix\n\n\n\n\n\n","category":"function"},{"location":"internals/predictive_control/#ModelPredictiveControl.relaxΔU","page":"Predictive Controllers","title":"ModelPredictiveControl.relaxΔU","text":"relaxΔU(\n    model, C, C_Δumin, C_Δumax, ΔUmin, ΔUmax, N_Hc\n) -> A_ΔŨmin, A_ΔŨmax, ΔŨmin, ΔŨmax, Ñ_Hc\n\nAugment input increments constraints with slack variable ϵ for softening.\n\nDenoting the input increments augmented with the slack variable  mathbfΔU = beginsmallmatrix mathbfΔU  ϵ endsmallmatrix, it returns the augmented input increment weights mathbfN_H_c (that incorporate C). It also   returns the augmented constraints mathbfΔU_min and mathbfΔU_max and the  mathbfA matrices for the inequality constraints:\n\nbeginbmatrix \n    mathbfA_ΔU_min  \n    mathbfA_ΔU_max\nendbmatrix mathbfΔU \nbeginbmatrix\n    - mathbfΔU_min \n    + mathbfΔU_max\nendbmatrix\n\n\n\n\n\n","category":"function"},{"location":"internals/predictive_control/#ModelPredictiveControl.relaxŶ","page":"Predictive Controllers","title":"ModelPredictiveControl.relaxŶ","text":"relaxŶ(::LinModel, C, C_ymin, C_ymax, E) -> A_Ymin, A_Ymax, Ẽ\n\nAugment linear output prediction constraints with slack variable ϵ for softening.\n\nDenoting the input increments augmented with the slack variable  mathbfΔU = beginsmallmatrix mathbfΔU  ϵ endsmallmatrix, it returns the  mathbfE matrix that appears in the linear model prediction equation  mathbfY = E ΔU + F, and the mathbfA matrices for the inequality constraints:\n\nbeginbmatrix \n    mathbfA_Y_min  \n    mathbfA_Y_max\nendbmatrix mathbfΔU \nbeginbmatrix\n    - mathbfY_min + F \n    + mathbfY_max - F \nendbmatrix\n\n\n\n\n\nReturn empty matrices if model is not a LinModel\n\n\n\n\n\n","category":"function"},{"location":"internals/predictive_control/#ModelPredictiveControl.relaxterminal","page":"Predictive Controllers","title":"ModelPredictiveControl.relaxterminal","text":"relaxterminal(::LinModel, C, c_x̂min, c_x̂max, ex̂) -> A_x̂min, A_x̂max, ẽx̂\n\nAugment terminal state constraints with slack variable ϵ for softening.\n\nDenoting the input increments augmented with the slack variable  mathbfΔU = beginsmallmatrix mathbfΔU  ϵ endsmallmatrix, it returns the  mathbfe_x matrix that appears in the terminal state equation  mathbfx_k-1(k + H_p) = mathbfe_x ΔU + f_x, and the mathbfA matrices for  the inequality constraints:\n\nbeginbmatrix \n    mathbfA_x_min  \n    mathbfA_x_max\nendbmatrix mathbfΔU \nbeginbmatrix\n    - mathbfx_min + f_x \n    + mathbfx_max - f_x\nendbmatrix\n\n\n\n\n\nReturn empty matrices if model is not a LinModel\n\n\n\n\n\n","category":"function"},{"location":"internals/predictive_control/#Constraints","page":"Predictive Controllers","title":"Constraints","text":"","category":"section"},{"location":"internals/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"ModelPredictiveControl.linconstraint!(::PredictiveController, ::LinModel)","category":"page"},{"location":"internals/predictive_control/#ModelPredictiveControl.linconstraint!-Tuple{PredictiveController, LinModel}","page":"Predictive Controllers","title":"ModelPredictiveControl.linconstraint!","text":"linconstraint!(mpc::PredictiveController, model::LinModel)\n\nSet b vector for the linear model inequality constraints (mathbfA ΔU  b).\n\nAlso init mathbff_x vector for the terminal constraints, see init_predmat.\n\n\n\n\n\n","category":"method"},{"location":"internals/state_estim/#Functions:-StateEstimator-Internals","page":"State Estimators","title":"Functions: StateEstimator Internals","text":"","category":"section"},{"location":"internals/state_estim/","page":"State Estimators","title":"State Estimators","text":"Pages = [\"state_estim.md\"]","category":"page"},{"location":"internals/state_estim/#Augmented-Model","page":"State Estimators","title":"Augmented Model","text":"","category":"section"},{"location":"internals/state_estim/","page":"State Estimators","title":"State Estimators","text":"ModelPredictiveControl.f̂\nModelPredictiveControl.ĥ","category":"page"},{"location":"internals/state_estim/#ModelPredictiveControl.f̂","page":"State Estimators","title":"ModelPredictiveControl.f̂","text":"f̂(estim::StateEstimator, model::SimModel, x̂, u, d)\n\nState function mathbff of the augmented model.\n\nBy introducing an augmented state vector mathbfx like in augment_model, the function returns the next state of the augmented model, defined as:\n\nbeginaligned\n    mathbfx(k+1) = mathbffBig(mathbfx(k) mathbfu(k) mathbfd(k)Big) \n    mathbfy(k)   = mathbfhBig(mathbfx(k) mathbfd(k)Big) \nendaligned\n\n\n\n\n\nUse the augmented model matrices if model is a LinModel.\n\n\n\n\n\nf̂(::InternalModel, model::NonLinModel, x̂, u, d)\n\nState function mathbff of InternalModel for NonLinModel.\n\nIt calls model.f(x̂, u ,d) since this estimator does not augment the states.\n\n\n\n\n\n","category":"function"},{"location":"internals/state_estim/#ModelPredictiveControl.ĥ","page":"State Estimators","title":"ModelPredictiveControl.ĥ","text":"ĥ(estim::StateEstimator, model::SimModel, x̂, d)\n\nOutput function mathbfh of the augmented model, see f̂ for details.\n\n\n\n\n\nUse the augmented model matrices if model is a LinModel.\n\n\n\n\n\nĥ(::InternalModel, model::NonLinModel, x̂, d)\n\nOutput function mathbfh of InternalModel, it calls model.h.\n\n\n\n\n\n","category":"function"},{"location":"internals/state_estim/#Estimator-Construction","page":"State Estimators","title":"Estimator Construction","text":"","category":"section"},{"location":"internals/state_estim/","page":"State Estimators","title":"State Estimators","text":"ModelPredictiveControl.init_estimstoch\nModelPredictiveControl.init_integrators\nModelPredictiveControl.augment_model\nModelPredictiveControl.init_ukf\nModelPredictiveControl.init_internalmodel\nModelPredictiveControl.init_predmat_mhe\nModelPredictiveControl.init_matconstraint_mhe","category":"page"},{"location":"internals/state_estim/#ModelPredictiveControl.init_estimstoch","page":"State Estimators","title":"ModelPredictiveControl.init_estimstoch","text":"init_estimstoch(model, i_ym, nint_u, nint_ym) -> As, Cs_u, Cs_y, nxs, nint_u, nint_ym\n\nInit stochastic model matrices from integrator specifications for state estimation.\n\nThe arguments nint_u and nint_ym specify how many integrators are added to each  manipulated input and measured outputs. The function returns the state-space matrices As,  Cs_u and Cs_y of the stochastic model:\n\nbeginaligned\nmathbfx_s(k+1)     = mathbfA_s x_s(k) + mathbfB_s e(k) \nmathbfy_s_u(k)   = mathbfC_s_u  x_s(k) \nmathbfy_s_ym(k)  = mathbfC_s_ym x_s(k) \nendaligned\n\nwhere mathbfe(k) is an unknown zero mean white noise and mathbfA_s =  mathrmdiag(mathbfA_s_u A_s_ym). The estimations does not use mathbfB_s, it is thus ignored. The function init_integrators builds the state-space matrices.\n\n\n\n\n\n","category":"function"},{"location":"internals/state_estim/#ModelPredictiveControl.init_integrators","page":"State Estimators","title":"ModelPredictiveControl.init_integrators","text":"init_integrators(nint, ny, varname::String) -> A, C, nint\n\nCalc A, C state-space matrices from integrator specifications nint.\n\nThis function is used to initialize the stochastic part of the augmented model for the design of state estimators. The vector nint provides how many integrators (in series)  should be incorporated for each output. The argument should have ny element, except for nint=0 which is an alias for no integrator at all. The specific case of one integrator per output results in A = I and C = I. The estimation does not use the B matrix, it  is thus ignored. This function is called twice :\n\nfor the unmeasured disturbances at manipulated inputs mathbfu\nfor the unmeasured disturbances at measured outputs mathbfy^m\n\n\n\n\n\n","category":"function"},{"location":"internals/state_estim/#ModelPredictiveControl.augment_model","page":"State Estimators","title":"ModelPredictiveControl.augment_model","text":"augment_model(model::LinModel, As, Cs; verify_obsv=true) -> Â, B̂u, Ĉ, B̂d, D̂d\n\nAugment LinModel state-space matrices with the stochastic ones As and Cs.\n\nIf mathbfx are model.x states, and mathbfx_s, the states defined at init_estimstoch, we define an augmented state vector mathbfx =   beginsmallmatrix mathbfx  mathbfx_s endsmallmatrix . The method returns the augmented matrices Â, B̂u, Ĉ, B̂d and D̂d:\n\nbeginaligned\n    mathbfx(k+1) = mathbfA x(k) + mathbfB_u u(k) + mathbfB_d d(k) \n    mathbfy(k)   = mathbfC x(k) + mathbfD_d d(k)\nendaligned\n\nAn error is thrown if the augmented model is not observable and verify_obsv == true.\n\n\n\n\n\nReturn empty matrices if model is not a LinModel.\n\n\n\n\n\n","category":"function"},{"location":"internals/state_estim/#ModelPredictiveControl.init_ukf","page":"State Estimators","title":"ModelPredictiveControl.init_ukf","text":"init_ukf(model, nx̂, α, β, κ) -> nσ, γ, m̂, Ŝ\n\nCompute the UnscentedKalmanFilter constants from α β and κ.\n\nWith n_mathbfx elements in the state vector mathbfx and  n_σ = 2 n_mathbfx + 1 sigma points, the scaling factor applied on standard deviation  matrices sqrtmathbfP is:\n\n    γ = α sqrt n_mathbfx + κ \n\nThe weight vector (n_σ  1) for the mean and the weight matrix (n_σ  n_σ) for the  covariance are respectively:\n\nbeginaligned\n    mathbfm = beginbmatrix 1 - tfracn_mathbfxγ^2  tfrac12γ^2  tfrac12γ^2  cdots  tfrac12γ^2 endbmatrix \n    mathbfS = mathrmdiagbig( 2 - α^2 + β - tfracn_mathbfxγ^2  tfrac12γ^2  tfrac12γ^2  cdots  tfrac12γ^2 big)\nendaligned\n\nSee update_estimate!(::UnscentedKalmanFilter) for other details.\n\n\n\n\n\n","category":"function"},{"location":"internals/state_estim/#ModelPredictiveControl.init_internalmodel","page":"State Estimators","title":"ModelPredictiveControl.init_internalmodel","text":"init_internalmodel(As, Bs, Cs, Ds) -> Âs, B̂s\n\nCalc stochastic model update matrices Âs and B̂s for InternalModel estimator.\n\nAs, Bs, Cs and Ds are the stochastic model matrices :\n\nbeginaligned\n    mathbfx_s(k+1) = mathbfA_s x_s(k) + mathbfB_s e(k) \n    mathbfy_s(k)   = mathbfC_s x_s(k) + mathbfD_s e(k)\nendaligned\n\nwhere mathbfe(k) is conceptual and unknown zero mean white noise. Its optimal estimation is mathbfe=0, the expected value. Thus, the Âs and B̂s matrices that  optimally update the stochastic estimate mathbfx_s are:\n\nbeginaligned\n    mathbfx_s(k+1) \n        = mathbf(A_s - B_s D_s^-1 C_s) x_s(k) + mathbf(B_s D_s^-1) y_s(k) \n        = mathbfA_s x_s(k) + mathbfB_s y_s(k)\nendaligned\n\nwith current stochastic outputs estimation mathbfy_s(k), composed of the measured  mathbfy_s^m(k) = mathbfy^m(k) - mathbfy_d^m(k) and unmeasured  mathbfy_s^u = 0 outputs. See [1].\n\n[1]: Desbiens, A., D. Hodouin & É. Plamondon. 2000, \"Global predictive control : a unified control structure for decoupling setpoint tracking, feedforward compensation and  disturbance rejection dynamics\", IEE Proceedings - Control Theory and Applications,  vol. 147, no 4, https://doi.org/10.1049/ip-cta:20000443, p. 465–475, ISSN 1350-2379.\n\n\n\n\n\n","category":"function"},{"location":"internals/state_estim/#ModelPredictiveControl.init_predmat_mhe","page":"State Estimators","title":"ModelPredictiveControl.init_predmat_mhe","text":"init_predmat_mhe(\n    model::LinModel, He, i_ym, Â, B̂u, Ĉ, B̂d, D̂d\n) -> E, F, G, J, ex̄, fx̄, Ex̂, Fx̂, Gx̂, Jx̂\n\nConstruct the MHE prediction matrices for LinModel model.\n\nIntroducing the vector mathbfZ = beginsmallmatrix mathbfx_k(k-H_e+1)   mathbfW endsmallmatrix with the decision variables, the estimated sensor noises from time k-H_e+1 to k are computed by:\n\nbeginaligned\nmathbfV = mathbfY^m - Y^m = mathbfE Z + G U + J D + Y^m     \n                                = mathbfE Z + F\nendaligned\n\nin which mathbfU D and mathbfY^m contains respectively the manipulated inputs, measured disturbances and measured outputs from time k-H_e+1 to k. The method also returns similar matrices but for the estimation error at arrival:\n\nmathbfx = mathbfx_k-H_e(k-H_e+1) - mathbfx_k(k-H_e+1) = mathbfe_x Z + f_x\n\nLastly, the estimated states from time k-H_e+2 to k+1 are given by the equation:\n\nbeginaligned\nmathbfX  = mathbfE_x Z + G_x U + J_x D \n            = mathbfE_x Z + F_x\nendaligned\n\nAll these equations omit the operating points mathbfu_op y_op d_op. These matrices are truncated when N_k  H_e (at the beginning).\n\nExtended Help\n\ndetails: Extended Help\nUsing the augmented matrices mathbfA B_u C B_d D_d, the prediction matrices for the sensor noises are computed by (notice the minus signs after the equalities):beginaligned\nmathbfE = - beginbmatrix\n    mathbfC^mmathbfA^0                   mathbf0                                     cdots  mathbf0    \n    mathbfC^mmathbfA^1                   mathbfC^mmathbfA^0                     cdots  mathbf0    \n    vdots                                       vdots                                         ddots  vdots       \n    mathbfC^mmathbfA^H_e-1               mathbfC^mmathbfA^H_e-2                 cdots  mathbf0   endbmatrix \nmathbfG = - beginbmatrix\n    mathbf0                                   mathbf0                                     cdots  mathbf0    \n    mathbfC^mmathbfA^0mathbfB_u       mathbf0                                     cdots  mathbf0    \n    vdots                                       vdots                                         ddots  vdots       \n    mathbfC^mmathbfA^H_e-2mathbfB_u   mathbfC^mmathbfA^H_e-3mathbfB_u     cdots  mathbf0   endbmatrix \nmathbfJ = - beginbmatrix\n    mathbfD^m                                 mathbf0                                     cdots  mathbf0    \n    mathbfC^mmathbfA^0mathbfB_d       mathbfD^m                                   cdots  mathbf0    \n    vdots                                       vdots                                         ddots  vdots       \n    mathbfC^mmathbfA^H_e-2mathbfB_d   mathbfC^mmathbfA^H_e-3mathbfB_d     cdots  mathbfD^m endbmatrix \nendalignedfor the estimation error at arrival:mathbfe_x = beginbmatrix\n    -mathbfI  mathbf0  cdots  mathbf0 endbmatrixand, for the estimated states:beginaligned\nmathbfE_x = beginbmatrix\n    mathbfA^1                       mathbfI                         cdots  mathbf0                   \n    mathbfA^2                       mathbfA^1                     cdots  mathbf0                    \n    vdots                               vdots                             ddots  vdots                       \n    mathbfA^H_e                     mathbfA^H_e-1                 cdots  mathbfA^1               endbmatrix \nmathbfG_x = beginbmatrix\n    mathbfA^0mathbfB_u           mathbf0                         cdots  mathbf0                    \n    mathbfA^1mathbfB_u           mathbfA^0mathbfB_u         cdots  mathbf0                    \n    vdots                               vdots                             ddots  vdots                       \n    mathbfA^H_e-1mathbfB_u       mathbfA^H_e-2mathbfB_u     cdots  mathbfA^0mathbfB_u   endbmatrix \nmathbfJ_x = beginbmatrix\n    mathbfA^0mathbfB_d           mathbf0                         cdots  mathbf0                    \n    mathbfA^1mathbfB_d           mathbfA^0mathbfB_d         cdots  mathbf0                    \n    vdots                               vdots                             ddots  vdots                       \n    mathbfA^H_e-1mathbfB_d       mathbfA^H_e-2mathbfB_d     cdots  mathbfA^0mathbfB_d   endbmatrix\nendaligned\n\n\n\n\n\nReturn empty matrices if model is not a LinModel, except for ex̄.\n\n\n\n\n\n","category":"function"},{"location":"internals/state_estim/#ModelPredictiveControl.init_matconstraint_mhe","page":"State Estimators","title":"ModelPredictiveControl.init_matconstraint_mhe","text":"init_matconstraint_mhe(model::LinModel, \n    i_x̃min, i_x̃max, i_X̂min, i_X̂max, i_Ŵmin, i_Ŵmax, i_V̂min, i_V̂max, args...\n) -> i_b, i_g, A\n\nInit i_b, i_g and A matrices for the MHE linear inequality constraints.\n\nThe linear and nonlinear inequality constraints are respectively defined as:\n\nbeginaligned \n    mathbfA Z   mathbfb  \n    mathbfg(Z)  mathbf0\nendaligned\n\ni_b is a BitVector including the indices of mathbfb that are finite numbers.  i_g is a similar vector but for the indices of mathbfg (empty if model is a  LinModel). The method also returns the mathbfA matrix if args is provided. In such a case, args  needs to contain all the inequality constraint matrices:  A_x̃min, A_x̃max, A_X̂min, A_X̂max, A_Ŵmin, A_Ŵmax, A_V̂min, A_V̂max.\n\n\n\n\n\nInit i_b, A without state and sensor noise constraints if model is not a LinModel.\n\n\n\n\n\n","category":"function"},{"location":"internals/state_estim/#Constraint-Relaxation","page":"State Estimators","title":"Constraint Relaxation","text":"","category":"section"},{"location":"internals/state_estim/","page":"State Estimators","title":"State Estimators","text":"ModelPredictiveControl.relaxarrival\nModelPredictiveControl.relaxX̂\nModelPredictiveControl.relaxŴ\nModelPredictiveControl.relaxV̂","category":"page"},{"location":"internals/state_estim/#ModelPredictiveControl.relaxarrival","page":"State Estimators","title":"ModelPredictiveControl.relaxarrival","text":"relaxarrival(\n    model::SimModel, C, c_x̂min, c_x̂max, x̂min, x̂max, ex̄\n) -> A_x̃min, A_x̃max, x̃min, x̃max, ẽx̄\n\nAugment arrival state constraints with slack variable ϵ for softening the MHE.\n\nDenoting the MHE decision variable augmented with the slack variable mathbfZ =  beginsmallmatrix ϵ  mathbfZ endsmallmatrix, it returns the mathbfe_x matrix that appears in the estimation error at arrival equation mathbfx = mathbfe_x Z + f_x. It also returns the augmented constraints mathbfx_min and mathbfx_max, and the mathbfA matrices for the inequality constraints:\n\nbeginbmatrix \n    mathbfA_x_min  \n    mathbfA_x_max\nendbmatrix mathbfZ \nbeginbmatrix\n    - mathbfx_min + f_x \n    + mathbfx_max - f_x\nendbmatrix\n\n\n\n\n\n","category":"function"},{"location":"internals/state_estim/#ModelPredictiveControl.relaxX̂","page":"State Estimators","title":"ModelPredictiveControl.relaxX̂","text":"relaxX̂(model::SimModel, C, C_x̂min, C_x̂max, Ex̂) -> A_X̂min, A_X̂max, Ẽx̂\n\nAugment estimated state constraints with slack variable ϵ for softening the MHE.\n\nDenoting the MHE decision variable augmented with the slack variable mathbfZ =  beginsmallmatrix ϵ  mathbfZ endsmallmatrix, it returns the mathbfE_x matrix that appears in estimated states equation mathbfX = mathbfE_x Z + F_x. It also returns the mathbfA matrices for the inequality constraints:\n\nbeginbmatrix \n    mathbfA_X_min  \n    mathbfA_X_max\nendbmatrix mathbfZ \nbeginbmatrix\n    - mathbfX_min + F_x \n    + mathbfX_max - F_x\nendbmatrix\n\n\n\n\n\nReturn empty matrices if model is not a LinModel\n\n\n\n\n\n","category":"function"},{"location":"internals/state_estim/#ModelPredictiveControl.relaxŴ","page":"State Estimators","title":"ModelPredictiveControl.relaxŴ","text":"relaxŴ(model::SimModel, C, C_ŵmin, C_ŵmax, nx̂) -> A_Ŵmin, A_Ŵmax\n\nAugment estimated process noise constraints with slack variable ϵ for softening the MHE.\n\nDenoting the MHE decision variable augmented with the slack variable mathbfZ =  beginsmallmatrix ϵ  mathbfZ endsmallmatrix, it returns the mathbfA  matrices for the inequality constraints:\n\nbeginbmatrix \n    mathbfA_W_min  \n    mathbfA_W_max\nendbmatrix mathbfZ \nbeginbmatrix\n    - mathbfW_min \n    + mathbfW_max\nendbmatrix\n\n\n\n\n\n","category":"function"},{"location":"internals/state_estim/#ModelPredictiveControl.relaxV̂","page":"State Estimators","title":"ModelPredictiveControl.relaxV̂","text":"relaxV̂(model::SimModel, C, C_v̂min, C_v̂max, E) -> A_V̂min, A_V̂max, Ẽ\n\nAugment estimated sensor noise constraints with slack variable ϵ for softening the MHE.\n\nDenoting the MHE decision variable augmented with the slack variable mathbfZ =  beginsmallmatrix ϵ  mathbfZ endsmallmatrix, it returns the mathbfE matrix that appears in estimated sensor noise equation mathbfV = mathbfE Z + F. It also returns the mathbfA matrices for the inequality constraints:\n\nbeginbmatrix \n    mathbfA_V_min  \n    mathbfA_V_max\nendbmatrix mathbfZ \nbeginbmatrix\n    - mathbfV_min + F \n    + mathbfV_max - F\nendbmatrix\n\n\n\n\n\nReturn empty matrices if model is not a LinModel\n\n\n\n\n\n","category":"function"},{"location":"internals/state_estim/#Constraints","page":"State Estimators","title":"Constraints","text":"","category":"section"},{"location":"internals/state_estim/","page":"State Estimators","title":"State Estimators","text":"ModelPredictiveControl.linconstraint!(::MovingHorizonEstimator, ::LinModel)","category":"page"},{"location":"internals/state_estim/#ModelPredictiveControl.linconstraint!-Tuple{MovingHorizonEstimator, LinModel}","page":"State Estimators","title":"ModelPredictiveControl.linconstraint!","text":"linconstraint!(estim::MovingHorizonEstimator, model::LinModel)\n\nSet b vector for the linear model inequality constraints (mathbfA Z  b) of MHE.\n\nAlso init mathbfF_x vector for the state constraints, see init_predmat_mhe.\n\n\n\n\n\n","category":"method"},{"location":"internals/state_estim/#Evaluate-Estimated-Output","page":"State Estimators","title":"Evaluate Estimated Output","text":"","category":"section"},{"location":"internals/state_estim/","page":"State Estimators","title":"State Estimators","text":"ModelPredictiveControl.evalŷ","category":"page"},{"location":"internals/state_estim/#ModelPredictiveControl.evalŷ","page":"State Estimators","title":"ModelPredictiveControl.evalŷ","text":"evalŷ(estim::StateEstimator, _ , d) -> ŷ\n\nEvaluate StateEstimator output ŷ from measured disturbance d and estim.x̂.\n\nSecond argument is ignored, except for InternalModel.\n\n\n\n\n\nevalŷ(estim::InternalModel, ym, d) -> ŷ\n\nGet InternalModel output ŷ from current measured outputs ym and dist. d.\n\nInternalModel estimator needs current measured outputs mathbfy^m(k) to  estimate its outputs mathbfy(k), since the strategy imposes that  mathbfy^m(k) = mathbfy^m(k) is always true.\n\n\n\n\n\n","category":"function"},{"location":"internals/state_estim/#Remove-Operating-Points","page":"State Estimators","title":"Remove Operating Points","text":"","category":"section"},{"location":"internals/state_estim/","page":"State Estimators","title":"State Estimators","text":"ModelPredictiveControl.remove_op!","category":"page"},{"location":"internals/state_estim/#ModelPredictiveControl.remove_op!","page":"State Estimators","title":"ModelPredictiveControl.remove_op!","text":"remove_op!(estim::StateEstimator, u, ym, d) -> u0, ym0, d0\n\nRemove operating points on inputs u, measured outputs ym and disturbances d.\n\nAlso store current inputs without operating points u0 in estim.lastu0. This field is  used for PredictiveController computations.\n\n\n\n\n\n","category":"function"},{"location":"internals/state_estim/#Update-Estimate","page":"State Estimators","title":"Update Estimate","text":"","category":"section"},{"location":"internals/state_estim/","page":"State Estimators","title":"State Estimators","text":"info: Info\nAll these methods assume that the operating points are already removed in u, ym and d arguments. Strickly speaking, the arguments should be called u0, ym0 and d0, following setop! notation. The 0 is dropped to simplify the notation.","category":"page"},{"location":"internals/state_estim/","page":"State Estimators","title":"State Estimators","text":"ModelPredictiveControl.update_estimate!","category":"page"},{"location":"internals/state_estim/#ModelPredictiveControl.update_estimate!","page":"State Estimators","title":"ModelPredictiveControl.update_estimate!","text":"update_estimate!(estim::SteadyKalmanFilter, u, ym, d)\n\nUpdate estim.x̂ estimate with current inputs u, measured outputs ym and dist. d.\n\nThe SteadyKalmanFilter updates it with the precomputed Kalman gain mathbfK:\n\nmathbfx_k(k+1) = mathbfA x_k-1(k) + mathbfB_u u(k) + mathbfB_d d(k) \n               + mathbfKmathbfy^m(k) - mathbfC^m x_k-1(k) - mathbfD_d^m d(k)\n\n\n\n\n\nupdate_estimate!(estim::KalmanFilter, u, ym, d)\n\nUpdate KalmanFilter state estim.x̂ and estimation error covariance estim.P̂.\n\nIt implements the time-varying Kalman Filter in its predictor (observer) form :\n\nbeginaligned\n    mathbfM(k)       = mathbfP_k-1(k)mathbfC^m\n                           mathbfC^m P_k-1(k)mathbfC^m + mathbfR^-1       \n    mathbfK(k)       = mathbfA M(k)                                                \n    mathbfy^m(k)     = mathbfC^m x_k-1(k) + mathbfD_d^m d(k)                  \n    mathbfx_k(k+1) = mathbfA x_k-1(k) + mathbfB_u u(k) + mathbfB_d d(k)\n                           + mathbfK(k)mathbfy^m(k) - mathbfy^m(k)             \n    mathbfP_k(k+1) = mathbfAmathbfP_k-1(k)\n                           - mathbfM(k)mathbfC^m P_k-1(k)mathbfA + mathbfQ\nendaligned\n\nbased on the process model described in SteadyKalmanFilter. The notation  mathbfx_k-1(k) refers to the state for the current time k estimated at the last  control period k-1. See [2] for details.\n\n[2]: Boyd S., \"Lecture 8 : The Kalman Filter\" (Winter 2008-09) [course slides], EE363:   Linear Dynamical Systems, https://web.stanford.edu/class/ee363/lectures/kf.pdf.\n\n\n\n\n\nupdate_estimate!(estim::UnscentedKalmanFilter, u, ym, d)\n\nUpdate UnscentedKalmanFilter state estim.x̂ and covariance estimate estim.P̂.\n\nIt implements the unscented Kalman Filter in its predictor (observer) form, based on the  generalized unscented transform[3]. See init_ukf for the definition of the  constants mathbfm S and γ. \n\nDenoting mathbfx_k-1(k) as the state for the current time k estimated at the  last period k-1, mathbf0, a null vector, n_σ = 2 n_mathbfx + 1, the number of sigma points, and mathbfX_k-1^j(k), the vector at the jth column of  mathbfX_k-1(k), the estimator updates the states with:\n\nbeginaligned\n    mathbfX_k-1(k) = biggbeginmatrix mathbfx_k-1(k)  mathbfx_k-1(k)  cdots  mathbfx_k-1(k)  endmatrixbigg + biggbeginmatrix mathbf0  γ sqrtmathbfP_k-1(k)  -γ sqrtmathbfP_k-1(k) endmatrixbigg \n    mathbfY^m(k)     = biggbeginmatrix mathbfh^mBig( mathbfX_k-1^1(k) Big)  mathbfh^mBig( mathbfX_k-1^2(k) Big)  cdots  mathbfh^mBig( mathbfX_k-1^n_σ(k) Big) endmatrixbigg \n    mathbfy^m(k)     = mathbfY^m(k) mathbfm \n    mathbfX_k-1(k) = beginbmatrix mathbfX_k-1^1(k) - mathbfx_k-1(k)  mathbfX_k-1^2(k) - mathbfx_k-1(k)  cdots  mathbfX_k-1^n_σ(k) - mathbfx_k-1(k) endbmatrix \n    mathbfY^m(k)     = beginbmatrix mathbfY^m^1(k)     - mathbfy^m(k)      mathbfY^m^2(k)     - mathbfy^m(k)      cdots  mathbfY^m^n_σ(k)     - mathbfy^m(k)     endbmatrix \n    mathbfM(k)       = mathbfY^m(k) mathbfS mathbfY^m(k) + mathbfR \n    mathbfK(k)       = mathbfX_k-1(k) mathbfS mathbfY^m(k) mathbfM^-1(k) \n    mathbfx_k(k)     = mathbfx_k-1(k) + mathbfK(k) big mathbfy^m(k) - mathbfy^m(k) big \n    mathbfP_k(k)     = mathbfP_k-1(k) - mathbfK(k) mathbfM(k) mathbfK(k) \n    mathbfX_k(k)     = biggbeginmatrix mathbfx_k(k)  mathbfx_k(k)  cdots  mathbfx_k(k) endmatrixbigg + biggbeginmatrix mathbf0  gamma sqrtmathbfP_k(k)  - gamma sqrtmathbfP_k(k) endmatrixbigg \n    mathbfX_k(k+1) = biggbeginmatrix mathbffBig( mathbfX_k^1(k) mathbfu(k) mathbfd(k) Big)  mathbffBig( mathbfX_k^2(k) mathbfu(k) mathbfd(k) Big)  cdots  mathbffBig( mathbfX_k^n_σ(k) mathbfu(k) mathbfd(k) Big) endmatrixbigg \n    mathbfx_k(k+1) = mathbfX_k(k+1)mathbfm \n    mathbfX_k(k+1)   = beginbmatrix mathbfX_k^1(k+1) - mathbfx_k(k+1)  mathbfX_k^2(k+1) - mathbfx_k(k+1)  cdots  mathbfX_k^n_σ(k+1) - mathbfx_k(k+1) endbmatrix \n    mathbfP_k(k+1)   = mathbfX_k(k+1) mathbfS mathbfX_k(k+1) + mathbfQ\nendaligned \n\nby using the lower triangular factor of cholesky to compute sqrtmathbfP_k-1(k) and sqrtmathbfP_k(k).  The matrices  mathbfP Q R are the covariance of the estimation error, process noise and sensor  noise, respectively.\n\n[3]: Simon, D. 2006, \"Chapter 14: The unscented Kalman filter\" in \"Optimal State Estimation:   Kalman, H∞, and Nonlinear Approaches\", John Wiley & Sons, p. 433–459, https://doi.org/10.1002/0470045345.ch14,   ISBN9780470045343.\n\n\n\n\n\nupdate_estimate!(estim::ExtendedKalmanFilter, u, ym, d=empty(estim.x̂))\n\nUpdate ExtendedKalmanFilter state estim.x̂ and covariance estim.P̂.\n\nThe equations are similar to update_estimate!(::KalmanFilter) but with the  substitutions mathbfA = F(k) and mathbfC^m = H^m(k):\n\nbeginaligned\n    mathbfM(k)       = mathbfP_k-1(k)mathbfH^m(k)\n                           mathbfH^m(k)mathbfP_k-1(k)mathbfH^m(k) + mathbfR^-1    \n    mathbfK(k)       = mathbfF(k) mathbfM(k)                                    \n    mathbfy^m(k)     = mathbfh^mBig( mathbfx_k-1(k) mathbfd(k) Big)     \n    mathbfx_k(k+1) = mathbffBig( mathbfx_k-1(k) mathbfu(k) mathbfd(k) Big)\n                           + mathbfK(k)mathbfy^m(k) - mathbfy^m(k)             \n    mathbfP_k(k+1) = mathbfF(k)mathbfP_k-1(k)\n                           - mathbfM(k)mathbfH^m(k)mathbfP_k-1(k)mathbfF(k) \n                           + mathbfQ\nendaligned\n\nForwardDiff.jacobian automatically computes the Jacobians:\n\nbeginaligned\n    mathbfF(k) = left fracmathbff(mathbfx mathbfu mathbfd)mathbfx right_mathbfx = x_k-1(k) mathbfu = u(k) mathbfd = d(k)  \n    mathbfH(k) = left fracmathbfh(mathbfx mathbfd)mathbfx             right_mathbfx = x_k-1(k) mathbfd = d(k)\nendaligned\n\nThe matrix mathbfH^m is the rows of mathbfH that are measured outputs.\n\n\n\n\n\nupdate_estimate!(estim::Luenberger, u, ym, d=empty(estim.x̂))\n\nSame than update_estimate!(::SteadyKalmanFilter) but using Luenberger.\n\n\n\n\n\nupdate_estimate!(estim::MovingHorizonEstimator, u, ym, d)\n\nUpdate MovingHorizonEstimator state estim.x̂.\n\nThe optimization problem of MovingHorizonEstimator documentation is solved at each discrete time k. Once solved, the next estimate mathbfx_k(k+1) is computed by inserting the optimal values of mathbfx_k(k-N_k+1) and mathbfW in the augmented model from j = N_k-1 to 0 inclusively. Afterward, if k  H_e, the arrival covariance for the next time step mathbfP_k-N_k+1(k-N_k+2) is estimated with the equations of update_estimate!(::ExtendedKalmanFilter), or KalmanFilter, for LinModel.\n\n\n\n\n\nupdate_estimate!(estim::InternalModel, u, ym, d=empty(estim.x̂)) -> x̂d\n\nUpdate estim.x̂ / x̂d / x̂s with current inputs u, measured outputs ym and dist. d.\n\nThe InternalModel updates the deterministic x̂d and stochastic x̂s estimates with:\n\nbeginaligned\n    mathbfx_d(k+1) = mathbffBig( mathbfx_d(k) mathbfu(k) mathbfd(k) Big) \n    mathbfx_s(k+1) = mathbfA_s x_s(k) + mathbfB_s y_s(k)\nendaligned\n\nThis estimator does not augment the state vector, thus mathbfx = x_d. See  init_internalmodel for details. \n\n\n\n\n\n","category":"function"},{"location":"internals/state_estim/#Init-Estimate","page":"State Estimators","title":"Init Estimate","text":"","category":"section"},{"location":"internals/state_estim/","page":"State Estimators","title":"State Estimators","text":"info: Info\nSame as above: the arguments should be called u0, ym0 and d0, strickly speaking.","category":"page"},{"location":"internals/state_estim/","page":"State Estimators","title":"State Estimators","text":"ModelPredictiveControl.init_estimate!","category":"page"},{"location":"internals/state_estim/#ModelPredictiveControl.init_estimate!","page":"State Estimators","title":"ModelPredictiveControl.init_estimate!","text":"init_estimate!(estim::StateEstimator, model::LinModel, u, ym, d)\n\nInit estim.x̂ estimate with the steady-state solution if model is a LinModel.\n\nUsing u, ym and d arguments, the steady-state problem combined to the equality  constraint mathbfy^m = mathbfy^m engenders the following system to solve:\n\nbeginbmatrix\n    mathbfI - mathbfA             \n    mathbfC^m\nendbmatrix mathbfx =\nbeginbmatrix\n    mathbfB_u u + mathbfB_d d     \n    mathbfy^m - mathbfD_d^m d\nendbmatrix\n\nin which mathbfC^m D_d^m are the rows of estim.Ĉ, estim.D̂d  that correspond to  measured outputs mathbfy^m.\n\n\n\n\n\ninit_estimate!(estim::StateEstimator, model::SimModel, _ , _ , _ )\n\nLeft estim.x̂ estimate unchanged if model is not a LinModel.\n\n\n\n\n\ninit_estimate!(estim::InternalModel, model::LinModel, u, ym, d)\n\nInit estim.x̂ / x̂d / x̂s estimate at steady-state for InternalModels.\n\nThe deterministic estimates estim.x̂d start at steady-state using u and d arguments:\n\n    mathbfx_d = mathbf(I - A)^-1 (B_u u + B_d d)\n\nBased on ym argument and current stochastic outputs estimation mathbfy_s, composed of the measured mathbfy_s^m = mathbfy^m - mathbfy_d^m and unmeasured  mathbfy_s^u = 0 outputs, the stochastic estimates also start at steady-state:\n\n    mathbfx_s = mathbf(I - A_s)^-1 B_s y_s\n\nThis estimator does not augment the state vector, thus mathbfx = x_d. See init_internalmodel for details.\n\n\n\n\n\n","category":"function"},{"location":"manual/nonlinmpc/#man_nonlin","page":"Nonlinear Design","title":"Manual: Nonlinear Design","text":"","category":"section"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"Pages = [\"nonlinmpc.md\"]","category":"page"},{"location":"manual/nonlinmpc/#Nonlinear-Model","page":"Nonlinear Design","title":"Nonlinear Model","text":"","category":"section"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"In this example, the goal is to control the angular position θ of a pendulum attached to a motor. Knowing that the manipulated input is the motor torque τ, the I/O vectors are:","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"beginaligned\n    mathbfu = τ \n    mathbfy = θ\nendaligned","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"The following figure presents the system:","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"<p><img src=\"../../assets/pendulum.svg\" alt=\"pendulum\" width=200 style=\"background-color:white; \n    border:20px solid white; display: block; margin-left: auto; margin-right: auto;\"/></p>","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"The plant model is nonlinear:","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"beginaligned\n    dotθ(t) = ω(t) \n    dotω(t) = -fracgLsinbig( θ(t) big) - fracKm ω(t) + frac1m L^2 τ(t)\nendaligned","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"in which g is the gravitational acceleration in m/s², L, the pendulum length in m, K, the friction coefficient at the pivot point in kg/s, and m, the mass attached at the end of the pendulum in kg. Here, the explicit Euler method discretizes the system to construct a NonLinModel:","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"using ModelPredictiveControl\nfunction pendulum(par, x, u)\n    g, L, K, m = par        # [m/s²], [m], [kg/s], [kg]\n    θ, ω = x[1], x[2]       # [rad], [rad/s]\n    τ  = u[1]               # [N m]\n    dθ = ω\n    dω = -g/L*sin(θ) - K/m*ω + τ/m/L^2\n    return [dθ, dω]\nend\n# declared constants, to avoid type-instability in the f function, for speed:\nconst par, Ts = (9.8, 0.4, 1.2, 0.3), 0.1\nf(x, u, _ ) = x + Ts*pendulum(par, x, u) # Euler method\nh(x, _ )    = [180/π*x[1]]  # [°]\nnu, nx, ny = 1, 2, 1\nmodel = NonLinModel(f, h, Ts, nu, nx, ny)","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"The output function mathbfh converts the θ angle to degrees. Note that special characters like θ can be typed in the Julia REPL or VS Code by typing \\theta and pressing the <TAB> key. The tuple par and Ts are declared as constants here to improve the performance. It is good practice to first simulate model using sim! as a quick sanity check:","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"using Plots\nu = [0.5]\nN = 35\nres = sim!(model, N, u)\nplot(res, plotu=false)\nsavefig(ans, \"plot1_NonLinMPC.svg\"); nothing # hide","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"(Image: plot1_NonLinMPC)","category":"page"},{"location":"manual/nonlinmpc/#Nonlinear-Model-Predictive-Controller","page":"Nonlinear Design","title":"Nonlinear Model Predictive Controller","text":"","category":"section"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"An UnscentedKalmanFilter estimates the plant state :","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"σQ=[0.1, 0.5]; σR=[0.5]; nint_u=[1]; σQint_u=[0.1]\nestim = UnscentedKalmanFilter(model; σQ, σR, nint_u, σQint_u)","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"The vectors σQ and σR σR are the standard deviations of the process and sensor noises, respectively. The value for the velocity ω is higher here (σQ second value) since dotω(t) equation includes an uncertain parameter: the friction coefficient K. Also, the argument nint_u explicitly adds one integrating state at the model input, the motor torque τ , with an associated standard deviation σQint_u of 0.1 N m. The estimator tuning is tested on a plant with a 25 % larger friction coefficient K:","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"const par_plant = (par[1], par[2], 1.25*par[3], par[4])\nf_plant(x, u, _) = x + Ts*pendulum(par_plant, x, u)\nplant = NonLinModel(f_plant, h, Ts, nu, nx, ny)\nres = sim!(estim, N, [0.5], plant=plant, y_noise=[0.5])\nplot(res, plotu=false, plotxwithx̂=true)\nsavefig(ans, \"plot2_NonLinMPC.svg\"); nothing # hide","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"(Image: plot2_NonLinMPC)","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"The estimate x_3 is the integrating state on the torque τ that compensates for static errors. The Kalman filter performance seems sufficient for control.","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"As the motor torque is limited to -1.5 to 1.5 N m, we incorporate the input constraints in a NonLinMPC:","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"nmpc = NonLinMPC(estim, Hp=20, Hc=2, Mwt=[0.5], Nwt=[2.5])\nnmpc = setconstraint!(nmpc, umin=[-1.5], umax=[+1.5])","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"We test mpc performance on plant by imposing an angular setpoint of 180° (inverted position):","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"using Logging; disable_logging(Warn)            # hide\nusing JuMP; unset_time_limit_sec(nmpc.optim)    # hide\nres_ry = sim!(nmpc, N, [180.0], plant=plant, x0=[0, 0], x̂0=[0, 0, 0])\nplot(res_ry)\nsavefig(ans, \"plot3_NonLinMPC.svg\"); nothing # hide","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"(Image: plot3_NonLinMPC)","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"The controller seems robust enough to variations on K coefficient. Starting from this inverted position, the closed-loop response to a step disturbances of 10° is also satisfactory:","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"res_yd = sim!(nmpc, N, [180.0], plant=plant, x0=[π, 0], x̂0=[π, 0, 0], y_step=[10])\nplot(res_yd)\nsavefig(ans, \"plot4_NonLinMPC.svg\"); nothing # hide","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"(Image: plot4_NonLinMPC)","category":"page"},{"location":"manual/nonlinmpc/#Economic-Model-Predictive-Controller","page":"Nonlinear Design","title":"Economic Model Predictive Controller","text":"","category":"section"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"Economic MPC can achieve the same objective but with lower economical costs. For this case study, the controller will aim to reduce the energy consumed by the motor. The power (W) transmitted by the motor to the pendulum is:","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"W(t) = τ(t) ω(t)","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"Thus, the work (J) done by the motor from t = t_0 to t_end is:","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"W = int_t_0^t_end W(t) mathrmdt = int_t_0^t_end τ(t) ω(t) mathrmdt","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"With the sampling time T_s in s, the prediction horizon H_p, the limits defined as t_0 = k T_s and t_end = (k+H_p) T_s, and the left-endpoint rectangle method for the integral, we get:","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"W  T_s sum_j=0^H_p-1 τ(k + j) ω(k + j)","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"The objective function will now include an additive term that penalizes the work done by the motor W to reduce the energy consumption. Notice that W is a function of the manipulated input τ and the angular speed ω, a state that is not measured (only the angle θ is measured here). As the arguments of NonLinMPC economic function JE do not include the states, the speed is now defined as an unmeasured output to design a Kalman Filter similar to the previous one (mathbfy^m = θ and mathbfy^u = ω):","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"h2(x, _ ) = [180/π*x[1], x[2]]\nnu, nx, ny = 1, 2, 2\nmodel2 = NonLinModel(f      , h2, Ts, nu, nx, ny)\nplant2 = NonLinModel(f_plant, h2, Ts, nu, nx, ny)\nestim2 = UnscentedKalmanFilter(model2; σQ, σR, nint_u, σQint_u, i_ym=[1])","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"The plant2 object based on h2 is also required since sim! expects that the output vector of plant argument corresponds to the model output vector in mpc argument. We can now define the J_E function and the empc controller:","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"function JE(UE, ŶE, _ )\n    τ, ω = UE[1:end-1], ŶE[2:2:end-1]\n    return Ts*sum(τ.*ω)\nend\nempc = NonLinMPC(estim2, Hp=20, Hc=2, Mwt=[0.5, 0], Nwt=[2.5], Ewt=4.5e3, JE=JE)\nempc = setconstraint!(empc, umin=[-1.5], umax=[+1.5])","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"The keyword argument Ewt weights the economic costs relative to the other terms in the objective function. The term must be large enough to be significant but a too high value can lead to a static error on the angle setpoint. The second element of Mwt is zero since the speed ω is not requested to track a setpoint. The closed-loop response to a 180° setpoint is similar:","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"unset_time_limit_sec(empc.optim) # hide\nres2_ry = sim!(empc, N, [180, 0], plant=plant2, x0=[0, 0], x̂0=[0, 0, 0])\nplot(res2_ry)\nsavefig(ans, \"plot5_NonLinMPC.svg\"); nothing # hide","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"(Image: plot5_NonLinMPC)","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"and the energy consumption is slightly lower:","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"function calcW(res)\n    τ, ω = res.U_data[1, 1:end-1], res.X_data[2, 1:end-1]\n    return Ts*sum(τ.*ω)\nend\nDict(:W_nmpc => calcW(res_ry), :W_empc => calcW(res2_ry))","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"Also, for a 10° step disturbance:","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"res2_yd = sim!(empc, N, [180; 0]; plant=plant2, x0=[π, 0], x̂0=[π, 0, 0], y_step=[10, 0])\nplot(res2_yd)\nsavefig(ans, \"plot6_NonLinMPC.svg\"); nothing # hide","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"(Image: plot6_NonLinMPC)","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"the new controller is able to recuperate more energy from the pendulum (i.e. negative work):","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"Dict(:W_nmpc => calcW(res_yd), :W_empc => calcW(res2_yd))","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"Of course, this gain is only exploitable if the motor electronic includes some kind of regenerative circuitry.","category":"page"},{"location":"manual/nonlinmpc/#Linearizing-the-Model","page":"Nonlinear Design","title":"Linearizing the Model","text":"","category":"section"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"Nonlinear MPC is more computationally expensive than LinMPC. Solving the problem should always be faster than the sampling time T_s = 01 s for real-time operation. This requirement is sometimes hard to meet on electronics or mechanical systems because of the fast dynamics. To ease the design and comparison with LinMPC, the linearize function allows automatic linearization of NonLinModel based on ForwardDiff.jl. We first linearize model at the point θ = π rad and ω = τ = 0 (inverted position):","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"linmodel = linearize(model, x=[π, 0], u=[0])","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"It is worth mentioning that the Euler method in model object is not the best choice for linearization since its accuracy is low (approximation of a poor approximation). A SteadyKalmanFilter and a LinMPC are designed from linmodel:","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"kf  = SteadyKalmanFilter(linmodel; σQ, σR, nint_u, σQint_u)\nmpc = LinMPC(kf, Hp=20, Hc=2, Mwt=[0.5], Nwt=[2.5])\nmpc = setconstraint!(mpc, umin=[-1.5], umax=[+1.5])","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"The linear controller has difficulties to reject the 10° step disturbance:","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"res_lin = sim!(mpc, N, [180.0]; plant, x0=[π, 0], y_step=[10])\nplot(res_lin)\nsavefig(ans, \"plot7_NonLinMPC.svg\"); nothing # hide","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"(Image: plot7_NonLinMPC)","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"Solving the optimization problem of mpc with DAQP optimizer instead of the default OSQP solver can help here. It is indeed documented that DAQP can perform better on small/medium dense matrices and unstable poles[1], which is obviously the case here (absolute value of unstable poles are greater than one):","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"[1]: Arnström, D., Bemporad, A., and Axehill, D. (2022). A dual active-set solver for embedded quadratic programming using recursive LDLᵀ updates. IEEE Trans. Autom. Contr., 67(8). https://doi.org/doi:10.1109/TAC.2022.3176430.","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"using LinearAlgebra; poles = eigvals(linmodel.A)","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"To install the solver, run:","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"using Pkg; Pkg.add(\"DAQP\")","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"Constructing a LinMPC with DAQP:","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"using JuMP, DAQP\ndaqp = Model(DAQP.Optimizer, add_bridges=false)\nmpc2 = LinMPC(kf, Hp=20, Hc=2, Mwt=[0.5], Nwt=[2.5], optim=daqp)\nmpc2 = setconstraint!(mpc2, umin=[-1.5], umax=[+1.5])","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"does improve the rejection of the step disturbance:","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"res_lin2 = sim!(mpc2, N, [180.0]; plant, x0=[π, 0], y_step=[10])\nplot(res_lin2)\nsavefig(ans, \"plot8_NonLinMPC.svg\"); nothing # hide","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"(Image: plot8_NonLinMPC)","category":"page"},{"location":"manual/nonlinmpc/","page":"Nonlinear Design","title":"Nonlinear Design","text":"The closed-loop performance is still lower than the nonlinear controller, as expected, but computations are about 2000 times faster (0.00002 s versus 0.04 s per time steps, on average). Note that linmodel is only valid for angular positions near 180°. Multiple linearized models and controllers are required for large deviations from this operating point. This is known as gain scheduling.","category":"page"},{"location":"public/state_estim/#Functions:-State-Estimators","page":"State Estimators","title":"Functions: State Estimators","text":"","category":"section"},{"location":"public/state_estim/","page":"State Estimators","title":"State Estimators","text":"Pages = [\"state_estim.md\"]","category":"page"},{"location":"public/state_estim/","page":"State Estimators","title":"State Estimators","text":"This module includes many state estimators (or state observer), both for deterministic and stochastic systems. The implementations focus on control applications, that is, relying on the estimates to compute a full state feedback (predictive controllers, in this package). They all incorporates some kind of integral action by default, since it is generally desired to eliminate the steady-state error with closed-loop control (offset-free tracking).","category":"page"},{"location":"public/state_estim/","page":"State Estimators","title":"State Estimators","text":"warning: Warning\nIf you plan to use the estimators for other contexts than this specific package (e.g. : filter, parameter estimation, etc.), careful must be taken at construction since the integral action is not necessarily desired. The options nint_u=0 and nint_ym=0 disable it.","category":"page"},{"location":"public/state_estim/","page":"State Estimators","title":"State Estimators","text":"The estimators are all implemented in the predictor form (a.k.a. observer form), that is, they all estimates at each discrete time k the states of the next period mathbfx_k(k+1)[1]. In contrast, the filter form that estimates mathbfx_k(k) is sometimes slightly more accurate.","category":"page"},{"location":"public/state_estim/","page":"State Estimators","title":"State Estimators","text":"[1]: also denoted mathbfx_k+1k elsewhere.","category":"page"},{"location":"public/state_estim/","page":"State Estimators","title":"State Estimators","text":"The predictor form comes in handy for control applications since the estimations come after the controller computations, without introducing any additional delays. Moreover, the moveinput! method of the predictive controllers does not automatically update the estimates with updatestate!. This allows applying the calculated inputs on the real plant before starting the potentially expensive estimator computations (see Manual for examples).","category":"page"},{"location":"public/state_estim/","page":"State Estimators","title":"State Estimators","text":"info: Info\nAll the estimators support measured mathbfy^m and unmeasured mathbfy^u model outputs, where mathbfy refers to all of them.","category":"page"},{"location":"public/state_estim/#StateEstimator","page":"State Estimators","title":"StateEstimator","text":"","category":"section"},{"location":"public/state_estim/","page":"State Estimators","title":"State Estimators","text":"StateEstimator","category":"page"},{"location":"public/state_estim/#ModelPredictiveControl.StateEstimator","page":"State Estimators","title":"ModelPredictiveControl.StateEstimator","text":"Abstract supertype of all state estimators.\n\n\n\n(estim::StateEstimator)(d=[]) -> ŷ\n\nFunctor allowing callable StateEstimator object as an alias for evaloutput.\n\nExamples\n\njulia> kf = KalmanFilter(setop!(LinModel(tf(3, [10, 1]), 2), yop=[20]));\n\njulia> ŷ = kf() \n1-element Vector{Float64}:\n 20.0\n\n\n\n\n\n","category":"type"},{"location":"public/state_estim/#SteadyKalmanFilter","page":"State Estimators","title":"SteadyKalmanFilter","text":"","category":"section"},{"location":"public/state_estim/","page":"State Estimators","title":"State Estimators","text":"SteadyKalmanFilter","category":"page"},{"location":"public/state_estim/#ModelPredictiveControl.SteadyKalmanFilter","page":"State Estimators","title":"ModelPredictiveControl.SteadyKalmanFilter","text":"SteadyKalmanFilter(model::LinModel; <keyword arguments>)\n\nConstruct a steady-state Kalman Filter with the LinModel model.\n\nThe steady-state (or asymptotic) Kalman filter is based on the process model :\n\nbeginaligned\n    mathbfx(k+1) = \n            mathbfA x(k) + mathbfB_u u(k) + mathbfB_d d(k) + mathbfw(k) \n    mathbfy^m(k) = mathbfC^m x(k) + mathbfD_d^m d(k) + mathbfv(k) \n    mathbfy^u(k) = mathbfC^u x(k) + mathbfD_d^u d(k)\nendaligned\n\nwith sensor mathbfv(k) and process mathbfw(k) noises as uncorrelated zero mean  white noise vectors, with a respective covariance of mathbfR and mathbfQ.  The arguments are in standard deviations σ, i.e. same units than outputs and states. The  matrices mathbfA B_u B_d C D_d are model matrices augmented with the stochastic model, which is specified by the numbers of integrator nint_u and nint_ym (see Extended Help). Likewise, the covariance matrices are augmented with mathbfQ = textdiag(Q  Q_int_u Q_int_ym) and mathbfR = R. The matrices mathbfC^m D_d^m are the rows of mathbfC D_d that correspond to measured outputs mathbfy^m (and  unmeasured ones, for mathbfC^u D_d^u).\n\nArguments\n\nmodel::LinModel : (deterministic) model for the estimations.\ni_ym=1:model.ny : model output indices that are measured mathbfy^m, the rest    are unmeasured mathbfy^u.\nσQ=fill(1/model.nx,model.nx) : main diagonal of the process noise covariance   mathbfQ of model, specified as a standard deviation vector.\nσR=fill(1,length(i_ym)) : main diagonal of the sensor noise covariance mathbfR   of model measured outputs, specified as a standard deviation vector.\nnint_u=0: integrator quantity for the stochastic model of the unmeasured disturbances at   the manipulated inputs (vector), use nint_u=0 for no integrator (see Extended Help).\nσQint_u=fill(1,sum(nint_u)): same than σQ but for the unmeasured disturbances at    manipulated inputs mathbfQ_int_u (composed of integrators).\nnint_ym=default_nint(model,i_ym,nint_u) : same than nint_u but for the unmeasured    disturbances at the measured outputs, use nint_ym=0 for no integrator (see Extended Help).\nσQint_ym=fill(1,sum(nint_ym)) : same than σQ for the unmeasured disturbances at    measured outputs mathbfQ_int_ym (composed of integrators).\n\nExamples\n\njulia> model = LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 0.5);\n\njulia> estim = SteadyKalmanFilter(model, i_ym=[2], σR=[1], σQint_ym=[0.01])\nSteadyKalmanFilter estimator with a sample time Ts = 0.5 s, LinModel and:\n 1 manipulated inputs u (0 integrating states)\n 3 estimated states x̂\n 1 measured outputs ym (1 integrating states)\n 1 unmeasured outputs yu\n 0 measured disturbances d\n\nExtended Help\n\ndetails: Extended Help\nThe model augmentation with nint_u vector adds integrators at model manipulated inputs, and nint_ym, at measured outputs. They create the integral action when the estimator is used in a controller as state feedback. By default, the method default_nint adds one integrator per measured output if feasible. The argument nint_ym can also be tweaked by following these rules on each measured output:Use 0 integrator if the model output is already integrating (else it will be unobservable)\nUse 1 integrator if the disturbances on the output are typically \"step-like\"\nUse 2 integrators if the disturbances on the output are typically \"ramp-like\" The function init_estimstoch builds the stochastic model for estimation.tip: Tip\nIncreasing σQint_u and σQint_ym values increases the integral action \"gain\".The constructor pre-compute the steady-state Kalman gain K̂ with the kalman function. It can sometimes fail, for example when model matrices are ill-conditioned. In such a case, you can try the alternative time-varying KalmanFilter.\n\n\n\n\n\nSteadyKalmanFilter(model, i_ym, nint_u, nint_ym, Q̂, R̂)\n\nConstruct the estimator from the augmented covariance matrices Q̂ and R̂.\n\nThis syntax allows nonzero off-diagonal elements in mathbfQ R.\n\n\n\n\n\n","category":"type"},{"location":"public/state_estim/#KalmanFilter","page":"State Estimators","title":"KalmanFilter","text":"","category":"section"},{"location":"public/state_estim/","page":"State Estimators","title":"State Estimators","text":"KalmanFilter","category":"page"},{"location":"public/state_estim/#ModelPredictiveControl.KalmanFilter","page":"State Estimators","title":"ModelPredictiveControl.KalmanFilter","text":"KalmanFilter(model::LinModel; <keyword arguments>)\n\nConstruct a time-varying Kalman Filter with the LinModel model.\n\nThe process model is identical to SteadyKalmanFilter. The matrix  mathbfP_k(k+1) is the estimation error covariance of model states augmented with the stochastic ones (specified by nint_u and nint_ym). Three keyword arguments modify its initial value with mathbfP_-1(0) =      mathrmdiag mathbfP(0) mathbfP_int_u(0) mathbfP_int_ym(0) .\n\nArguments\n\nmodel::LinModel : (deterministic) model for the estimations.\nσP0=fill(1/model.nx,model.nx) : main diagonal of the initial estimate covariance   mathbfP(0), specified as a standard deviation vector.\nσP0int_u=fill(1,sum(nint_u)) : same than σP0 but for the unmeasured disturbances at    manipulated inputs mathbfP_int_u(0) (composed of integrators).\nσP0int_ym=fill(1,sum(nint_ym)) : same than σP0 but for the unmeasured disturbances at    measured outputs mathbfP_int_ym(0) (composed of integrators).\n<keyword arguments> of SteadyKalmanFilter constructor.\n\nExamples\n\njulia> model = LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 0.5);\n\njulia> estim = KalmanFilter(model, i_ym=[2], σR=[1], σP0=[100, 100], σQint_ym=[0.01])\nKalmanFilter estimator with a sample time Ts = 0.5 s, LinModel and:\n 1 manipulated inputs u (0 integrating states)\n 3 estimated states x̂\n 1 measured outputs ym (1 integrating states)\n 1 unmeasured outputs yu\n 0 measured disturbances d\n\n\n\n\n\nKalmanFilter(model, i_ym, nint_u, nint_ym, P̂0, Q̂, R̂)\n\nConstruct the estimator from the augmented covariance matrices P̂0, Q̂ and R̂.\n\nThis syntax allows nonzero off-diagonal elements in mathbfP_-1(0) mathbfQ R.\n\n\n\n\n\n","category":"type"},{"location":"public/state_estim/#Luenberger","page":"State Estimators","title":"Luenberger","text":"","category":"section"},{"location":"public/state_estim/","page":"State Estimators","title":"State Estimators","text":"Luenberger","category":"page"},{"location":"public/state_estim/#ModelPredictiveControl.Luenberger","page":"State Estimators","title":"ModelPredictiveControl.Luenberger","text":"Luenberger(\n    model::LinModel; \n    i_ym = 1:model.ny, \n    nint_u  = 0,\n    nint_ym = default_nint(model, i_ym),\n    p̂ = 1e-3*(1:(model.nx + sum(nint_u) + sum(nint_ym))) .+ 0.5\n)\n\nConstruct a Luenberger observer with the LinModel model.\n\ni_ym provides the model output indices that are measured mathbfy^m, the rest are unmeasured mathbfy^u. model matrices are augmented with the stochastic model, which is specified by the numbers of integrator nint_u and nint_ym (see SteadyKalmanFilter Extended Help). The argument p̂ is a vector of model.nx + sum(nint_u) + sum(nint_ym) elements specifying the observer poles/eigenvalues (near z=05 by default). The method computes the observer gain K̂ with place.\n\nExamples\n\njulia> model = LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 0.5);\n\njulia> estim = Luenberger(model, nint_ym=[1, 1], p̂=[0.61, 0.62, 0.63, 0.64])\nLuenberger estimator with a sample time Ts = 0.5 s, LinModel and:\n 1 manipulated inputs u (0 integrating states)\n 4 estimated states x̂\n 2 measured outputs ym (2 integrating states)\n 0 unmeasured outputs yu\n 0 measured disturbances d\n\n\n\n\n\n","category":"type"},{"location":"public/state_estim/#UnscentedKalmanFilter","page":"State Estimators","title":"UnscentedKalmanFilter","text":"","category":"section"},{"location":"public/state_estim/","page":"State Estimators","title":"State Estimators","text":"UnscentedKalmanFilter","category":"page"},{"location":"public/state_estim/#ModelPredictiveControl.UnscentedKalmanFilter","page":"State Estimators","title":"ModelPredictiveControl.UnscentedKalmanFilter","text":"UnscentedKalmanFilter(model::SimModel; <keyword arguments>)\n\nConstruct an unscented Kalman Filter with the SimModel model.\n\nBoth LinModel and NonLinModel are supported. The unscented Kalman filter is based on the process model :\n\nbeginaligned\n    mathbfx(k+1) = mathbffBig(mathbfx(k) mathbfu(k) mathbfd(k)Big) \n                        + mathbfw(k)                                                   \n    mathbfy^m(k) = mathbfh^mBig(mathbfx(k) mathbfd(k)Big) + mathbfv(k) \n    mathbfy^u(k) = mathbfh^uBig(mathbfx(k) mathbfd(k)Big)                 \nendaligned\n\nSee SteadyKalmanFilter for details on mathbfv(k) mathbfw(k) noises and mathbfR mathbfQ covariances. The functions mathbff h are model  state-space functions augmented with the stochastic model, which is specified by the numbers of integrator nint_u and nint_ym (see Extended Help). The mathbfh^m function  represents the measured outputs of mathbfh function (and unmeasured ones, for  mathbfh^u).\n\nArguments\n\nmodel::SimModel : (deterministic) model for the estimations.\nα=1e-3 : alpha parameter, spread of the state distribution (0  α  1).\nβ=2 : beta parameter, skewness and kurtosis of the states distribution (β  0).\nκ=0 : kappa parameter, another spread parameter (0  κ  3).\n<keyword arguments> of SteadyKalmanFilter constructor.\n<keyword arguments> of KalmanFilter constructor.\n\nExamples\n\njulia> model = NonLinModel((x,u,_)->0.1x+u, (x,_)->2x, 10.0, 1, 1, 1);\n\njulia> estim = UnscentedKalmanFilter(model, σR=[1], nint_ym=[2], σP0int_ym=[1, 1])\nUnscentedKalmanFilter estimator with a sample time Ts = 10.0 s, NonLinModel and:\n 1 manipulated inputs u (0 integrating states)\n 3 estimated states x̂\n 1 measured outputs ym (2 integrating states)\n 0 unmeasured outputs yu\n 0 measured disturbances d\n\nExtended Help\n\ndetails: Extended Help\nThe Extended Help of SteadyKalmanFilter details the augmentation with nint_ym  and nint_u arguments. Note that the constructor does not validate the observability of the resulting augmented NonLinModel. In such cases, it is the user's  responsibility to ensure that the augmented model is still observable.\n\n\n\n\n\nUnscentedKalmanFilter(model, i_ym, nint_u, nint_ym, P̂0, Q̂, R̂, α, β, κ)\n\nConstruct the estimator from the augmented covariance matrices P̂0, Q̂ and R̂.\n\nThis syntax allows nonzero off-diagonal elements in mathbfP_-1(0) mathbfQ R.\n\n\n\n\n\n","category":"type"},{"location":"public/state_estim/#ExtendedKalmanFilter","page":"State Estimators","title":"ExtendedKalmanFilter","text":"","category":"section"},{"location":"public/state_estim/","page":"State Estimators","title":"State Estimators","text":"ExtendedKalmanFilter","category":"page"},{"location":"public/state_estim/#ModelPredictiveControl.ExtendedKalmanFilter","page":"State Estimators","title":"ModelPredictiveControl.ExtendedKalmanFilter","text":"ExtendedKalmanFilter(model::SimModel; <keyword arguments>)\n\nConstruct an extended Kalman Filter with the SimModel model.\n\nBoth LinModel and NonLinModel are supported. The process model is  identical to UnscentedKalmanFilter. The Jacobians of the augmented model  mathbff h are computed with ForwardDiff.jl automatic differentiation.\n\nwarning: Warning\nSee the Extended Help of linearize function if you get an error like:     MethodError: no method matching (::var\"##\")(::Vector{ForwardDiff.Dual}).\n\nArguments\n\nmodel::SimModel : (deterministic) model for the estimations.\n<keyword arguments> of SteadyKalmanFilter constructor.\n<keyword arguments> of KalmanFilter constructor.\n\nExamples\n\njulia> model = NonLinModel((x,u,_)->0.2x+u, (x,_)->-3x, 5.0, 1, 1, 1);\n\njulia> estim = ExtendedKalmanFilter(model, σQ=[2], σQint_ym=[2], σP0=[0.1], σP0int_ym=[0.1])\nExtendedKalmanFilter estimator with a sample time Ts = 5.0 s, NonLinModel and:\n 1 manipulated inputs u (0 integrating states)\n 2 estimated states x̂\n 1 measured outputs ym (1 integrating states)\n 0 unmeasured outputs yu\n 0 measured disturbances d\n\n\n\n\n\nExtendedKalmanFilter(model, i_ym, nint_u, nint_ym, P̂0, Q̂, R̂)\n\nConstruct the estimator from the augmented covariance matrices P̂0, Q̂ and R̂.\n\nThis syntax allows nonzero off-diagonal elements in mathbfP_-1(0) mathbfQ R.\n\n\n\n\n\n","category":"type"},{"location":"public/state_estim/#MovingHorizonEstimator","page":"State Estimators","title":"MovingHorizonEstimator","text":"","category":"section"},{"location":"public/state_estim/","page":"State Estimators","title":"State Estimators","text":"MovingHorizonEstimator","category":"page"},{"location":"public/state_estim/#ModelPredictiveControl.MovingHorizonEstimator","page":"State Estimators","title":"ModelPredictiveControl.MovingHorizonEstimator","text":"MovingHorizonEstimator(model::SimModel; <keyword arguments>)\n\nConstruct a moving horizon estimator (MHE) based on model (LinModel or NonLinModel).\n\nIt can handle constraints on the estimates, see setconstraint!. Additionally,  model is not linearized like the ExtendedKalmanFilter, and the probability  distribution is not approximated like the UnscentedKalmanFilter. The computational costs are drastically higher, however, since it minimizes the following objective function at each discrete time k:\n\nmin_mathbfx_k(k-N_k+1) mathbfW ϵ   mathbfx mathbfP^-1       mathbfx \n                                            + mathbfW mathbfQ_N_k^-1 mathbfW  \n                                            + mathbfV mathbfR_N_k^-1 mathbfV\n                                            + C ϵ^2\n\nin which the arrival costs are evaluated from the states estimated at time k-N_k:\n\nbeginaligned\n    mathbfx = mathbfx_k-N_k(k-N_k+1) - mathbfx_k(k-N_k+1) \n    mathbfP = mathbfP_k-N_k(k-N_k+1)\nendaligned\n\nand the covariances are repeated N_k times:\n\nbeginaligned\n    mathbfQ_N_k = textdiagmathbf(QQQ)  \n    mathbfR_N_k = textdiagmathbf(RRR) \nendaligned\n\nThe estimation horizon H_e limits the window length: \n\nN_k =                     begincases \n    k + 1     k  H_e    \n    H_e       k  H_e    endcases\n\nThe vectors mathbfW and mathbfV encompass the estimated process noise mathbfw(k-j) and sensor noise mathbfv(k-j) from j=N_k-1 to 0. The  Extended Help defines the two vectors and the scalar ϵ. See UnscentedKalmanFilter for details on he augmented process model and mathbfR mathbfQ covariances. The matrix mathbfP_k-N_k(k-N_k+1) is estimated with an ExtendedKalmanFilter.\n\nwarning: Warning\nSee the Extended Help if you get an error like:     MethodError: no method matching (::var\"##\")(::Vector{ForwardDiff.Dual}).\n\nArguments\n\nmodel::SimModel : (deterministic) model for the estimations.\nHe=nothing : estimation horizon H_e, must be specified.\nCwt=Inf : slack variable weight C, default to Inf meaning hard constraints only.\noptim=default_optim_mhe(model) : a JuMP.Model  with a quadratic/nonlinear optimizer for solving (default to Ipopt,  or OSQP if model is a LinModel).\n<keyword arguments> of SteadyKalmanFilter constructor.\n<keyword arguments> of KalmanFilter constructor.\n\nExamples\n\njulia> model = NonLinModel((x,u,_)->0.1x+u, (x,_)->2x, 10.0, 1, 1, 1);\n\njulia> estim = MovingHorizonEstimator(model, He=5, σR=[1], σP0=[0.01])\nMovingHorizonEstimator estimator with a sample time Ts = 10.0 s, Ipopt optimizer, NonLinModel and:\n 5 estimation steps He\n 1 manipulated inputs u (0 integrating states)\n 2 estimated states x̂\n 1 measured outputs ym (1 integrating states)\n 0 unmeasured outputs yu\n 0 measured disturbances d\n\nExtended Help\n\ndetails: Extended Help\nThe estimated process and sensor noises are defined as:mathbfW = \nbeginbmatrix\n    mathbfw(k-N_k+1)     \n    mathbfw(k-N_k+2)     \n    vdots                  \n    mathbfw(k)\nendbmatrix  quad\nmathbfV =\nbeginbmatrix\n    mathbfv(k-N_k+1)     \n    mathbfv(k-N_k+2)     \n    vdots                  \n    mathbfv(k)\nendbmatrixbased on the augmented model functions mathbff h^m:beginaligned\n    mathbfv(k-j)     = mathbfy^m(k-j) - mathbfh^mBig(mathbfx_k(k-j) mathbfd(k-j)Big) \n    mathbfx_k(k-j+1) = mathbffBig(mathbfx_k(k-j) mathbfu(k-j) mathbfd(k-j)Big) + mathbfw(k-j)\nendalignedThe slack variable ϵ relaxes the constraints if enabled, see setconstraint!.  It is disabled by default for the MHE (from Cwt=Inf) but it should be activated for problems with two or more types of bounds, to ensure feasibility (e.g. on the estimated state and sensor noise).For LinModel, the optimization is treated as a quadratic program with a time-varying Hessian, which is generally cheaper than nonlinear programming. For  NonLinModel, the optimization relies on automatic differentiation (AD). Optimizers generally benefit from exact derivatives like AD. However, the f and h  functions must be compatible with this feature. See Automatic differentiation for common mistakes when writing these functions.\n\n\n\n\n\nMovingHorizonEstimator(model, He, i_ym, nint_u, nint_ym, P̂0, Q̂, R̂, Cwt, optim)\n\nConstruct the estimator from the augmented covariance matrices P̂0, Q̂ and R̂.\n\nThis syntax allows nonzero off-diagonal elements in mathbfP_-1(0) mathbfQ R.\n\n\n\n\n\n","category":"type"},{"location":"public/state_estim/#InternalModel","page":"State Estimators","title":"InternalModel","text":"","category":"section"},{"location":"public/state_estim/","page":"State Estimators","title":"State Estimators","text":"InternalModel","category":"page"},{"location":"public/state_estim/#ModelPredictiveControl.InternalModel","page":"State Estimators","title":"ModelPredictiveControl.InternalModel","text":"InternalModel(model::SimModel; i_ym=1:model.ny, stoch_ym=ss(I,I,I,I,model.Ts))\n\nConstruct an internal model estimator based on model (LinModel or NonLinModel).\n\ni_ym provides the model output indices that are measured mathbfy^m, the rest are  unmeasured mathbfy^u. model evaluates the deterministic predictions  mathbfy_d, and stoch_ym, the stochastic predictions of the measured outputs  mathbfy_s^m (the unmeasured ones being mathbfy_s^u=0). The predicted outputs sum both values : mathbfy = y_d + y_s.\n\nwarning: Warning\nInternalModel estimator does not work if model is integrating or unstable. The  constructor verifies these aspects for LinModel but not for NonLinModel. Uses any  other state estimator in such cases.\n\nExamples\n\njulia> estim = InternalModel(LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 0.5), i_ym=[2])\nInternalModel estimator with a sample time Ts = 0.5 s, LinModel and:\n 1 manipulated inputs u\n 2 estimated states x̂\n 1 measured outputs ym\n 1 unmeasured outputs yu\n 0 measured disturbances d\n\nExtended Help\n\ndetails: Extended Help\nstoch_ym is a TransferFunction or StateSpace object that models disturbances on mathbfy^m. Its input is a hypothetical zero mean white noise vector. stoch_ym  supposes 1 integrator per measured outputs by default, assuming that the current stochastic estimate mathbfy_s^m(k) = mathbfy^m(k) - mathbfy_d^m(k) is constant in the  future. This is the dynamic matrix control (DMC) strategy, which is simple but sometimes too aggressive. Additional poles and zeros in stoch_ym can mitigate this.\n\n\n\n\n\n","category":"type"},{"location":"public/state_estim/#Default-Model-Augmentation","page":"State Estimators","title":"Default Model Augmentation","text":"","category":"section"},{"location":"public/state_estim/","page":"State Estimators","title":"State Estimators","text":"default_nint","category":"page"},{"location":"public/state_estim/#ModelPredictiveControl.default_nint","page":"State Estimators","title":"ModelPredictiveControl.default_nint","text":"default_nint(model::LinModel, i_ym=1:model.ny, nint_u=0) -> nint_ym\n\nGet default integrator quantity per measured outputs nint_ym for LinModel.\n\nThe arguments i_ym and nint_u are the measured output indices and the integrator quantity on each manipulated input, respectively. By default, one integrator is added on each measured outputs. If mathbfA C matrices of the augmented model become unobservable, the integrator is removed. This approach works well for stable, integrating and unstable model (see Examples).\n\nExamples\n\njulia> model = LinModel(append(tf(3, [10, 1]), tf(2, [1, 0]), tf(4,[-5, 1])), 1.0);\n\njulia> nint_ym = default_nint(model)\n3-element Vector{Int64}:\n 1\n 0\n 1\n\n\n\n\n\ndefault_nint(model::SimModel, i_ym=1:model.ny, nint_u=0)\n\nOne integrator on each measured output by default if model is not a  LinModel.\n\nIf the integrator quantity per manipulated input nint_u ≠ 0, the method returns zero integrator on each measured output.\n\n\n\n\n\n","category":"function"},{"location":"func_index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"func_index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"manual/linmpc/#man_lin","page":"Linear Design","title":"Manual: Linear Design","text":"","category":"section"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"Pages = [\"linmpc.md\"]","category":"page"},{"location":"manual/linmpc/#Linear-Model","page":"Linear Design","title":"Linear Model","text":"","category":"section"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"The example considers a continuously stirred-tank reactor (CSTR) with a cold and hot water inlet as a plant. The water flows out of an opening at the bottom of the tank. The manipulated inputs are the cold u_c and hot u_h water flow rates, and the measured outputs are the liquid level y_L and temperature y_T:","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"beginaligned\n    mathbfu = beginbmatrix u_c  u_h endbmatrix \n    mathbfy = beginbmatrix y_L  y_T endbmatrix\nendaligned","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"The following figure depicts the instrumentation installed on the CSTR:","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"<p><img src=\"../../assets/cstr.svg\" alt=\"cstr\" width=275 style=\"background-color:white; \n    border:20px solid white; display: block; margin-left: auto; margin-right: auto;\"/></p>","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"At the steady-state operating points:","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"beginaligned\n    mathbfu_op = beginbmatrix 20  20 endbmatrix \n    mathbfy_op = beginbmatrix 50  30 endbmatrix \nendaligned","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"the following linear model accurately describes the plant dynamics:","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"mathbfG(s) = fracmathbfy(s)mathbfu(s) =\nbeginbmatrix\n    frac19018s + 1  frac19018s + 1 3pt\n    frac-0748s + 1  frac0748s + 1\nendbmatrix","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"We first need to construct a LinModel objet with setop! to handle the operating points:","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"using ModelPredictiveControl, ControlSystemsBase\nG = [ tf(1.90, [18, 1]) tf(1.90, [18, 1]);\n      tf(-0.74,[8, 1])  tf(0.74, [8, 1]) ]\nTs = 2.0\nmodel = setop!(LinModel(G, Ts), uop=[20, 20], yop=[50, 30])","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"The model object will be used for two purposes : to construct our controller, and as a plant simulator to test the design. Its sampling time is 2 s thus the control period will be 2 s as well.","category":"page"},{"location":"manual/linmpc/#Linear-Model-Predictive-Controller","page":"Linear Design","title":"Linear Model Predictive Controller","text":"","category":"section"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"A linear model predictive controller (MPC) will control both the water level y_L and temperature y_T in the tank. The tank level should also never fall below 45:","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"y_L  45","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"We design our LinMPC controllers by including the linear level constraint with setconstraint! (±Inf values should be used when there is no bound):","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"mpc = LinMPC(model, Hp=10, Hc=2, Mwt=[1, 1], Nwt=[0.1, 0.1])\nmpc = setconstraint!(mpc, ymin=[45, -Inf])","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"in which Hp and Hc keyword arguments are respectively the predictive and control horizons, and Mwt and Nwt, the output setpoint tracking and move suppression weights. By default, LinMPC controllers use OSQP to solve the problem, soft constraints on output predictions mathbfy to ensure feasibility, and a SteadyKalmanFilter to estimate the plant states[1]. An attentive reader will also notice that the Kalman filter estimates two additional states compared to the plant model. These are the integrating states for the unmeasured plant disturbances, and they are automatically added to the model outputs by default if observability is preserved (see SteadyKalmanFilter for details).","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"[1]: As an alternative to state observer, we could have use an InternalModel structure with mpc = LinMPC(InternalModel(model), Hp=15, Hc=2, Mwt=[1, 1], Nwt=[0.1, 0.1]). It was tested on the example of this page and it gave similar results.","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"Before closing the loop, we call initstate! with the actual plant inputs and measurements to ensure a bumpless transfer. Since model simulates our plant here, its output will initialize the states. LinModel objects are callable for this purpose (an alias for evaloutput):","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"u, y = model.uop, model() # or equivalently : y = evaloutput(model)\ninitstate!(mpc, u, y)\nnothing # hide","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"We can then close the loop and test mpc performance on the simulator by imposing step changes on output setpoints mathbfr_y and on a load disturbance u_l:","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"function test_mpc(mpc, model)\n    N = 200\n    ry, ul = [50, 30], 0\n    u_data, y_data, ry_data = zeros(model.nu, N), zeros(model.ny, N), zeros(model.ny, N)\n    for i = 1:N\n        i == 51  && (ry = [50, 35])\n        i == 101 && (ry = [54, 30])\n        i == 151 && (ul = -20)\n        y = model() # simulated measurements\n        u = mpc(ry) # or equivalently : u = moveinput!(mpc, ry)\n        u_data[:,i], y_data[:,i], ry_data[:,i] = u, y, ry\n        updatestate!(mpc, u, y) # update mpc state estimate\n        updatestate!(model, u + [0; ul]) # update simulator with the load disturbance\n    end\n    return u_data, y_data, ry_data\nend\nu_data, y_data, ry_data = test_mpc(mpc, model)\nt_data = Ts*(0:(size(y_data,2)-1))\nnothing # hide","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"The LinMPC objects are also callable as an alternative syntax for moveinput!. It is worth mentioning that additional information like the optimal output predictions mathbfY can be retrieved by calling getinfo after solving the problem. Also, calling updatestate! on the mpc object updates its internal state for the NEXT control period (this is by design, see Functions: State Estimators for justifications). That is why the call is done at the end of the for loop. The same logic applies for model.","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"Lastly, we plot the closed-loop test with the Plots package:","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"using Plots\nfunction plot_data(t_data, u_data, y_data, ry_data)\n    p1 = plot(t_data, y_data[1,:], label=\"meas.\"); ylabel!(\"level\")\n    plot!(t_data, ry_data[1,:], label=\"setpoint\", linestyle=:dash, linetype=:steppost)\n    plot!(t_data, fill(45,size(t_data)), label=\"min\", linestyle=:dot, linewidth=1.5)\n    p2 = plot(t_data, y_data[2,:], label=\"meas.\", legend=:topleft); ylabel!(\"temp.\")\n    plot!(t_data, ry_data[2,:],label=\"setpoint\", linestyle=:dash, linetype=:steppost)\n    p3 = plot(t_data,u_data[1,:],label=\"cold\", linetype=:steppost); ylabel!(\"flow rate\")\n    plot!(t_data,u_data[2,:],label=\"hot\", linetype=:steppost); xlabel!(\"time (s)\")\n    return plot(p1, p2, p3, layout=(3,1))\nend\nplot_data(t_data, u_data, y_data, ry_data)\nsavefig(ans, \"plot1_LinMPC.svg\"); nothing # hide","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"(Image: plot1_LinMPC)","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"Compared to the default setting, adding the integrating states at the model inputs may improve the closed-loop performance. Load disturbances are indeed very common in many real-life control problems. Constructing a LinMPC with input integrators:","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"mpc2 = LinMPC(model, Hp=10, Hc=2, Mwt=[1, 1], Nwt=[0.1, 0.1], nint_u=[1, 1])\nmpc2 = setconstraint!(mpc2, ymin=[45, -Inf])","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"does accelerate the rejection of the load disturbance and eliminates the level constraint violation:","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"setstate!(model, zeros(model.nx))\nu, y = model.uop, model()\ninitstate!(mpc2, u, y)\nu_data, y_data, ry_data = test_mpc(mpc2, model)\nplot_data(t_data, u_data, y_data, ry_data)\nsavefig(ans, \"plot2_LinMPC.svg\"); nothing # hide","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"(Image: plot2_LinMPC)","category":"page"},{"location":"manual/linmpc/#Adding-Feedforward-Compensation","page":"Linear Design","title":"Adding Feedforward Compensation","text":"","category":"section"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"Suppose that the load disturbance u_l of the last section is in fact caused by a separate hot water pipe that discharges into the tank. Measuring this flow rate allows us to incorporate feedforward compensation in the controller. The new plant model is:","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"beginbmatrix\n    y_L(s)  y_T(s)\nendbmatrix = \nbeginbmatrix\n    frac19018s + 1  frac19018s + 1  frac19018s + 1 3pt\n    frac-0748s + 1  frac0748s + 1   frac0748s + 1\nendbmatrix\nbeginbmatrix\n    u_c(s)  u_h(s)  u_l(s)\nendbmatrix","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"We need to construct a new LinModel that includes the measured disturbance mathbfd = u_l and the operating point mathbfd_op = 20:","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"model_d = setop!(LinModel([G G[1:2, 2]], Ts, i_d=[3]), uop=[20, 20], yop=[50, 30], dop=[20])","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"A LinMPC controller is constructed on this model:","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"mpc_d = LinMPC(model_d, Hp=10, Hc=2, Mwt=[1, 1], Nwt=[0.1, 0.1])\nmpc_d = setconstraint!(mpc_d, ymin=[45, -Inf])","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"A new test function that feeds the measured disturbance mathbfd to the controller is also required:","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"function test_mpc_d(mpc_d, model)\n    N = 200\n    ry, ul = [50, 30], 0\n    dop = mpc_d.estim.model.dop\n    u_data, y_data, ry_data = zeros(model.nu, N), zeros(model.ny, N), zeros(model.ny, N)\n    for i = 1:N\n        i == 51  && (ry = [50, 35])\n        i == 101 && (ry = [54, 30])\n        i == 151 && (ul = -20)\n        d = ul .+ dop   # simulated measured disturbance\n        y = model()     # simulated measurements\n        u = mpc_d(ry, d) # also feed the measured disturbance d to the controller\n        u_data[:,i], y_data[:,i], ry_data[:,i] = u, y, ry\n        updatestate!(mpc_d, u, y, d)    # update estimate with the measured disturbance d\n        updatestate!(model, u + [0; ul]) # update simulator\n    end\n    return u_data, y_data, ry_data\nend\nnothing # hide","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"The new feedforward compensation is able to almost perfectly reject the load disturbance:","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"setstate!(model, zeros(model.nx))\nu, y, d = model.uop, model(), mpc_d.estim.model.dop\ninitstate!(mpc_d, u, y, d)\nu_data, y_data, ry_data = test_mpc_d(mpc_d, model)\nplot_data(t_data, u_data, y_data, ry_data)\nsavefig(ans, \"plot3_LinMPC.svg\"); nothing # hide","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"(Image: plot3_LinMPC)","category":"page"},{"location":"manual/linmpc/","page":"Linear Design","title":"Linear Design","text":"Note that measured disturbances are assumed constant in the future by default but custom mathbfD predictions are possible. The same applies for the setpoint predictions mathbfR_y.","category":"page"},{"location":"public/sim_model/#func_sim_model","page":"Plant Models","title":"Functions: Plant Models","text":"","category":"section"},{"location":"public/sim_model/","page":"Plant Models","title":"Plant Models","text":"Pages = [\"sim_model.md\"]","category":"page"},{"location":"public/sim_model/","page":"Plant Models","title":"Plant Models","text":"The SimModel types represents discrete state-space models that can be used to construct StateEstimators and PredictiveControllers, or as plant simulators by calling evaloutput and updatestate! methods on SimModel instances (to test estimator/controller designs). For time simulations, the states x are stored inside SimModel instances. Use setstate! method to manually modify them.","category":"page"},{"location":"public/sim_model/#SimModel","page":"Plant Models","title":"SimModel","text":"","category":"section"},{"location":"public/sim_model/","page":"Plant Models","title":"Plant Models","text":"SimModel","category":"page"},{"location":"public/sim_model/#ModelPredictiveControl.SimModel","page":"Plant Models","title":"ModelPredictiveControl.SimModel","text":"Abstract supertype of LinModel and NonLinModel types.\n\n\n\n(model::SimModel)(d=[]) -> y\n\nFunctor allowing callable SimModel object as an alias for evaloutput.\n\nExamples\n\njulia> model = NonLinModel((x,u,_)->-x + u, (x,_)->x .+ 20, 10.0, 1, 1, 1);\n\njulia> y = model()\n1-element Vector{Float64}:\n 20.0\n\n\n\n\n\n","category":"type"},{"location":"public/sim_model/#LinModel","page":"Plant Models","title":"LinModel","text":"","category":"section"},{"location":"public/sim_model/","page":"Plant Models","title":"Plant Models","text":"LinModel","category":"page"},{"location":"public/sim_model/#ModelPredictiveControl.LinModel","page":"Plant Models","title":"ModelPredictiveControl.LinModel","text":"LinModel(sys::StateSpace[, Ts]; i_u=1:size(sys,2), i_d=Int[])\n\nConstruct a linear model from state-space model sys with sampling time Ts in second.\n\nTs can be omitted when sys is discrete-time. Its state-space matrices are:\n\nbeginaligned\n    mathbfx(k+1) = mathbfA x(k) + mathbfB z(k) \n    mathbfy(k)   = mathbfC x(k) + mathbfD z(k)\nendaligned\n\nwith the state mathbfx and output mathbfy vectors. The mathbfz vector  comprises the manipulated inputs mathbfu and measured disturbances mathbfd,  in any order. i_u provides the indices of mathbfz that are manipulated, and i_d,  the measured disturbances. See Extended Help if sys is continuous-time, or discrete-time with Ts ≠ sys.Ts.\n\nSee also ss, tf.\n\nExamples\n\njulia> model = LinModel(ss(0.4, 0.2, 0.3, 0, 0.1))\nDiscrete-time linear model with a sample time Ts = 0.1 s and:\n 1 manipulated inputs u\n 1 states x\n 1 outputs y\n 0 measured disturbances d\n\nExtended Help\n\ndetails: Extended Help\nState-space matrices are similar if sys is continuous (replace mathbfx(k+1) with mathbfx(t) and k with t on the LHS). In such a case, it's  discretized with c2d and :zoh for manipulated inputs, and :tustin, for measured disturbances. Lastly, if  sys is discrete and the provided argument Ts ≠ sys.Ts, the system is resampled by using the aforementioned discretization methods.Note that the constructor transforms the system to its minimal realization using minreal for controllability/observability. As a consequence, the final state-space representation may be different from the one provided in sys. It is also converted  into a more practical form (mathbfD_u=0 because of the zero-order hold):beginaligned\n    mathbfx(k+1) =  mathbfA x(k) + mathbfB_u u(k) + mathbfB_d d(k) \n    mathbfy(k)   =  mathbfC x(k) + mathbfD_d d(k)\nendalignedUse the syntax LinModel{NT}(A, Bu, C, Bd, Dd, Ts) to force a specific state-space representation.\n\n\n\n\n\nLinModel(sys::TransferFunction[, Ts]; i_u=1:size(sys,2), i_d=Int[])\n\nConvert to minimal realization state-space when sys is a transfer function.\n\nsys is equal to fracmathbfy(s)mathbfz(s) for continuous-time, and  fracmathbfy(z)mathbfz(z), for discrete-time.\n\nExamples\n\njulia> model = LinModel([tf(3, [30, 1]) tf(-2, [5, 1])], 0.5, i_d=[2])\nDiscrete-time linear model with a sample time Ts = 0.5 s and:\n 1 manipulated inputs u\n 2 states x\n 1 outputs y\n 1 measured disturbances d\n\n\n\n\n\nLinModel(sys::DelayLtiSystem, Ts; i_u=1:size(sys,2), i_d=Int[])\n\nDiscretize with zero-order hold when sys is a continuous system with delays.\n\nThe delays must be multiples of the sample time Ts.\n\n\n\n\n\nLinModel{NT}(A, Bu, C, Bd, Dd, Ts)\n\nConstruct the model from the discrete state-space matrices A, Bu, C, Bd, Dd directly.\n\nThis syntax do not modify the state-space representation provided in argument (minreal is not called). Care must be taken to ensure that the model is controllable and observable. The optional parameter NT explicitly specifies the number type of the matrices.\n\n\n\n\n\nLinModel(model::NonLinModel; x=model.x, u=model.uop, d=model.dop)\n\nCall linearize(model; x, u, d) and return the resulting linear model.\n\n\n\n\n\n","category":"type"},{"location":"public/sim_model/#NonLinModel","page":"Plant Models","title":"NonLinModel","text":"","category":"section"},{"location":"public/sim_model/","page":"Plant Models","title":"Plant Models","text":"NonLinModel","category":"page"},{"location":"public/sim_model/#ModelPredictiveControl.NonLinModel","page":"Plant Models","title":"ModelPredictiveControl.NonLinModel","text":"NonLinModel{NT}(f::Function, h::Function, Ts, nu, nx, ny, nd=0)\n\nConstruct a nonlinear model from discrete-time state-space functions f and h.\n\nThe state update mathbff and output mathbfh functions are defined as :\n\n    beginaligned\n    mathbfx(k+1) = mathbffBig( mathbfx(k) mathbfu(k) mathbfd(k) Big) \n    mathbfy(k)   = mathbfhBig( mathbfx(k) mathbfd(k) Big)\n    endaligned\n\nTs is the sampling time in second. nu, nx, ny and nd are the respective number of  manipulated inputs, states, outputs and measured disturbances. The optional parameter NT explicitly specifies the number type of vectors (default to Float64).\n\ntip: Tip\nReplace the d argument with _ if nd = 0 (see Examples below).\n\nNonlinear continuous-time state-space functions are not supported for now. In such a case,  manually call a differential equation solver in f (see Manual).\n\nwarning: Warning\nf and h must be pure Julia functions to use the model in NonLinMPC, ExtendedKalmanFilter, MovingHorizonEstimator and linearize.\n\nSee also LinModel.\n\nExamples\n\njulia> model = NonLinModel((x,u,_)->0.1x+u, (x,_)->2x, 10.0, 1, 1, 1)\nDiscrete-time nonlinear model with a sample time Ts = 10.0 s and:\n 1 manipulated inputs u\n 1 states x\n 1 outputs y\n 0 measured disturbances d\n\n\n\n\n\n","category":"type"},{"location":"public/sim_model/#Set-Operating-Points","page":"Plant Models","title":"Set Operating Points","text":"","category":"section"},{"location":"public/sim_model/","page":"Plant Models","title":"Plant Models","text":"setop!","category":"page"},{"location":"public/sim_model/#ModelPredictiveControl.setop!","page":"Plant Models","title":"ModelPredictiveControl.setop!","text":"setop!(model::SimModel; uop=nothing, yop=nothing, dop=nothing) -> model\n\nSet model inputs uop, outputs yop and measured disturbances dop operating points.\n\nThe state-space model with operating points (a.k.a. nominal values) is:\n\nbeginaligned\n    mathbfx(k+1) =  mathbfA x(k) + mathbfB_u u_0(k) + mathbfB_d d_0(k) \n    mathbfy_0(k) =  mathbfC x(k) + mathbfD_d d_0(k)\nendaligned\n\nin which the uop, yop and dop vectors evaluate:\n\nbeginaligned\n    mathbfu_0(k) = mathbfu(k) - mathbfu_op \n    mathbfy_0(k) = mathbfy(k) - mathbfy_op \n    mathbfd_0(k) = mathbfd(k) - mathbfd_op \nendaligned\n\nThe structure is similar if model is a NonLinModel:\n\nbeginaligned\n    mathbfx(k+1) = mathbffBig(mathbfx(k) mathbfu_0(k) mathbfd_0(k)Big)\n    mathbfy_0(k) = mathbfhBig(mathbfx(k) mathbfd_0(k)Big)\nendaligned\n\nExamples\n\njulia> model = setop!(LinModel(tf(3, [10, 1]), 2.0), uop=[50], yop=[20])\nDiscrete-time linear model with a sample time Ts = 2.0 s and:\n 1 manipulated inputs u\n 1 states x\n 1 outputs y\n 0 measured disturbances d\n\n\n\n\n\n","category":"function"},{"location":"public/sim_model/#Linearize","page":"Plant Models","title":"Linearize","text":"","category":"section"},{"location":"public/sim_model/","page":"Plant Models","title":"Plant Models","text":"linearize","category":"page"},{"location":"public/sim_model/#ModelPredictiveControl.linearize","page":"Plant Models","title":"ModelPredictiveControl.linearize","text":"linearize(model::NonLinModel; x=model.x, u=model.uop, d=model.dop) -> linmodel\n\nLinearize model at the operating points x, u, d and return the LinModel.\n\nThe arguments x, u and d are the linearization points for the state mathbfx, manipulated input mathbfu and measured disturbance mathbfd, respectively. The Jacobians of mathbff and mathbfh functions are automatically computed with ForwardDiff.jl.\n\nwarning: Warning\nSee Extended Help if you get an error like:     MethodError: no method matching (::var\"##\")(::Vector{ForwardDiff.Dual}).\n\nExamples\n\njulia> model = NonLinModel((x,u,_)->x.^3 + u, (x,_)->x, 0.1, 1, 1, 1);\n\njulia> linmodel = linearize(model, x=[10.0], u=[0.0]); \n\njulia> linmodel.A\n1×1 Matrix{Float64}:\n 300.0\n\nExtended Help\n\ndetails: Extended Help\nAutomatic differentiation (AD) allows exact Jacobians. The NonLinModel f and h functions must be compatible with this feature though. See Automatic differentiation for common mistakes when writing these functions.\n\n\n\n\n\n","category":"function"},{"location":"public/predictive_control/#Functions:-Predictive-Controllers","page":"Predictive Controllers","title":"Functions: Predictive Controllers","text":"","category":"section"},{"location":"public/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"Pages = [\"predictive_control.md\"]","category":"page"},{"location":"public/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"All the predictive controllers in this module rely on a state estimator to compute the predictions. The default LinMPC estimator is a SteadyKalmanFilter, and NonLinMPC with nonlinear models, an UnscentedKalmanFilter. For simpler and more classical designs, an InternalModel structure is also available, that assumes by default that the current model mismatch estimation is constant in the future (same approach as dynamic matrix control, DMC).","category":"page"},{"location":"public/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"info: Info\nThe nomenclature use capital letters for time series (and matrices) and hats for the predictions (and estimations, for state estimators).","category":"page"},{"location":"public/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"To be precise, at the kth control period, the vectors that encompass the future measured disturbances mathbfd, model outputs mathbfy and setpoints mathbfr_y over the prediction horizon H_p are defined as:","category":"page"},{"location":"public/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"    mathbfD = beginbmatrix\n        mathbfd(k+1)    mathbfd(k+2)    vdots   mathbfd(k+H_p)\n    endbmatrix   quad\n    mathbfY = beginbmatrix\n        mathbfy(k+1)    mathbfy(k+2)    vdots   mathbfy(k+H_p)\n    endbmatrix quad textand quad\n    mathbfR_y = beginbmatrix\n        mathbfr_y(k+1)  mathbfr_y(k+2)  vdots   mathbfr_y(k+H_p)\n    endbmatrix","category":"page"},{"location":"public/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"The vectors for the manipulated input mathbfu are shifted by one time step:","category":"page"},{"location":"public/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"    mathbfU = beginbmatrix\n        mathbfu(k+0)    mathbfu(k+1)    vdots   mathbfu(k+H_p-1)\n    endbmatrix quad textand quad\n    mathbfR_u = beginbmatrix\n        mathbfr_u(k+0)  mathbfr_u(k+1)  vdots   mathbfr_u(k+H_p-1)\n    endbmatrix","category":"page"},{"location":"public/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"Defining the manipulated input increment as mathbfΔu(k+j) = mathbfu(k+j) - mathbfu(k+j-1), the control horizon H_c enforces that mathbfΔu(k+j) = mathbf0 for j  H_c. For this reason, the vector that collects them is truncated up to k+H_c-1:","category":"page"},{"location":"public/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"    mathbfΔU =\n    beginbmatrix\n        mathbfΔu(k+0)  mathbfΔu(k+1)  vdots   mathbfΔu(k+H_c-1)\n    endbmatrix","category":"page"},{"location":"public/predictive_control/#PredictiveController","page":"Predictive Controllers","title":"PredictiveController","text":"","category":"section"},{"location":"public/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"PredictiveController","category":"page"},{"location":"public/predictive_control/#ModelPredictiveControl.PredictiveController","page":"Predictive Controllers","title":"ModelPredictiveControl.PredictiveController","text":"Abstract supertype of all predictive controllers.\n\n\n\n(mpc::PredictiveController)(ry, d=[]; kwargs...) -> u\n\nFunctor allowing callable PredictiveController object as an alias for moveinput!.\n\nExamples\n\njulia> mpc = LinMPC(LinModel(tf(5, [2, 1]), 3), Nwt=[0], Hp=1000, Hc=1);\n\njulia> u = mpc([5]); round.(u, digits=3)\n1-element Vector{Float64}:\n 1.0\n\n\n\n\n\n","category":"type"},{"location":"public/predictive_control/#LinMPC","page":"Predictive Controllers","title":"LinMPC","text":"","category":"section"},{"location":"public/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"LinMPC","category":"page"},{"location":"public/predictive_control/#ModelPredictiveControl.LinMPC","page":"Predictive Controllers","title":"ModelPredictiveControl.LinMPC","text":"LinMPC(model::LinModel; <keyword arguments>)\n\nConstruct a linear predictive controller based on LinModel model.\n\nThe controller minimizes the following objective function at each discrete time k:\n\nbeginaligned\nmin_mathbfΔU ϵ   mathbf(R_y - Y) mathbfM_H_p mathbf(R_y - Y)\n                      + mathbf(ΔU)      mathbfN_H_c mathbf(ΔU)        \n                      + mathbf(R_u - U) mathbfL_H_p mathbf(R_u - U) \n                      + C ϵ^2\nendaligned\n\nin which the weight matrices are repeated H_p or H_c times by default:\n\nbeginaligned\n    mathbfM_H_p = textdiagmathbf(MMM)     \n    mathbfN_H_c = textdiagmathbf(NNN)     \n    mathbfL_H_p = textdiagmathbf(LLL)     \nendaligned\n\nTime-varying weights over the horizons are also supported. The mathbfΔU includes the  input increments mathbfΔu(k+j) = mathbfu(k+j) - mathbfu(k+j-1) from j=0 to H_c-1, the mathbfY vector, the output predictions mathbfy(k+j) from j=1 to H_p, and the mathbfU vector, the manipulated inputs mathbfu(k+j) from j=0 to H_p-1. The slack variable ϵ relaxes the constraints, as described in setconstraint! documentation. See Extended Help for a detailed nomenclature. \n\nThis method uses the default state estimator, a SteadyKalmanFilter with default arguments.\n\nArguments\n\nmodel::LinModel : model used for controller predictions and state estimations.\nHp=10+nk: prediction horizon H_p, nk is the number of delays in model.\nHc=2 : control horizon H_c.\nMwt=fill(1.0,model.ny) : main diagonal of mathbfM weight matrix (vector).\nNwt=fill(0.1,model.nu) : main diagonal of mathbfN weight matrix (vector).\nLwt=fill(0.0,model.nu) : main diagonal of mathbfL weight matrix (vector).\nM_Hp=Diagonal(repeat(Mwt),Hp) : diagonal weight matrix mathbfM_H_p.\nN_Hc=Diagonal(repeat(Nwt),Hc) : diagonal weight matrix mathbfN_H_c.\nL_Hp=Diagonal(repeat(Lwt),Hp) : diagonal weight matrix mathbfL_H_p.\nCwt=1e5 : slack variable weight C (scalar), use Cwt=Inf for hard constraints only.\noptim=JuMP.Model(OSQP.MathOptInterfaceOSQP.Optimizer) : quadratic optimizer used in the predictive controller, provided as a JuMP.Model (default to OSQP optimizer).\nadditional keyword arguments are passed to SteadyKalmanFilter constructor.\n\nExamples\n\njulia> model = LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 4);\n\njulia> mpc = LinMPC(model, Mwt=[0, 1], Nwt=[0.5], Hp=30, Hc=1)\nLinMPC controller with a sample time Ts = 4.0 s, OSQP optimizer, SteadyKalmanFilter estimator and:\n 30 prediction steps Hp\n  1 control steps Hc\n  1 manipulated inputs u (0 integrating states)\n  4 estimated states x̂\n  2 measured outputs ym (2 integrating states)\n  0 unmeasured outputs yu\n  0 measured disturbances d\n\nExtended Help\n\ndetails: Extended Help\nManipulated inputs setpoints mathbfr_u are not common but they can be interesting for over-actuated systems, when nu > ny (e.g. prioritize solutions with lower  economical costs). The default Lwt value implies that this feature is disabled by default.The objective function follows this nomenclature:VARIABLE DESCRIPTION SIZE\nH_p prediction horizon (integer) ()\nH_c control horizon (integer) ()\nmathbfΔU manipulated input increments over H_c (nu*Hc,)\nmathbfY predicted outputs over H_p (ny*Hp,)\nmathbfU manipulated inputs over H_p (nu*Hp,)\nmathbfR_y predicted output setpoints over H_p (ny*Hp,)\nmathbfR_u predicted manipulated input setpoints over H_p (nu*Hp,)\nmathbfM_H_p output setpoint tracking weights over H_p (ny*Hp, ny*Hp)\nmathbfN_H_c manipulated input increment weights over H_c (nu*Hc, nu*Hc)\nmathbfL_H_p manipulated input setpoint tracking weights over H_p (nu*Hp, nu*Hp)\nC slack variable weight ()\nϵ slack variable for constraint softening ()\n\n\n\n\n\nLinMPC(estim::StateEstimator; <keyword arguments>)\n\nUse custom state estimator estim to construct LinMPC.\n\nestim.model must be a LinModel. Else, a NonLinMPC is required. \n\nExamples\n\njulia> estim = KalmanFilter(LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 4), i_ym=[2]);\n\njulia> mpc = LinMPC(estim, Mwt=[0, 1], Nwt=[0.5], Hp=30, Hc=1)\nLinMPC controller with a sample time Ts = 4.0 s, OSQP optimizer, KalmanFilter estimator and:\n 30 prediction steps Hp\n  1 control steps Hc\n  1 manipulated inputs u (0 integrating states)\n  3 estimated states x̂\n  1 measured outputs ym (1 integrating states)\n  1 unmeasured outputs yu\n  0 measured disturbances d\n\n\n\n\n\n","category":"type"},{"location":"public/predictive_control/#ExplicitMPC","page":"Predictive Controllers","title":"ExplicitMPC","text":"","category":"section"},{"location":"public/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"ExplicitMPC","category":"page"},{"location":"public/predictive_control/#ModelPredictiveControl.ExplicitMPC","page":"Predictive Controllers","title":"ModelPredictiveControl.ExplicitMPC","text":"ExplicitMPC(model::LinModel; <keyword arguments>)\n\nConstruct an explicit linear predictive controller based on LinModel model.\n\nThe controller minimizes the following objective function at each discrete time k:\n\nbeginaligned\nmin_mathbfΔU   mathbf(R_y - Y) mathbfM_H_p mathbf(R_y - Y)     \n                   + mathbf(ΔU)      mathbfN_H_c mathbf(ΔU)        \n                   + mathbf(R_u - U) mathbfL_H_p mathbf(R_u - U) \nendaligned\n\nSee LinMPC for the variable definitions. This controller does not support constraints but the computational costs are extremely low (array division), therefore  suitable for applications that require small sample times. The keyword arguments are identical to LinMPC, except for Cwt and optim which are not supported. \n\nThis method uses the default state estimator, a SteadyKalmanFilter with default arguments.\n\nExamples\n\njulia> model = LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 4);\n\njulia> mpc = ExplicitMPC(model, Mwt=[0, 1], Nwt=[0.5], Hp=30, Hc=1)\nExplicitMPC controller with a sample time Ts = 4.0 s, SteadyKalmanFilter estimator and:\n 30 prediction steps Hp\n  1 control steps Hc\n  1 manipulated inputs u (0 integrating states)\n  4 estimated states x̂\n  2 measured outputs ym (2 integrating states)\n  0 unmeasured outputs yu\n  0 measured disturbances d\n\n\n\n\n\nExplicitMPC(estim::StateEstimator; <keyword arguments>)\n\nUse custom state estimator estim to construct ExplicitMPC.\n\nestim.model must be a LinModel. Else, a NonLinMPC is required. \n\nExamples\n\njulia> estim = KalmanFilter(LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 4), i_ym=[2]);\n\njulia> mpc = ExplicitMPC(estim, Mwt=[0, 1], Nwt=[0.5], Hp=30, Hc=1)\nExplicitMPC controller with a sample time Ts = 4.0 s, KalmanFilter estimator and:\n 30 prediction steps Hp\n  1 control steps Hc\n  1 manipulated inputs u (0 integrating states)\n  3 estimated states x̂\n  1 measured outputs ym (1 integrating states)\n  1 unmeasured outputs yu\n  0 measured disturbances d\n\n\n\n\n\n","category":"type"},{"location":"public/predictive_control/#NonLinMPC","page":"Predictive Controllers","title":"NonLinMPC","text":"","category":"section"},{"location":"public/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"NonLinMPC","category":"page"},{"location":"public/predictive_control/#ModelPredictiveControl.NonLinMPC","page":"Predictive Controllers","title":"ModelPredictiveControl.NonLinMPC","text":"NonLinMPC(model::SimModel; <keyword arguments>)\n\nConstruct a nonlinear predictive controller based on SimModel model.\n\nBoth NonLinModel and LinModel are supported (see Extended Help). The  controller minimizes the following objective function at each discrete time k:\n\nbeginaligned\nmin_mathbfΔU ϵ  mathbf(R_y - Y) mathbfM_H_p mathbf(R_y - Y)   \n                       + mathbf(ΔU)      mathbfN_H_c mathbf(ΔU)        \n                       + mathbf(R_u - U) mathbfL_H_p mathbf(R_u - U) \n                       + C ϵ^2  \n                       + E J_E(mathbfU_E mathbfY_E mathbfD_E)\nendaligned\n\nSee LinMPC for the variable definitions. The custom economic function J_E can penalizes solutions with high economic costs. Setting all the weights to 0 except E  creates a pure economic model predictive controller (EMPC). The arguments of J_E are  the manipulated inputs, the predicted outputs and measured disturbances from k to  k+H_p inclusively:\n\n    mathbfU_E = beginbmatrix mathbfU       mathbfu(k+H_p-1)   endbmatrix   quad\n    mathbfY_E = beginbmatrix mathbfy(k)    mathbfY            endbmatrix   quad\n    mathbfD_E = beginbmatrix mathbfd(k)    mathbfD            endbmatrix\n\nsince H_c  H_p implies that mathbfΔu(k+H_p) = mathbf0 or mathbfu(k+H_p)= mathbfu(k+H_p-1). The vector mathbfD includes the predicted measured disturbance over H_p.\n\ntip: Tip\nReplace any of the 3 arguments with _ if not needed (see JE default value below).\n\nThis method uses the default state estimator :\n\nif model is a LinModel, a SteadyKalmanFilter with default arguments;\nelse, an UnscentedKalmanFilter with default arguments. \n\nwarning: Warning\nSee Extended Help if you get an error like:     MethodError: no method matching Float64(::ForwardDiff.Dual).\n\nArguments\n\nmodel::SimModel : model used for controller predictions and state estimations.\nHp=nothing: prediction horizon H_p, must be specified for NonLinModel.\nHc=2 : control horizon H_c.\nMwt=fill(1.0,model.ny) : main diagonal of mathbfM weight matrix (vector).\nNwt=fill(0.1,model.nu) : main diagonal of mathbfN weight matrix (vector).\nLwt=fill(0.0,model.nu) : main diagonal of mathbfL weight matrix (vector).\nM_Hp=Diagonal(repeat(Mwt),Hp) : diagonal weight matrix mathbfM_H_p.\nN_Hc=Diagonal(repeat(Nwt),Hc) : diagonal weight matrix mathbfN_H_c.\nL_Hp=Diagonal(repeat(Lwt),Hp) : diagonal weight matrix mathbfL_H_p.\nCwt=1e5 : slack variable weight C (scalar), use Cwt=Inf for hard constraints only.\nEwt=0.0 : economic costs weight E (scalar). \nJE=(_,_,_)->0.0 : economic function J_E(mathbfU_E mathbfY_E mathbfD_E).\noptim=JuMP.Model(Ipopt.Optimizer) : nonlinear optimizer used in the predictive  controller, provided as a JuMP.Model  (default to Ipopt optimizer).\nadditional keyword arguments are passed to UnscentedKalmanFilter constructor  (or SteadyKalmanFilter, for LinModel).\n\nExamples\n\njulia> model = NonLinModel((x,u,_)->0.5x+u, (x,_)->2x, 10.0, 1, 1, 1);\n\njulia> mpc = NonLinMPC(model, Hp=20, Hc=1, Cwt=1e6)\nNonLinMPC controller with a sample time Ts = 10.0 s, Ipopt optimizer, UnscentedKalmanFilter estimator and:\n 20 prediction steps Hp\n  1 control steps Hc\n  1 manipulated inputs u (0 integrating states)\n  2 estimated states x̂\n  1 measured outputs ym (1 integrating states)\n  0 unmeasured outputs yu\n  0 measured disturbances d\n\nExtended Help\n\ndetails: Extended Help\nNonLinMPC controllers based on LinModel compute the predictions with matrix  algebra instead of a for loop. This feature can accelerate the optimization, especially for the constraint handling, and is not available in any other package, to my knowledge.The optimization relies on JuMP.jl automatic  differentiation (AD) to compute the objective and constraint derivatives. Optimizers  generally benefit from exact derivatives like AD. However, the NonLinModel f  and h functions must be compatible with this feature. See Automatic differentiation for common mistakes when writing these functions.\n\n\n\n\n\nNonLinMPC(estim::StateEstimator; <keyword arguments>)\n\nUse custom state estimator estim to construct NonLinMPC.\n\nExamples\n\njulia> model = NonLinModel((x,u,_)->0.5x+u, (x,_)->2x, 10.0, 1, 1, 1);\n\njulia> estim = UnscentedKalmanFilter(model, σQint_ym=[0.05]);\n\njulia> mpc = NonLinMPC(estim, Hp=20, Hc=1, Cwt=1e6)\nNonLinMPC controller with a sample time Ts = 10.0 s, Ipopt optimizer, UnscentedKalmanFilter estimator and:\n 20 prediction steps Hp\n  1 control steps Hc\n  1 manipulated inputs u (0 integrating states)\n  2 estimated states x̂\n  1 measured outputs ym (1 integrating states)\n  0 unmeasured outputs yu\n  0 measured disturbances d\n\n\n\n\n\n","category":"type"},{"location":"public/predictive_control/#Move-Manipulated-Input-u","page":"Predictive Controllers","title":"Move Manipulated Input u","text":"","category":"section"},{"location":"public/predictive_control/","page":"Predictive Controllers","title":"Predictive Controllers","text":"moveinput!","category":"page"},{"location":"public/predictive_control/#ModelPredictiveControl.moveinput!","page":"Predictive Controllers","title":"ModelPredictiveControl.moveinput!","text":"moveinput!(mpc::PredictiveController, ry=mpc.estim.model.yop, d=[]; <keyword args>) -> u\n\nCompute the optimal manipulated input value u for the current control period.\n\nSolve the optimization problem of mpc PredictiveController and return the results mathbfu(k). Following the receding horizon principle, the algorithm discards the optimal future manipulated inputs mathbfu(k+1) mathbfu(k+2)  Note that the method mutates mpc internal data but it does not modifies mpc.estim states. Call updatestate!(mpc, u, ym, d) to update mpc state estimates.\n\nCalling a PredictiveController object calls this method.\n\nSee also LinMPC, ExplicitMPC, NonLinMPC.\n\nArguments\n\nmpc::PredictiveController : solve optimization problem of mpc.\nry=mpc.estim.model.yop : current output setpoints mathbfr_y(k).\nd=[] : current measured disturbances mathbfd(k).\nD̂=repeat(d, mpc.Hp) : predicted measured disturbances mathbfD, constant in the future by default or mathbfd(k+j)=mathbfd(k) for j=1 to H_p.\nR̂y=repeat(ry, mpc.Hp) : predicted output setpoints mathbfR_y, constant in the future by default or mathbfr_y(k+j)=mathbfr_y(k) for j=1 to H_p.\nR̂u=repeat(mpc.estim.model.uop, mpc.Hp) : predicted manipulated input setpoints, constant in the future by default or mathbfr_u(k+j)=mathbfu_op for j=0 to H_p-1.\nym=nothing : current measured outputs mathbfy^m(k), only required if mpc.estim   is an InternalModel.\n\nExamples\n\njulia> mpc = LinMPC(LinModel(tf(5, [2, 1]), 3), Nwt=[0], Hp=1000, Hc=1);\n\njulia> ry = [5]; u = moveinput!(mpc, ry); round.(u, digits=3)\n1-element Vector{Float64}:\n 1.0\n\n\n\n\n\n","category":"function"},{"location":"public/generic_func/#Functions:-Generic-Functions","page":"Generic Functions","title":"Functions: Generic Functions","text":"","category":"section"},{"location":"public/generic_func/","page":"Generic Functions","title":"Generic Functions","text":"Pages = [\"generic_func.md\"]","category":"page"},{"location":"public/generic_func/","page":"Generic Functions","title":"Generic Functions","text":"This page contains the documentation of functions that are generic to SimModel, StateEstimator and PredictiveController types.","category":"page"},{"location":"public/generic_func/#Set-Constraint","page":"Generic Functions","title":"Set Constraint","text":"","category":"section"},{"location":"public/generic_func/","page":"Generic Functions","title":"Generic Functions","text":"setconstraint!","category":"page"},{"location":"public/generic_func/#ModelPredictiveControl.setconstraint!","page":"Generic Functions","title":"ModelPredictiveControl.setconstraint!","text":"setconstraint!(estim::MovingHorizonEstimator; <keyword arguments>) -> estim\n\nSet the constraint parameters of the MovingHorizonEstimator estim.\n\nIt supports both soft and hard constraints on the estimated state mathbfx, process  noise mathbfw and sensor noise mathbfv:\n\nbeginalignat*3\n    mathbfx_min - c_x_min ϵ    mathbfx_k(k-j+1)  mathbfx_max + c_x_max ϵ qquad  j = N_k N_k - 1   0    \n    mathbfw_min - c_w_min ϵ      mathbfw(k-j+1)  mathbfw_max + c_w_max ϵ qquad  j = N_k N_k - 1   1    \n    mathbfv_min - c_v_min ϵ      mathbfv(k-j+1)  mathbfv_max + c_v_max ϵ qquad  j = N_k N_k - 1   1\nendalignat*\n\nand also ϵ  0. All the constraint parameters are vector. Use ±Inf values when there is no bound. The constraint softness parameters mathbfc, also called equal concern for relaxation, are non-negative values that specify the softness of the associated bound. Use 0.0 values for hard constraints (default for all of them). Notice that constraining the estimated sensor noises is equivalent to bounding the innovation term, since  mathbfv(k) = mathbfy^m(k) - mathbfy^m(k). See Extended Help for details on  model augmentation and time-varying constraints.\n\nArguments\n\ninfo: Info\nThe default constraints are mentioned here for clarity but omitting a keyword argument  will not re-assign to its default value (defaults are set at construction only). The same applies for PredictiveController.\n\nestim::MovingHorizonEstimator : moving horizon estimator to set constraints\nx̂min=fill(-Inf,nx̂) / x̂max=fill(+Inf,nx̂) : estimated state bound mathbfx_minmax\nŵmin=fill(-Inf,nx̂) / ŵmax=fill(+Inf,nx̂) : estimated process noise bound mathbfw_minmax\nv̂min=fill(-Inf,nym) / v̂max=fill(+Inf,nym) : estimated sensor noise bound mathbfv_minmax\nc_x̂min=fill(0.0,nx̂) / c_x̂max=fill(0.0,nx̂) : x̂min / x̂max softness weight mathbfc_x_minmax\nc_ŵmin=fill(0.0,nx̂) / c_ŵmax=fill(0.0,nx̂) : ŵmin / ŵmax softness weight mathbfc_w_minmax\nc_v̂min=fill(0.0,nym) / c_v̂max=fill(0.0,nym) : v̂min / v̂max softness weight mathbfc_v_minmax\nall the keyword arguments above but with a first capital letter, e.g. X̂max or C_ŵmax: for time-varying constraints (see Extended Help)\n\nExamples\n\njulia> estim = MovingHorizonEstimator(LinModel(ss(0.5,1,1,0,1)), He=3);\n\njulia> estim = setconstraint!(estim, x̂min=[-50, -50], x̂max=[50, 50])\nMovingHorizonEstimator estimator with a sample time Ts = 1.0 s, OSQP optimizer, LinModel and:\n 3 estimation steps He\n 1 manipulated inputs u (0 integrating states)\n 2 estimated states x̂\n 1 measured outputs ym (1 integrating states)\n 0 unmeasured outputs yu\n 0 measured disturbances d\n\nExtended Help\n\ndetails: Extended Help\nNote that the state mathbfx and process noise mathbfw constraints are  applied on the augmented model, detailed in SteadyKalmanFilter Extended Help.  For variable constraints, the bounds can be modified after calling updatestate!, that is, at runtime, except for ±Inf bounds. Time-varying constraints over the estimation horizon H_e are also possible, mathematically defined as:beginalignat*3\n    mathbfX_min - C_x_min ϵ  mathbfX  mathbfX_max + C_x_max ϵ \n    mathbfW_min - C_w_min ϵ  mathbfW  mathbfW_max + C_w_max ϵ \n    mathbfV_min - C_v_min ϵ  mathbfV  mathbfV_max + C_v_max ϵ\nendalignat*For this, use the same keyword arguments as above but with a first capital letter:X̂min / X̂max / C_x̂min / C_x̂max : mathbfX constraints (nx̂*(He+1),).\nŴmin / Ŵmax / C_ŵmin / C_ŵmax : mathbfW constraints (nx̂*He,).\nV̂min / V̂max / C_v̂min / C_v̂max : mathbfV constraints (nym*He,).\n\n\n\n\n\nsetconstraint!(mpc::PredictiveController; <keyword arguments>) -> mpc\n\nSet the constraint parameters of the PredictiveController mpc.\n\nThe predictive controllers support both soft and hard constraints, defined by:\n\nbeginalignat*3\n    mathbfu_min  - c_u_min  ϵ        mathbfu(k+j)  mathbfu_max  + c_u_max  ϵ qquad  j = 0 1  H_p - 1 \n    mathbfΔu_min - c_Δu_min ϵ       mathbfΔu(k+j)  mathbfΔu_max + c_Δu_max ϵ qquad  j = 0 1  H_c - 1 \n    mathbfy_min  - c_y_min  ϵ        mathbfy(k+j)  mathbfy_max  + c_y_max  ϵ qquad  j = 1 2  H_p     \n    mathbfx_min  - c_x_min  ϵ  mathbfx_k-1(k+j)  mathbfx_max  + c_x_max  ϵ qquad  j = H_p\nendalignat*\n\nand also ϵ  0. The last line is the terminal constraints applied on the states at the end of the horizon (see Extended Help). See MovingHorizonEstimator constraints for details on bounds and softness parameters mathbfc. The output and terminal  constraints are all soft by default. See Extended Help for time-varying constraints.\n\nArguments\n\nmpc::PredictiveController : predictive controller to set constraints\numin=fill(-Inf,nu) / umax=fill(+Inf,nu) : manipulated input bound mathbfu_minmax\nΔumin=fill(-Inf,nu) / Δumax=fill(+Inf,nu) : manipulated input increment bound mathbfΔu_minmax\nymin=fill(-Inf,ny) / ymax=fill(+Inf,ny) : predicted output bound mathbfy_minmax\nx̂min=fill(-Inf,nx̂) / x̂max=fill(+Inf,nx̂) : terminal constraint bound mathbfx_minmax\nc_umin=fill(0.0,nu) / c_umax=fill(0.0,nu) : umin / umax softness weight mathbfc_u_minmax\nc_Δumin=fill(0.0,nu) / c_Δumax=fill(0.0,nu) : Δumin / Δumax softness weight mathbfc_Δu_minmax\nc_ymin=fill(1.0,ny) / c_ymax=fill(1.0,ny) : ymin / ymax softness weight mathbfc_y_minmax\nc_x̂min=fill(1.0,nx̂) / c_x̂max=fill(1.0,nx̂) : x̂min / x̂max softness weight mathbfc_x_minmax\nall the keyword arguments above but with a first capital letter, except for the terminal constraints, e.g. Ymax or C_Δumin: for time-varying constraints (see Extended Help)\n\nExamples\n\njulia> mpc = LinMPC(setop!(LinModel(tf(3, [30, 1]), 4), uop=[50], yop=[25]));\n\njulia> mpc = setconstraint!(mpc, umin=[0], umax=[100], Δumin=[-10], Δumax=[+10])\nLinMPC controller with a sample time Ts = 4.0 s, OSQP optimizer, SteadyKalmanFilter estimator and:\n 10 prediction steps Hp\n  2 control steps Hc\n  1 manipulated inputs u (0 integrating states)\n  2 estimated states x̂\n  1 measured outputs ym (1 integrating states)\n  0 unmeasured outputs yu\n  0 measured disturbances d\n\nExtended Help\n\ndetails: Extended Help\nTerminal constraints provide closed-loop stability guarantees on the nominal plant model. They can render an unfeasible problem however. In practice, a sufficiently large prediction horizon H_p without terminal constraints is typically enough for  stability. Note that terminal constraints are applied on the augmented state vector  mathbfx (see SteadyKalmanFilter for details on augmentation).For variable constraints, the bounds can be modified after calling moveinput!, that is, at runtime, but not the softness parameters mathbfc. It is not possible to modify ±Inf bounds at runtime.tip: Tip\nTo keep a variable unconstrained while maintaining the ability to add a constraint later at runtime, set the bound to an absolute value sufficiently large when you create the controller (but different than ±Inf).It is also possible to specify time-varying constraints over H_p and H_c  horizons. In such a case, they are defined by:beginalignat*3\n    mathbfU_min  - C_u_min  ϵ  mathbfU   mathbfU_max  + C_u_max  ϵ \n    mathbfΔU_min - C_Δu_min ϵ  mathbfΔU  mathbfΔU_max + C_Δu_max ϵ \n    mathbfY_min  - C_y_min  ϵ  mathbfY   mathbfY_max  + C_y_max  ϵ\nendalignat*For this, use the same keyword arguments as above but with a first capital letter:Umin  / Umax  / C_umin  / C_umax  : mathbfU constraints (nu*Hp,).\nΔUmin / ΔUmax / C_Δumin / C_Δumax : mathbfΔU constraints (nu*Hc,).\nYmin  / Ymax  / C_ymin  / C_ymax  : mathbfY constraints (ny*Hp,).\n\n\n\n\n\n","category":"function"},{"location":"public/generic_func/#Evaluate-Output-y","page":"Generic Functions","title":"Evaluate Output y","text":"","category":"section"},{"location":"public/generic_func/","page":"Generic Functions","title":"Generic Functions","text":"evaloutput","category":"page"},{"location":"public/generic_func/#ModelPredictiveControl.evaloutput","page":"Generic Functions","title":"ModelPredictiveControl.evaloutput","text":"evaloutput(model::SimModel, d=[]) -> y\n\nEvaluate SimModel outputs y from model.x states and measured disturbances d.\n\nCalling a SimModel object calls this evaloutput method.\n\nExamples\n\njulia> model = setop!(LinModel(tf(2, [10, 1]), 5.0), yop=[20]);\n\njulia> y = evaloutput(model)\n1-element Vector{Float64}:\n 20.0\n\n\n\n\n\nevaloutput(estim::StateEstimator, d=[]) -> ŷ\n\nEvaluate StateEstimator outputs ŷ from estim.x̂ states and disturbances d.\n\nCalling a StateEstimator object calls this evaloutput method.\n\nExamples\n\njulia> kf = SteadyKalmanFilter(setop!(LinModel(tf(2, [10, 1]), 5), yop=[20]));\n\njulia> ŷ = evaloutput(kf)\n1-element Vector{Float64}:\n 20.0\n\n\n\n\n\n","category":"function"},{"location":"public/generic_func/#Update-State-x","page":"Generic Functions","title":"Update State x","text":"","category":"section"},{"location":"public/generic_func/","page":"Generic Functions","title":"Generic Functions","text":"updatestate!","category":"page"},{"location":"public/generic_func/#ModelPredictiveControl.updatestate!","page":"Generic Functions","title":"ModelPredictiveControl.updatestate!","text":"updatestate!(model::SimModel, u, d=[]) -> x\n\nUpdate model.x states with current inputs u and measured disturbances d.\n\nExamples\n\njulia> model = LinModel(ss(1.0, 1.0, 1.0, 0, 1.0));\n\njulia> x = updatestate!(model, [1])\n1-element Vector{Float64}:\n 1.0\n\n\n\n\n\nupdatestate!(estim::StateEstimator, u, ym, d=[]) -> x̂\n\nUpdate estim.x̂ estimate with current inputs u, measured outputs ym and dist. d. \n\nThe method removes the operating points with remove_op! and call  update_estimate!.\n\nExamples\n\njulia> kf = SteadyKalmanFilter(LinModel(ss(0.1, 0.5, 1, 0, 4.0)));\n\njulia> x̂ = updatestate!(kf, [1], [0]) # x̂[2] is the integrator state (nint_ym argument)\n2-element Vector{Float64}:\n 0.5\n 0.0\n\n\n\n\n\nupdatestate!(mpc::PredictiveController, u, ym, d=[]) -> x̂\n\nCall updatestate! on mpc.estim StateEstimator.\n\n\n\n\n\n","category":"function"},{"location":"public/generic_func/#Init-State-x","page":"Generic Functions","title":"Init State x","text":"","category":"section"},{"location":"public/generic_func/","page":"Generic Functions","title":"Generic Functions","text":"initstate!","category":"page"},{"location":"public/generic_func/#ModelPredictiveControl.initstate!","page":"Generic Functions","title":"ModelPredictiveControl.initstate!","text":"initstate!(model::SimModel, u, d=[]) -> x\n\nInit model.x with manipulated inputs u and measured disturbances d steady-state.\n\nIt calls steadystate!(model, u, d):\n\nIf model is a LinModel, the method computes the steady-state of current inputs u and measured disturbances d.\nElse, model.x is left unchanged. Use setstate! to manually modify it.\n\nExamples\n\njulia> model = LinModel(tf(6, [10, 1]), 2.0);\n\njulia> u = [1]; x = initstate!(model, u); y = round.(evaloutput(model), digits=3)\n1-element Vector{Float64}:\n 6.0\n \njulia> x ≈ updatestate!(model, u)\ntrue\n\n\n\n\n\ninitstate!(estim::StateEstimator, u, ym, d=[]) -> x̂\n\nInit estim.x̂ states from current inputs u, measured outputs ym and disturbances d.\n\nThe method tries to find a good stead-state for the initial esitmate mathbfx(0). It removes the operating points with remove_op! and call init_estimate!:\n\nIf estim.model is a LinModel, it finds the steady-state of the augmented model using u and d arguments, and uses the ym argument to enforce that  mathbfy^m(0) = mathbfy^m(0). For control applications, this solution produces a bumpless manual to automatic transfer. See init_estimate! for details.\nElse, estim.x̂ is left unchanged. Use setstate! to manually modify it.\n\nIf applicable, it also sets the error covariance estim.P̂ to estim.P̂0.\n\nExamples\n\njulia> estim = SteadyKalmanFilter(LinModel(tf(3, [10, 1]), 0.5), nint_ym=[2]);\n\njulia> u = [1]; y = [3 - 0.1]; x̂ = round.(initstate!(estim, u, y), digits=3)\n3-element Vector{Float64}:\n  5.0\n  0.0\n -0.1\n\njulia> x̂ ≈ updatestate!(estim, u, y)\ntrue\n\njulia> evaloutput(estim) ≈ y\ntrue\n\n\n\n\n\ninitstate!(mpc::PredictiveController, u, ym, d=[]) -> x̂\n\nInit the states of mpc.estim StateEstimator and warm start mpc.ΔŨ at zero.\n\n\n\n\n\n","category":"function"},{"location":"public/generic_func/#Set-State-x","page":"Generic Functions","title":"Set State x","text":"","category":"section"},{"location":"public/generic_func/","page":"Generic Functions","title":"Generic Functions","text":"setstate!","category":"page"},{"location":"public/generic_func/#ModelPredictiveControl.setstate!","page":"Generic Functions","title":"ModelPredictiveControl.setstate!","text":"setstate!(model::SimModel, x)\n\nSet model.x states to values specified by x. \n\n\n\n\n\nsetstate!(estim::StateEstimator, x̂)\n\nSet estim.x̂ states to values specified by x̂. \n\n\n\n\n\nsetstate!(mpc::PredictiveController, x̂)\n\nSet the estimate at mpc.estim.x̂.\n\n\n\n\n\n","category":"function"},{"location":"public/generic_func/#Quick-Simulation","page":"Generic Functions","title":"Quick Simulation","text":"","category":"section"},{"location":"public/generic_func/#Simulate","page":"Generic Functions","title":"Simulate","text":"","category":"section"},{"location":"public/generic_func/","page":"Generic Functions","title":"Generic Functions","text":"sim!","category":"page"},{"location":"public/generic_func/#ModelPredictiveControl.sim!","page":"Generic Functions","title":"ModelPredictiveControl.sim!","text":"sim!(plant::SimModel, N::Int, u=plant.uop.+1, d=plant.dop; x0=zeros(plant.nx)) -> res\n\nOpen-loop simulation of plant for N time steps, default to unit bump test on all inputs.\n\nThe manipulated inputs mathbfu and measured disturbances mathbfd are held constant at u and d values, respectively. The plant initial state mathbfx(0) is specified by x0 keyword arguments. The function returns SimResult instances that can be visualized by calling plot from Plots.jl  on them (see Examples below). Note that the method mutates plant internal states.\n\nExamples\n\njulia> plant = NonLinModel((x,u,d)->0.1x+u+d, (x,_)->2x, 10.0, 1, 1, 1, 1);\n\njulia> res = sim!(plant, 15, [0], [0], x0=[1])\nSimulation results of NonLinModel with 15 time steps.\n\njulia> using Plots; plot(res, plotu=false, plotd=false, plotx=true)\n\n\n\n\n\n\nsim!(\n    estim::StateEstimator,\n    N::Int,\n    u = estim.model.uop .+ 1,\n    d = estim.model.dop;\n    <keyword arguments>\n) -> res\n\nClosed-loop simulation of estim estimator for N steps, default to input bumps.\n\nSee Arguments for the available options. The noises are provided as standard deviations σ vectors. The simulated sensor and process noises of plant are specified by y_noise and x_noise arguments, respectively.\n\nArguments\n\nestim::StateEstimator : state estimator to simulate\nN::Int : simulation length in time steps\nu = estim.model.uop .+ 1 : manipulated input mathbfu value\nd = estim.model.dop : plant measured disturbance mathbfd value\nplant::SimModel = estim.model : simulated plant model\nu_step  = zeros(plant.nu) : step load disturbance on plant inputs mathbfu\nu_noise = zeros(plant.nu) : gaussian load disturbance on plant inputs mathbfu\ny_step  = zeros(plant.ny) : step disturbance on plant outputs mathbfy\ny_noise = zeros(plant.ny) : additive gaussian noise on plant outputs mathbfy\nd_step  = zeros(plant.nd) : step on measured disturbances mathbfd\nd_noise = zeros(plant.nd) : additive gaussian noise on measured dist. mathbfd\nx_noise = zeros(plant.nx) : additive gaussian noise on plant states mathbfx\nx0 = plant.x : plant initial state mathbfx(0)\nx̂0 = nothing : initial estimate mathbfx(0), initstate! is used if nothing\nlastu = plant.uop : last plant input mathbfu for mathbfx initialization\n\nExamples\n\njulia> model = LinModel(tf(3, [30, 1]), 0.5);\n\njulia> estim = KalmanFilter(model, σR=[0.5], σQ=[0.25], σQint_ym=[0.01], σP0int_ym=[0.1]);\n\njulia> res = sim!(estim, 50, [0], y_noise=[0.5], x_noise=[0.25], x0=[-10], x̂0=[0, 0])\nSimulation results of KalmanFilter with 50 time steps.\n\njulia> using Plots; plot(res, plotŷ=true, plotu=false, plotxwithx̂=true)\n\n\n\n\n\n\nsim!(\n    mpc::PredictiveController, \n    N::Int,\n    ry = mpc.estim.model.yop .+ 1, \n    d  = mpc.estim.model.dop,\n    ru = mpc.estim.model.uop;\n    <keyword arguments>\n) -> res\n\nClosed-loop simulation of mpc controller for N steps, default to output setpoint bumps.\n\nThe output and manipulated input setpoints are held constant at ry and ru, respectively. The keyword arguments are identical to sim!(::StateEstimator, ::Int).\n\nExamples\n\njulia> model = LinModel([tf(3, [30, 1]); tf(2, [5, 1])], 4);\n\njulia> mpc = setconstraint!(LinMPC(model, Mwt=[0, 1], Nwt=[0.01], Hp=30), ymin=[0, -Inf]);\n\njulia> res = sim!(mpc, 25, [0, 0], y_noise=[0.1], y_step=[-10, 0])\nSimulation results of LinMPC with 25 time steps.\n\njulia> using Plots; plot(res, plotry=true, plotŷ=true, plotymin=true, plotu=true)\n\n\n\n\n\n\n","category":"function"},{"location":"public/generic_func/#Simulation-Results","page":"Generic Functions","title":"Simulation Results","text":"","category":"section"},{"location":"public/generic_func/","page":"Generic Functions","title":"Generic Functions","text":"SimResult","category":"page"},{"location":"public/generic_func/#ModelPredictiveControl.SimResult","page":"Generic Functions","title":"ModelPredictiveControl.SimResult","text":"SimResult(\n    obj::Union{SimModel, StateEstimator, PredictiveController}, \n    U_data, \n    Y_data, \n    D_data  = [];\n    X_data  = nothing,\n    X̂_data  = nothing, \n    Ry_data = nothing, \n    Ru_data = nothing\n)\n\nManually construct a SimResult to quickly plot obj simulations.\n\nExcept for obj, all the arguments should be matrices of N columns, where N is the  number of time steps. SimResult objects allow to quickly plot simulation results. Simply call plot from Plots.jl on them.\n\nExamples\n\njulia> plant = LinModel(tf(1, [1, 1]), 1.0); N = 5; U_data = fill(1.0, 1, N);\n\njulia> Y_data = reduce(hcat, (updatestate!(plant, U_data[:, i]); plant()) for i=1:N)\n1×5 Matrix{Float64}:\n 0.632121  0.864665  0.950213  0.981684  0.993262\n\njulia> res = SimResult(plant, U_data, Y_data)\nSimulation results of LinModel with 5 time steps.\n\njulia> using Plots; plot(res)\n\n\n\n\n\n\n","category":"type"},{"location":"public/generic_func/#Get-Additional-Information","page":"Generic Functions","title":"Get Additional Information","text":"","category":"section"},{"location":"public/generic_func/","page":"Generic Functions","title":"Generic Functions","text":"getinfo","category":"page"},{"location":"public/generic_func/#ModelPredictiveControl.getinfo","page":"Generic Functions","title":"ModelPredictiveControl.getinfo","text":"getinfo(estim::MovingHorizonEstimator) -> info\n\nGet additional info on estim MovingHorizonEstimator optimum for troubleshooting.\n\nThe function should be called after calling updatestate!. It returns the dictionary info with the following fields:\n\n:Ŵ   : optimal estimated process noise over N_k, mathbfW\n:x̂arr: optimal estimated state at arrival, mathbfx_k(k-N_k+1)\n:ϵ   : optimal slack variable, ϵ\n:J   : objective value optimum, J\n:X̂   : optimal estimated states over N_k+1, mathbfX\n:x̂   : optimal estimated state for the next time step, mathbfx_k(k+1)\n:V̂   : optimal estimated sensor noise over N_k, mathbfV\n:P̄   : estimation error covariance at arrival, mathbfP\n:x̄   : optimal estimation error at arrival, mathbfx\n:Ŷ   : optimal estimated outputs over N_k, mathbfY\n:Ŷm  : optimal estimated measured outputs over N_k, mathbfY^m\n:Ym  : measured outputs over N_k, mathbfY^m\n:U   : manipulated inputs over N_k, mathbfU\n:D   : measured disturbances over N_k, mathbfD\n:sol : solution summary of the optimizer for printing\n\nExamples\n\njulia> estim = MovingHorizonEstimator(LinModel(ss(1.0, 1.0, 1.0, 0, 1)), He=1, nint_ym=0);\n\njulia> updatestate!(estim, [0], [1]);\n\njulia> round.(getinfo(estim)[:Ŷ], digits=3)\n1-element Vector{Float64}:\n 0.5\n\n\n\n\n\ngetinfo(mpc::PredictiveController) -> info\n\nGet additional info about mpc PredictiveController optimum for troubleshooting.\n\nThe function should be called after calling moveinput!. It returns the dictionary info with the following fields:\n\n:ΔU  : optimal manipulated input increments over H_c, mathbfΔU\n:ϵ   : optimal slack variable, ϵ\n:J   : objective value optimum, J\n:U   : optimal manipulated inputs over H_p, mathbfU\n:u   : current optimal manipulated input, mathbfu(k)\n:d   : current measured disturbance, mathbfd(k)\n:D̂   : predicted measured disturbances over H_p, mathbfD\n:ŷ   : current estimated output, mathbfy(k)\n:Ŷ   : optimal predicted outputs over H_p, mathbfY\n:x̂end: optimal terminal states, mathbfx_k-1(k+H_p)\n:Ŷs  : predicted stochastic output over H_p of InternalModel, mathbfY_s\n:R̂y  : predicted output setpoint over H_p, mathbfR_y\n:R̂u  : predicted manipulated input setpoint over H_p, mathbfR_u\n\nFor LinMPC and NonLinMPC, the field :sol also contains the optimizer solution summary that can be printed. Lastly, the optimal economic cost :JE is also available for NonLinMPC.\n\nExamples\n\njulia> mpc = LinMPC(LinModel(tf(5, [2, 1]), 3), Nwt=[0], Hp=1, Hc=1);\n\njulia> u = moveinput!(mpc, [10]);\n\njulia> round.(getinfo(mpc)[:Ŷ], digits=3)\n1-element Vector{Float64}:\n 10.0\n\n\n\n\n\n","category":"function"},{"location":"#ModelPredictiveControl.jl","page":"Home","title":"ModelPredictiveControl.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An open source model predictive control package for Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package depends on ControlSystemsBase.jl for the linear systems and JuMP.jl for the solving.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The objective is to provide a simple, clear and modular framework to quickly design model predictive controllers (MPCs) in Julia, while preserving the flexibility for advanced real-time optimization. Modern MPCs based on closed-loop state estimators are the main focus of the package, but classical approaches that rely on internal models are also possible. The JuMP.jl interface allows the user to test different solvers easily if the performance of the default settings is not satisfactory.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The documentation is divided in two parts:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Manual — This section includes step-by-step guides to design predictive controllers on multiple case studies.\nFunctions — Documentation of methods and types exported by the package. The \"Internals\" section provides implementation details of functions that are not exported.","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Depth = 2\nPages = [\n    \"manual/installation.md\",\n    \"manual/linmpc.md\",\n    \"manual/nonlinmpc.md\",\n]","category":"page"},{"location":"#Functions:-Public","page":"Home","title":"Functions: Public","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Depth = 2\nPages = [\n    \"public/sim_model.md\",\n    \"public/state_estim.md\",\n    \"public/predictive_control.md\",\n    \"public/generic_func.md\",\n]","category":"page"},{"location":"#Functions:-Internals","page":"Home","title":"Functions: Internals","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Depth = 1\nPages = [\n    \"internals/sim_model.md\",\n    \"internals/state_estim.md\",\n    \"internals/predictive_control.md\",\n]","category":"page"},{"location":"internals/sim_model/#Functions:-SimModel-Internals","page":"Plant Models","title":"Functions: SimModel Internals","text":"","category":"section"},{"location":"internals/sim_model/","page":"Plant Models","title":"Plant Models","text":"Pages = [\"sim_model.md\"]","category":"page"},{"location":"internals/sim_model/#State-Space-Functions","page":"Plant Models","title":"State-Space Functions","text":"","category":"section"},{"location":"internals/sim_model/","page":"Plant Models","title":"Plant Models","text":"ModelPredictiveControl.f\nModelPredictiveControl.h","category":"page"},{"location":"internals/sim_model/#ModelPredictiveControl.f","page":"Plant Models","title":"ModelPredictiveControl.f","text":"f(model::LinModel, x, u, d)\n\nEvaluate mathbfA x + B_u u + B_d d when model is a LinModel.\n\n\n\n\n\nCall mathbff(x u d) with model.f function for NonLinModel.\n\n\n\n\n\n","category":"function"},{"location":"internals/sim_model/#ModelPredictiveControl.h","page":"Plant Models","title":"ModelPredictiveControl.h","text":"h(model::LinModel, x, d)\n\nEvaluate mathbfC x + D_d d when model is a LinModel.\n\n\n\n\n\nCall mathbfh(x d) with model.h function for NonLinModel.\n\n\n\n\n\n","category":"function"},{"location":"internals/sim_model/#Steady-State-Calculation","page":"Plant Models","title":"Steady-State Calculation","text":"","category":"section"},{"location":"internals/sim_model/","page":"Plant Models","title":"Plant Models","text":"ModelPredictiveControl.steadystate!","category":"page"},{"location":"internals/sim_model/#ModelPredictiveControl.steadystate!","page":"Plant Models","title":"ModelPredictiveControl.steadystate!","text":"steadystate!(model::LinModel, u, d)\n\nSet model.x to u and d steady-state if model is a LinModel.\n\nFollowing setop! notation, the method evaluates the equilibrium mathbfx from:\n\n    mathbfx = mathbf(I - A)^-1(B_u u_0 + B_d d_0)\n\nwith constant manipulated inputs mathbfu_0 = u - u_op and measured disturbances mathbfd_0 = d - d_op. The Moore-Penrose pseudo-inverse computes  mathbf(I - A)^-1 to support integrating model (integrator states will be 0).\n\n\n\n\n\nDo nothing if model is a NonLinModel.\n\n\n\n\n\n","category":"function"}]
}
