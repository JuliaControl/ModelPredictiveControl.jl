<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Predictive Controllers · ModelPredictiveControl.jl</title><meta name="title" content="Predictive Controllers · ModelPredictiveControl.jl"/><meta property="og:title" content="Predictive Controllers · ModelPredictiveControl.jl"/><meta property="twitter:title" content="Predictive Controllers · ModelPredictiveControl.jl"/><meta name="description" content="Documentation for ModelPredictiveControl.jl."/><meta property="og:description" content="Documentation for ModelPredictiveControl.jl."/><meta property="twitter:description" content="Documentation for ModelPredictiveControl.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="ModelPredictiveControl.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="ModelPredictiveControl.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelPredictiveControl.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/installation/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/linmpc/">Linear Design</a></li><li><a class="tocitem" href="../../manual/nonlinmpc/">Nonlinear Design</a></li></ul></li></ul></li><li><span class="tocitem">Functions</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox" checked/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Public</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../sim_model/">Plant Models</a></li><li><a class="tocitem" href="../state_estim/">State Estimators</a></li><li class="is-active"><a class="tocitem" href>Predictive Controllers</a><ul class="internal"><li><a class="tocitem" href="#PredictiveController"><span>PredictiveController</span></a></li><li><a class="tocitem" href="#LinMPC"><span>LinMPC</span></a></li><li><a class="tocitem" href="#ExplicitMPC"><span>ExplicitMPC</span></a></li><li><a class="tocitem" href="#NonLinMPC"><span>NonLinMPC</span></a></li><li><a class="tocitem" href="#Set-Constraint"><span>Set Constraint</span></a></li><li><a class="tocitem" href="#Move-Manipulated-Input-u"><span>Move Manipulated Input u</span></a></li><li><a class="tocitem" href="#Get-Additional-Information"><span>Get Additional Information</span></a></li></ul></li><li><a class="tocitem" href="../generic_func/">Generic Functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../internals/sim_model/">Plant Models</a></li><li><a class="tocitem" href="../../internals/state_estim/">State Estimators</a></li><li><a class="tocitem" href="../../internals/predictive_control/">Predictive Controllers</a></li></ul></li></ul></li><li><a class="tocitem" href="../../func_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functions</a></li><li><a class="is-disabled">Public</a></li><li class="is-active"><a href>Predictive Controllers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Predictive Controllers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/franckgaga/ModelPredictiveControl.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/franckgaga/ModelPredictiveControl.jl/blob/main/docs/src/public/predictive_control.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions:-Predictive-Controllers"><a class="docs-heading-anchor" href="#Functions:-Predictive-Controllers">Functions: Predictive Controllers</a><a id="Functions:-Predictive-Controllers-1"></a><a class="docs-heading-anchor-permalink" href="#Functions:-Predictive-Controllers" title="Permalink"></a></h1><ul><li><a href="#Functions:-Predictive-Controllers">Functions: Predictive Controllers</a></li><li class="no-marker"><ul><li><a href="#PredictiveController">PredictiveController</a></li><li><a href="#LinMPC">LinMPC</a></li><li><a href="#ExplicitMPC">ExplicitMPC</a></li><li><a href="#NonLinMPC">NonLinMPC</a></li><li><a href="#Set-Constraint">Set Constraint</a></li><li><a href="#Move-Manipulated-Input-u">Move Manipulated Input u</a></li><li><a href="#Get-Additional-Information">Get Additional Information</a></li></ul></li></ul><p>All the predictive controllers in this module rely on a state estimator to compute the predictions. The default <a href="#ModelPredictiveControl.LinMPC"><code>LinMPC</code></a> estimator is a <a href="../state_estim/#ModelPredictiveControl.SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a>, and <a href="#ModelPredictiveControl.NonLinMPC"><code>NonLinMPC</code></a> with nonlinear models, an <a href="../state_estim/#ModelPredictiveControl.UnscentedKalmanFilter"><code>UnscentedKalmanFilter</code></a>. For simpler and more classical designs, an <a href="../state_estim/#ModelPredictiveControl.InternalModel"><code>InternalModel</code></a> structure is also available, that assumes by default that the current model mismatch estimation is constant in the future (same approach as dynamic matrix control, DMC).</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The nomenclature use capital letters for time series (and matrices) and hats for the predictions (and estimations, for state estimators).</p></div></div><p>To be precise, at the <span>$k$</span>th control period, the vectors that encompass the future measured disturbances <span>$\mathbf{d̂}$</span>, model outputs <span>$\mathbf{ŷ}$</span> and setpoints <span>$\mathbf{r̂_y}$</span> over the prediction horizon <span>$H_p$</span> are defined as:</p><p class="math-container">\[    \mathbf{D̂} = \begin{bmatrix}
        \mathbf{d̂}(k+1)   \\ \mathbf{d̂}(k+2)   \\ \vdots  \\ \mathbf{d̂}(k+H_p)
    \end{bmatrix} \: , \quad
    \mathbf{Ŷ} = \begin{bmatrix}
        \mathbf{ŷ}(k+1)   \\ \mathbf{ŷ}(k+2)   \\ \vdots  \\ \mathbf{ŷ}(k+H_p)
    \end{bmatrix} \quad \text{and} \quad
    \mathbf{R̂_y} = \begin{bmatrix}
        \mathbf{r̂_y}(k+1) \\ \mathbf{r̂_y}(k+2) \\ \vdots  \\ \mathbf{r̂_y}(k+H_p)
    \end{bmatrix}\]</p><p>The vectors for the manipulated input <span>$\mathbf{u}$</span> are shifted by one time step:</p><p class="math-container">\[    \mathbf{U} = \begin{bmatrix}
        \mathbf{u}(k+0)   \\ \mathbf{u}(k+1)   \\ \vdots  \\ \mathbf{u}(k+H_p-1)
    \end{bmatrix} \quad \text{and} \quad
    \mathbf{R̂_u} = \begin{bmatrix}
        \mathbf{r̂_u}(k+0) \\ \mathbf{r̂_u}(k+1) \\ \vdots  \\ \mathbf{r̂_u}(k+H_p-1)
    \end{bmatrix}\]</p><p>Defining the manipulated input increment as <span>$\mathbf{Δu}(k+j) = \mathbf{u}(k+j) - \mathbf{u}(k+j-1)$</span>, the control horizon <span>$H_c$</span> enforces that <span>$\mathbf{Δu}(k+j) = \mathbf{0}$</span> for <span>$j ≥ H_c$</span>. For this reason, the vector that collects them is truncated up to <span>$k+H_c-1$</span>:</p><p class="math-container">\[    \mathbf{ΔU} =
    \begin{bmatrix}
        \mathbf{Δu}(k+0) \\ \mathbf{Δu}(k+1) \\ \vdots  \\ \mathbf{Δu}(k+H_c-1)
    \end{bmatrix}\]</p><h2 id="PredictiveController"><a class="docs-heading-anchor" href="#PredictiveController">PredictiveController</a><a id="PredictiveController-1"></a><a class="docs-heading-anchor-permalink" href="#PredictiveController" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.PredictiveController" href="#ModelPredictiveControl.PredictiveController"><code>ModelPredictiveControl.PredictiveController</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract supertype of all predictive controllers.</p><hr/><pre><code class="nohighlight hljs">(mpc::PredictiveController)(ry, d=[]; kwargs...) -&gt; u</code></pre><p>Functor allowing callable <code>PredictiveController</code> object as an alias for <a href="#ModelPredictiveControl.moveinput!"><code>moveinput!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mpc = LinMPC(LinModel(tf(5, [2, 1]), 3), Nwt=[0], Hp=1000, Hc=1);

julia&gt; u = mpc([5]); round.(u, digits=3)
1-element Vector{Float64}:
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/franckgaga/ModelPredictiveControl.jl/blob/6c28cfb718464c5ee95f21b36d34a9ed7112fc89/src/predictive_control.jl#L1-L19">source</a></section></article><h2 id="LinMPC"><a class="docs-heading-anchor" href="#LinMPC">LinMPC</a><a id="LinMPC-1"></a><a class="docs-heading-anchor-permalink" href="#LinMPC" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.LinMPC" href="#ModelPredictiveControl.LinMPC"><code>ModelPredictiveControl.LinMPC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinMPC(model::LinModel; &lt;keyword arguments&gt;)</code></pre><p>Construct a linear predictive controller based on <a href="../sim_model/#ModelPredictiveControl.LinModel"><code>LinModel</code></a> <code>model</code>.</p><p>The controller minimizes the following objective function at each discrete time <span>$k$</span>:</p><p class="math-container">\[\min_{\mathbf{ΔU}, ϵ}    \mathbf{(R̂_y - Ŷ)}&#39; \mathbf{M}_{H_p} \mathbf{(R̂_y - Ŷ)}   
                       + \mathbf{(ΔU)}&#39;      \mathbf{N}_{H_c} \mathbf{(ΔU)}  
                       + \mathbf{(R̂_u - U)}&#39; \mathbf{L}_{H_p} \mathbf{(R̂_u - U)} 
                       + C ϵ^2\]</p><p>in which the weight matrices are repeated <span>$H_p$</span> or <span>$H_c$</span> times:</p><p class="math-container">\[\begin{aligned}
    \mathbf{M}_{H_p} &amp;= \text{diag}\mathbf{(M,M,...,M)}     \\
    \mathbf{N}_{H_c} &amp;= \text{diag}\mathbf{(N,N,...,N)}     \\
    \mathbf{L}_{H_p} &amp;= \text{diag}\mathbf{(L,L,...,L)}     
\end{aligned}\]</p><p>The <span>$\mathbf{ΔU}$</span> vector includes the manipulated input increments <span>$\mathbf{Δu}(k+j) = \mathbf{u}(k+j) - \mathbf{u}(k+j-1)$</span> from <span>$j=0$</span> to <span>$H_c-1$</span>, the <span>$\mathbf{Ŷ}$</span> vector, the output predictions <span>$\mathbf{ŷ}(k+j)$</span> from <span>$j=1$</span> to <span>$H_p$</span>, and the <span>$\mathbf{U}$</span> vector, the manipulated inputs <span>$\mathbf{u}(k+j)$</span> from <span>$j=0$</span> to <span>$H_p-1$</span>. See Extended Help for a detailed nomenclature.</p><p>This method uses the default state estimator, a <a href="../state_estim/#ModelPredictiveControl.SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a> with default arguments.</p><p><strong>Arguments</strong></p><ul><li><code>model::LinModel</code> : model used for controller predictions and state estimations.</li><li><code>Hp=10+nk</code>: prediction horizon <span>$H_p$</span>, <code>nk</code> is the number of delays in <code>model</code>.</li><li><code>Hc=2</code> : control horizon <span>$H_c$</span>.</li><li><code>Mwt=fill(1.0,model.ny)</code> : main diagonal of <span>$\mathbf{M}$</span> weight matrix (vector).</li><li><code>Nwt=fill(0.1,model.nu)</code> : main diagonal of <span>$\mathbf{N}$</span> weight matrix (vector).</li><li><code>Lwt=fill(0.0,model.nu)</code> : main diagonal of <span>$\mathbf{L}$</span> weight matrix (vector).</li><li><code>Cwt=1e5</code> : slack variable weight <span>$C$</span> (scalar), use <code>Cwt=Inf</code> for hard constraints only.</li><li><code>optim=JuMP.Model(OSQP.MathOptInterfaceOSQP.Optimizer)</code> : quadratic optimizer used in the predictive controller, provided as a <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.Model"><code>JuMP.Model</code></a> (default to <a href="https://osqp.org/docs/parsers/jump.html"><code>OSQP.jl</code></a> optimizer).</li><li>additional keyword arguments are passed to <a href="../state_estim/#ModelPredictiveControl.SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a> constructor.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 4);

julia&gt; mpc = LinMPC(model, Mwt=[0, 1], Nwt=[0.5], Hp=30, Hc=1)
LinMPC controller with a sample time Ts = 4.0 s, OSQP optimizer, SteadyKalmanFilter estimator and:
 30 prediction steps Hp
  1 control steps Hc
  1 manipulated inputs u (0 integrating states)
  4 states x̂
  2 measured outputs ym (2 integrating states)
  0 unmeasured outputs yu
  0 measured disturbances d</code></pre><p><strong>Extended Help</strong></p><p>Manipulated inputs setpoints <span>$\mathbf{r_u}$</span> are not common but they can be interesting for over-actuated systems, when <code>nu &gt; ny</code> (e.g. prioritize solutions with lower economical  costs). The default <code>Lwt</code> value implies that this feature is disabled by default.</p><p>The objective function follows this nomenclature:</p><table><tr><th style="text-align: left">VARIABLE</th><th style="text-align: left">DESCRIPTION</th><th style="text-align: left">SIZE</th></tr><tr><td style="text-align: left"><span>$H_p$</span></td><td style="text-align: left">prediction horizon (integer)</td><td style="text-align: left"><code>()</code></td></tr><tr><td style="text-align: left"><span>$H_c$</span></td><td style="text-align: left">control horizon (integer)</td><td style="text-align: left"><code>()</code></td></tr><tr><td style="text-align: left"><span>$\mathbf{ΔU}$</span></td><td style="text-align: left">manipulated input increments over <span>$H_c$</span></td><td style="text-align: left"><code>(nu*Hc,)</code></td></tr><tr><td style="text-align: left"><span>$\mathbf{Ŷ}$</span></td><td style="text-align: left">predicted outputs over <span>$H_p$</span></td><td style="text-align: left"><code>(ny*Hp,)</code></td></tr><tr><td style="text-align: left"><span>$\mathbf{U}$</span></td><td style="text-align: left">manipulated inputs over <span>$H_p$</span></td><td style="text-align: left"><code>(nu*Hp,)</code></td></tr><tr><td style="text-align: left"><span>$\mathbf{R̂_y}$</span></td><td style="text-align: left">predicted output setpoints over <span>$H_p$</span></td><td style="text-align: left"><code>(ny*Hp,)</code></td></tr><tr><td style="text-align: left"><span>$\mathbf{R̂_u}$</span></td><td style="text-align: left">predicted manipulated input setpoints over <span>$H_p$</span></td><td style="text-align: left"><code>(nu*Hp,)</code></td></tr><tr><td style="text-align: left"><span>$\mathbf{M}$</span></td><td style="text-align: left">output setpoint tracking weights</td><td style="text-align: left"><code>(ny*Hp, ny*Hp)</code></td></tr><tr><td style="text-align: left"><span>$\mathbf{N}$</span></td><td style="text-align: left">manipulated input increment weights</td><td style="text-align: left"><code>(nu*Hc, nu*Hc)</code></td></tr><tr><td style="text-align: left"><span>$\mathbf{L}$</span></td><td style="text-align: left">manipulated input setpoint tracking weights</td><td style="text-align: left"><code>(nu*Hp, nu*Hp)</code></td></tr><tr><td style="text-align: left"><span>$C$</span></td><td style="text-align: left">slack variable weight</td><td style="text-align: left"><code>()</code></td></tr><tr><td style="text-align: left"><span>$ϵ$</span></td><td style="text-align: left">slack variable for constraint softening</td><td style="text-align: left"><code>()</code></td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/franckgaga/ModelPredictiveControl.jl/blob/6c28cfb718464c5ee95f21b36d34a9ed7112fc89/src/controller/linmpc.jl#L71-L149">source</a></section><section><div><pre><code class="language-julia hljs">LinMPC(estim::StateEstimator; &lt;keyword arguments&gt;)</code></pre><p>Use custom state estimator <code>estim</code> to construct <code>LinMPC</code>.</p><p><code>estim.model</code> must be a <a href="../sim_model/#ModelPredictiveControl.LinModel"><code>LinModel</code></a>. Else, a <a href="#ModelPredictiveControl.NonLinMPC"><code>NonLinMPC</code></a> is required. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; estim = KalmanFilter(LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 4), i_ym=[2]);

julia&gt; mpc = LinMPC(estim, Mwt=[0, 1], Nwt=[0.5], Hp=30, Hc=1)
LinMPC controller with a sample time Ts = 4.0 s, OSQP optimizer, KalmanFilter estimator and:
 30 prediction steps Hp
  1 control steps Hc
  1 manipulated inputs u (0 integrating states)
  3 states x̂
  1 measured outputs ym (1 integrating states)
  1 unmeasured outputs yu
  0 measured disturbances d</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/franckgaga/ModelPredictiveControl.jl/blob/6c28cfb718464c5ee95f21b36d34a9ed7112fc89/src/controller/linmpc.jl#L166-L187">source</a></section></article><h2 id="ExplicitMPC"><a class="docs-heading-anchor" href="#ExplicitMPC">ExplicitMPC</a><a id="ExplicitMPC-1"></a><a class="docs-heading-anchor-permalink" href="#ExplicitMPC" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.ExplicitMPC" href="#ModelPredictiveControl.ExplicitMPC"><code>ModelPredictiveControl.ExplicitMPC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ExplicitMPC(model::LinModel; &lt;keyword arguments&gt;)</code></pre><p>Construct an explicit linear predictive controller based on <a href="../sim_model/#ModelPredictiveControl.LinModel"><code>LinModel</code></a> <code>model</code>.</p><p>The controller minimizes the following objective function at each discrete time <span>$k$</span>:</p><p class="math-container">\[\min_{\mathbf{ΔU}}       \mathbf{(R̂_y - Ŷ)}&#39; \mathbf{M}_{H_p} \mathbf{(R̂_y - Ŷ)}   
                       + \mathbf{(ΔU)}&#39;      \mathbf{N}_{H_c} \mathbf{(ΔU)}  
                       + \mathbf{(R̂_u - U)}&#39; \mathbf{L}_{H_p} \mathbf{(R̂_u - U)} \]</p><p>See <a href="#ModelPredictiveControl.LinMPC"><code>LinMPC</code></a> for the variable definitions. This controller does not support constraints but the computational costs are extremely low (array division), therefore  suitable for applications that require small sample times. This method uses the default state estimator, a <a href="../state_estim/#ModelPredictiveControl.SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a> with default arguments.</p><p><strong>Arguments</strong></p><ul><li><code>model::LinModel</code> : model used for controller predictions and state estimations.</li><li><code>Hp=10+nk</code>: prediction horizon <span>$H_p$</span>, <code>nk</code> is the number of delays in <code>model</code>.</li><li><code>Hc=2</code> : control horizon <span>$H_c$</span>.</li><li><code>Mwt=fill(1.0,model.ny)</code> : main diagonal of <span>$\mathbf{M}$</span> weight matrix (vector).</li><li><code>Nwt=fill(0.1,model.nu)</code> : main diagonal of <span>$\mathbf{N}$</span> weight matrix (vector).</li><li><code>Lwt=fill(0.0,model.nu)</code> : main diagonal of <span>$\mathbf{L}$</span> weight matrix (vector).</li><li>additionnal keyword arguments are passed to <a href="../state_estim/#ModelPredictiveControl.SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a> constructor.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 4);

julia&gt; mpc = ExplicitMPC(model, Mwt=[0, 1], Nwt=[0.5], Hp=30, Hc=1)
ExplicitMPC controller with a sample time Ts = 4.0 s, SteadyKalmanFilter estimator and:
 30 prediction steps Hp
  1 control steps Hc
  1 manipulated inputs u (0 integrating states)
  4 states x̂
  2 measured outputs ym (2 integrating states)
  0 unmeasured outputs yu
  0 measured disturbances d</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/franckgaga/ModelPredictiveControl.jl/blob/6c28cfb718464c5ee95f21b36d34a9ed7112fc89/src/controller/explicitmpc.jl#L72-L113">source</a></section><section><div><pre><code class="language-julia hljs">ExplicitMPC(estim::StateEstimator; &lt;keyword arguments&gt;)</code></pre><p>Use custom state estimator <code>estim</code> to construct <code>ExplicitMPC</code>.</p><p><code>estim.model</code> must be a <a href="../sim_model/#ModelPredictiveControl.LinModel"><code>LinModel</code></a>. Else, a <a href="#ModelPredictiveControl.NonLinMPC"><code>NonLinMPC</code></a> is required. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; estim = KalmanFilter(LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 4), i_ym=[2]);

julia&gt; mpc = ExplicitMPC(estim, Mwt=[0, 1], Nwt=[0.5], Hp=30, Hc=1)
ExplicitMPC controller with a sample time Ts = 4.0 s, KalmanFilter estimator and:
 30 prediction steps Hp
  1 control steps Hc
  1 manipulated inputs u (0 integrating states)
  3 states x̂
  1 measured outputs ym (1 integrating states)
  1 unmeasured outputs yu
  0 measured disturbances d</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/franckgaga/ModelPredictiveControl.jl/blob/6c28cfb718464c5ee95f21b36d34a9ed7112fc89/src/controller/explicitmpc.jl#L127-L148">source</a></section></article><h2 id="NonLinMPC"><a class="docs-heading-anchor" href="#NonLinMPC">NonLinMPC</a><a id="NonLinMPC-1"></a><a class="docs-heading-anchor-permalink" href="#NonLinMPC" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.NonLinMPC" href="#ModelPredictiveControl.NonLinMPC"><code>ModelPredictiveControl.NonLinMPC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NonLinMPC(model::SimModel; &lt;keyword arguments&gt;)</code></pre><p>Construct a nonlinear predictive controller based on <a href="../sim_model/#ModelPredictiveControl.SimModel"><code>SimModel</code></a> <code>model</code>.</p><p>Both <a href="../sim_model/#ModelPredictiveControl.NonLinModel"><code>NonLinModel</code></a> and <a href="../sim_model/#ModelPredictiveControl.LinModel"><code>LinModel</code></a> are supported (see Extended Help). The  controller minimizes the following objective function at each discrete time <span>$k$</span>:</p><p class="math-container">\[\min_{\mathbf{ΔU}, ϵ}    \mathbf{(R̂_y - Ŷ)}&#39; \mathbf{M}_{H_p} \mathbf{(R̂_y - Ŷ)}   
                       + \mathbf{(ΔU)}&#39;      \mathbf{N}_{H_c} \mathbf{(ΔU)}  
                       + \mathbf{(R̂_u - U)}&#39; \mathbf{L}_{H_p} \mathbf{(R̂_u - U)} 
                       + C ϵ^2  +  E J_E(\mathbf{U}_E, \mathbf{Ŷ}_E, \mathbf{D̂}_E)\]</p><p>See <a href="#ModelPredictiveControl.LinMPC"><code>LinMPC</code></a> for the variable definitions. The custom economic function <span>$J_E$</span> can penalizes solutions with high economic costs. Setting all the weights to 0 except <span>$E$</span>  creates a pure economic model predictive controller (EMPC). The arguments of <span>$J_E$</span> are  the manipulated inputs, the predicted outputs and measured disturbances from <span>$k$</span> to  <span>$k+H_p$</span> inclusively:</p><p class="math-container">\[    \mathbf{U}_E = \begin{bmatrix} \mathbf{U}      \\ \mathbf{u}(k+H_p-1)   \end{bmatrix}  \text{,} \qquad
    \mathbf{Ŷ}_E = \begin{bmatrix} \mathbf{ŷ}(k)   \\ \mathbf{Ŷ}            \end{bmatrix}  \text{,} \qquad
    \mathbf{D̂}_E = \begin{bmatrix} \mathbf{d}(k)   \\ \mathbf{D̂}            \end{bmatrix}\]</p><p>since <span>$H_c ≤ H_p$</span> implies that <span>$\mathbf{Δu}(k+H_p) = \mathbf{0}$</span> or <span>$\mathbf{u}(k+H_p)= \mathbf{u}(k+H_p-1)$</span>. The vector <span>$\mathbf{D̂}$</span> includes the predicted measured disturbance over <span>$H_p$</span>.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Replace any of the 3 arguments with <code>_</code> if not needed (see <code>JE</code> default value below).</p></div></div><p>This method uses the default state estimator :</p><ul><li>if <code>model</code> is a <a href="../sim_model/#ModelPredictiveControl.LinModel"><code>LinModel</code></a>, a <a href="../state_estim/#ModelPredictiveControl.SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a> with default arguments;</li><li>else, an <a href="../state_estim/#ModelPredictiveControl.UnscentedKalmanFilter"><code>UnscentedKalmanFilter</code></a> with default arguments. </li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>See Extended Help if you get an error like:     <code>MethodError: no method matching Float64(::ForwardDiff.Dual)</code>.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>model::SimModel</code> : model used for controller predictions and state estimations.</li><li><code>Hp=nothing</code>: prediction horizon <span>$H_p$</span>, must be specified for <a href="../sim_model/#ModelPredictiveControl.NonLinModel"><code>NonLinModel</code></a>.</li><li><code>Hc=2</code> : control horizon <span>$H_c$</span>.</li><li><code>Mwt=fill(1.0,model.ny)</code> : main diagonal of <span>$\mathbf{M}$</span> weight matrix (vector).</li><li><code>Nwt=fill(0.1,model.nu)</code> : main diagonal of <span>$\mathbf{N}$</span> weight matrix (vector).</li><li><code>Lwt=fill(0.0,model.nu)</code> : main diagonal of <span>$\mathbf{L}$</span> weight matrix (vector).</li><li><code>Cwt=1e5</code> : slack variable weight <span>$C$</span> (scalar), use <code>Cwt=Inf</code> for hard constraints only.</li><li><code>Ewt=0.0</code> : economic costs weight <span>$E$</span> (scalar). </li><li><code>JE=(_,_,_)-&gt;0.0</code> : economic function <span>$J_E(\mathbf{U}_E, \mathbf{Ŷ}_E, \mathbf{D̂}_E)$</span>.</li><li><code>optim=JuMP.Model(Ipopt.Optimizer)</code> : nonlinear optimizer used in the predictive  controller, provided as a <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.Model"><code>JuMP.Model</code></a>  (default to <a href="https://github.com/jump-dev/Ipopt.jl"><code>Ipopt.jl</code></a> optimizer).</li><li>additionnal keyword arguments are passed to <a href="../state_estim/#ModelPredictiveControl.UnscentedKalmanFilter"><code>UnscentedKalmanFilter</code></a> constructor  (or <a href="../state_estim/#ModelPredictiveControl.SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a>, for <a href="../sim_model/#ModelPredictiveControl.LinModel"><code>LinModel</code></a>).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = NonLinModel((x,u,_)-&gt;0.5x+u, (x,_)-&gt;2x, 10.0, 1, 1, 1);

julia&gt; mpc = NonLinMPC(model, Hp=20, Hc=1, Cwt=1e6)
NonLinMPC controller with a sample time Ts = 10.0 s, Ipopt optimizer, UnscentedKalmanFilter estimator and:
 20 prediction steps Hp
  1 control steps Hc
  1 manipulated inputs u (0 integrating states)
  2 states x̂
  1 measured outputs ym (1 integrating states)
  0 unmeasured outputs yu
  0 measured disturbances d</code></pre><p><strong>Extended Help</strong></p><p><code>NonLinMPC</code> controllers based on <a href="../sim_model/#ModelPredictiveControl.LinModel"><code>LinModel</code></a> compute the predictions with matrix  algebra instead of a <code>for</code> loop. This feature can accelerate the optimization, especially for the constraint handling, and is not available in any other package, to my knowledge.</p><p>The optimizations rely on <a href="https://github.com/jump-dev/JuMP.jl"><code>JuMP.jl</code></a> automatic  differentiation (AD) to compute the objective and constraint derivatives. Optimizers  generally benefit from exact derivatives like AD. However, the <a href="../sim_model/#ModelPredictiveControl.NonLinModel"><code>NonLinModel</code></a> <code>f</code>  and <code>h</code> functions must be compatible with this feature. See <a href="https://jump.dev/JuMP.jl/stable/manual/nlp/#Automatic-differentiation">Automatic differentiation</a> for common mistakes when writing these functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/franckgaga/ModelPredictiveControl.jl/blob/6c28cfb718464c5ee95f21b36d34a9ed7112fc89/src/controller/nonlinmpc.jl#L75-L155">source</a></section><section><div><pre><code class="language-julia hljs">NonLinMPC(estim::StateEstimator; &lt;keyword arguments&gt;)</code></pre><p>Use custom state estimator <code>estim</code> to construct <code>NonLinMPC</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = NonLinModel((x,u,_)-&gt;0.5x+u, (x,_)-&gt;2x, 10.0, 1, 1, 1);

julia&gt; estim = UnscentedKalmanFilter(model, σQint_ym=[0.05]);

julia&gt; mpc = NonLinMPC(estim, Hp=20, Hc=1, Cwt=1e6)
NonLinMPC controller with a sample time Ts = 10.0 s, Ipopt optimizer, UnscentedKalmanFilter estimator and:
 20 prediction steps Hp
  1 control steps Hc
  1 manipulated inputs u (0 integrating states)
  2 states x̂
  1 measured outputs ym (1 integrating states)
  0 unmeasured outputs yu
  0 measured disturbances d</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/franckgaga/ModelPredictiveControl.jl/blob/6c28cfb718464c5ee95f21b36d34a9ed7112fc89/src/controller/nonlinmpc.jl#L191-L212">source</a></section></article><h2 id="Set-Constraint"><a class="docs-heading-anchor" href="#Set-Constraint">Set Constraint</a><a id="Set-Constraint-1"></a><a class="docs-heading-anchor-permalink" href="#Set-Constraint" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.setconstraint!" href="#ModelPredictiveControl.setconstraint!"><code>ModelPredictiveControl.setconstraint!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setconstraint!(mpc::PredictiveController; &lt;keyword arguments&gt;) -&gt; mpc</code></pre><p>Set the constraint parameters of <code>mpc</code> predictive controller.</p><p>The predictive controllers support both soft and hard constraints, defined by:</p><p class="math-container">\[\begin{alignat*}{3}
    \mathbf{u_{min}  - c_{u_{min}}}  ϵ ≤&amp;&amp;\       \mathbf{u}(k+j) &amp;≤ \mathbf{u_{max}  + c_{u_{max}}}  ϵ &amp;&amp;\qquad  j = 0, 1 ,..., H_p - 1 \\
    \mathbf{Δu_{min} - c_{Δu_{min}}} ϵ ≤&amp;&amp;\      \mathbf{Δu}(k+j) &amp;≤ \mathbf{Δu_{max} + c_{Δu_{max}}} ϵ &amp;&amp;\qquad  j = 0, 1 ,..., H_c - 1 \\
    \mathbf{y_{min}  - c_{y_{min}}}  ϵ ≤&amp;&amp;\       \mathbf{ŷ}(k+j) &amp;≤ \mathbf{y_{max}  + c_{y_{max}}}  ϵ &amp;&amp;\qquad  j = 1, 2 ,..., H_p     \\
    \mathbf{x̂_{min}  - c_{x̂_{min}}}  ϵ ≤&amp;&amp;\ \mathbf{x̂}_{k-1}(k+j) &amp;≤ \mathbf{x̂_{max}  + c_{x̂_{max}}}  ϵ &amp;&amp;\qquad  j = H_p
\end{alignat*}\]</p><p>and also <span>$ϵ ≥ 0$</span>. The last line is the terminal constraints applied on the states at the end of the horizon (see Extended Help). All the constraint parameters are vector. Use <code>±Inf</code> values when there is no bound. The constraint softness parameters <span>$\mathbf{c}$</span>, also called equal concern for relaxation, are non-negative values that specify the softness of the associated bound. Use <code>0.0</code> values for hard constraints. The output and terminal  constraints are all soft by default. See Extended Help for time-varying constraints.</p><p><strong>Arguments</strong></p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The default constraints are mentioned here for clarity but omitting a keyword argument  will not re-assign to its default value (defaults are set at construction only).</p></div></div><ul><li><code>mpc::PredictiveController</code> : predictive controller to set constraints.</li><li><code>umin  = fill(-Inf,nu)</code> : manipulated input lower bounds <span>$\mathbf{u_{min}}$</span>.</li><li><code>umax  = fill(+Inf,nu)</code> : manipulated input upper bounds <span>$\mathbf{u_{max}}$</span>.</li><li><code>Δumin = fill(-Inf,nu)</code> : manipulated input increment lower bounds <span>$\mathbf{Δu_{min}}$</span>.</li><li><code>Δumax = fill(+Inf,nu)</code> : manipulated input increment upper bounds <span>$\mathbf{Δu_{max}}$</span>.</li><li><code>ymin  = fill(-Inf,ny)</code> : predicted output lower bounds <span>$\mathbf{y_{min}}$</span>.</li><li><code>ymax  = fill(+Inf,ny)</code> : predicted output upper bounds <span>$\mathbf{y_{max}}$</span>.</li><li><code>x̂min  = fill(-Inf,nx̂)</code> : terminal constraint lower bounds <span>$\mathbf{x̂_{min}}$</span>.</li><li><code>x̂max  = fill(+Inf,nx̂)</code> : terminal constraint upper bounds <span>$\mathbf{x̂_{max}}$</span>.</li><li><code>c_umin  = fill(0.0,nu)</code> : <code>umin</code> softness weights <span>$\mathbf{c_{u_{min}}}$</span>.</li><li><code>c_umax  = fill(0.0,nu)</code> : <code>umax</code> softness weights <span>$\mathbf{c_{u_{max}}}$</span>.</li><li><code>c_Δumin = fill(0.0,nu)</code> : <code>Δumin</code> softness weights <span>$\mathbf{c_{Δu_{min}}}$</span>.</li><li><code>c_Δumax = fill(0.0,nu)</code> : <code>Δumax</code> softness weights <span>$\mathbf{c_{Δu_{max}}}$</span>.</li><li><code>c_ymin  = fill(1.0,ny)</code> : <code>ymin</code> softness weights <span>$\mathbf{c_{y_{min}}}$</span>.</li><li><code>c_ymax  = fill(1.0,ny)</code> : <code>ymax</code> softness weights <span>$\mathbf{c_{y_{max}}}$</span>.</li><li><code>c_x̂min  = fill(1.0,nx̂)</code> : <code>x̂min</code> softness weights <span>$\mathbf{c_{x̂_{min}}}$</span>.</li><li><code>c_x̂max  = fill(1.0,nx̂)</code> : <code>x̂max</code> softness weights <span>$\mathbf{c_{x̂_{max}}}$</span>.</li><li>all the keyword arguments above but with a capital letter, except for the terminal constraints, e.g. <code>Ymax</code> or <code>C_Δumin</code> : for time-varying constraints (see Extended Help).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mpc = LinMPC(setop!(LinModel(tf(3, [30, 1]), 4), uop=[50], yop=[25]));

julia&gt; mpc = setconstraint!(mpc, umin=[0], umax=[100], c_umin=[0.0], c_umax=[0.0]);

julia&gt; mpc = setconstraint!(mpc, Δumin=[-10], Δumax=[+10], c_Δumin=[1.0], c_Δumax=[1.0])
LinMPC controller with a sample time Ts = 4.0 s, OSQP optimizer, SteadyKalmanFilter estimator and:
 10 prediction steps Hp
  2 control steps Hc
  1 manipulated inputs u (0 integrating states)
  2 states x̂
  1 measured outputs ym (1 integrating states)
  0 unmeasured outputs yu
  0 measured disturbances d</code></pre><p><strong>Extended Help</strong></p><p>Terminal constraints provide closed-loop stability guarantees on the nominal plant model. They can render an unfeasible problem however. In practice, a sufficiently large prediction horizon <span>$H_p$</span> without terminal constraints is typically enough for stability. Note that terminal constraints are applied on the augmented state vector <span>$\mathbf{x̂}$</span> (see <a href="../state_estim/#ModelPredictiveControl.SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a> for details on augmentation).</p><p>For variable constraints, the bounds can be modified after calling <a href="#ModelPredictiveControl.moveinput!"><code>moveinput!</code></a>, that is, at runtime, but not the softness parameters <span>$\mathbf{c}$</span>. It is not possible to modify <code>±Inf</code> bounds at runtime.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>To keep a variable unconstrained while maintaining the ability to add a constraint later at runtime, set the bound to an absolute value sufficiently large when you create the controller (but different than <code>±Inf</code>).</p></div></div><p>It is also possible to specify time-varying constraints over <span>$H_p$</span> and <span>$H_c$</span> horizons.  In such a case, they are defined by:</p><p class="math-container">\[\begin{alignat*}{3}
    \mathbf{U_{min}  - C_{u_{min}}}  ϵ ≤&amp;&amp;\ \mathbf{U}  &amp;≤ \mathbf{U_{max}  + C_{u_{max}}}  ϵ \\
    \mathbf{ΔU_{min} - C_{Δu_{min}}} ϵ ≤&amp;&amp;\ \mathbf{ΔU} &amp;≤ \mathbf{ΔU_{max} + C_{Δu_{max}}} ϵ \\
    \mathbf{Y_{min}  - C_{y_{min}}}  ϵ ≤&amp;&amp;\ \mathbf{Ŷ}  &amp;≤ \mathbf{Y_{max}  + C_{y_{max}}}  ϵ
\end{alignat*}\]</p><p>For this, use the same keyword arguments as above but with a capital letter:</p><ul><li><code>Umin</code>  / <code>Umax</code>  / <code>C_umin</code>  / <code>C_umax</code>  : <span>$\mathbf{U}$</span> constraints <code>(nu*Hp,)</code>.</li><li><code>ΔUmin</code> / <code>ΔUmax</code> / <code>C_Δumin</code> / <code>C_Δumax</code> : <span>$\mathbf{ΔU}$</span> constraints <code>(nu*Hc,)</code>.</li><li><code>Ymin</code>  / <code>Ymax</code>  / <code>C_ymin</code>  / <code>C_ymax</code>  : <span>$\mathbf{Ŷ}$</span> constraints <code>(ny*Hp,)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/franckgaga/ModelPredictiveControl.jl/blob/6c28cfb718464c5ee95f21b36d34a9ed7112fc89/src/predictive_control.jl#L80-L172">source</a></section></article><h2 id="Move-Manipulated-Input-u"><a class="docs-heading-anchor" href="#Move-Manipulated-Input-u">Move Manipulated Input u</a><a id="Move-Manipulated-Input-u-1"></a><a class="docs-heading-anchor-permalink" href="#Move-Manipulated-Input-u" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.moveinput!" href="#ModelPredictiveControl.moveinput!"><code>ModelPredictiveControl.moveinput!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">moveinput!(mpc::PredictiveController, ry=mpc.estim.model.yop, d=[]; &lt;keyword args&gt;) -&gt; u</code></pre><p>Compute the optimal manipulated input value <code>u</code> for the current control period.</p><p>Solve the optimization problem of <code>mpc</code> <a href="#ModelPredictiveControl.PredictiveController"><code>PredictiveController</code></a> and return the results <span>$\mathbf{u}(k)$</span>. Following the receding horizon principle, the algorithm discards the optimal future manipulated inputs <span>$\mathbf{u}(k+1), \mathbf{u}(k+2), ...$</span> Note that the method mutates <code>mpc</code> internal data but it does not modifies <code>mpc.estim</code> states. Call <a href="../generic_func/#ModelPredictiveControl.updatestate!"><code>updatestate!(mpc, u, ym, d)</code></a> to update <code>mpc</code> state estimates.</p><p>Calling a <a href="#ModelPredictiveControl.PredictiveController"><code>PredictiveController</code></a> object calls this method.</p><p>See also <a href="#ModelPredictiveControl.LinMPC"><code>LinMPC</code></a>, <a href="#ModelPredictiveControl.ExplicitMPC"><code>ExplicitMPC</code></a>, <a href="#ModelPredictiveControl.NonLinMPC"><code>NonLinMPC</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>mpc::PredictiveController</code> : solve optimization problem of <code>mpc</code>.</li><li><code>ry=mpc.estim.model.yop</code> : current output setpoints <span>$\mathbf{r_y}(k)$</span>.</li><li><code>d=[]</code> : current measured disturbances <span>$\mathbf{d}(k)$</span>.</li><li><code>D̂=repeat(d, mpc.Hp)</code> : predicted measured disturbances <span>$\mathbf{D̂}$</span>, constant in the future by default or <span>$\mathbf{d̂}(k+j)=\mathbf{d}(k)$</span> for <span>$j=1$</span> to <span>$H_p$</span>.</li><li><code>R̂y=repeat(ry, mpc.Hp)</code> : predicted output setpoints <span>$\mathbf{R̂_y}$</span>, constant in the future by default or <span>$\mathbf{r̂_y}(k+j)=\mathbf{r_y}(k)$</span> for <span>$j=1$</span> to <span>$H_p$</span>.</li><li><code>R̂u=repeat(mpc.estim.model.uop, mpc.Hp)</code> : predicted manipulated input setpoints, constant in the future by default or <span>$\mathbf{r̂_u}(k+j)=\mathbf{u_{op}}$</span> for <span>$j=0$</span> to <span>$H_p-1$</span>.</li><li><code>ym=nothing</code> : current measured outputs <span>$\mathbf{y^m}(k)$</span>, only required if <code>mpc.estim</code>   is an <a href="../state_estim/#ModelPredictiveControl.InternalModel"><code>InternalModel</code></a>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mpc = LinMPC(LinModel(tf(5, [2, 1]), 3), Nwt=[0], Hp=1000, Hc=1);

julia&gt; ry = [5]; u = moveinput!(mpc, ry); round.(u, digits=3)
1-element Vector{Float64}:
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/franckgaga/ModelPredictiveControl.jl/blob/6c28cfb718464c5ee95f21b36d34a9ed7112fc89/src/predictive_control.jl#L347-L383">source</a></section></article><h2 id="Get-Additional-Information"><a class="docs-heading-anchor" href="#Get-Additional-Information">Get Additional Information</a><a id="Get-Additional-Information-1"></a><a class="docs-heading-anchor-permalink" href="#Get-Additional-Information" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.getinfo" href="#ModelPredictiveControl.getinfo"><code>ModelPredictiveControl.getinfo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getinfo(mpc::PredictiveController) -&gt; info</code></pre><p>Get additional information about <code>mpc</code> controller optimum to ease troubleshooting.</p><p>The function should be called after calling <a href="#ModelPredictiveControl.moveinput!"><code>moveinput!</code></a>. It returns the dictionary <code>info</code> with the following fields:</p><ul><li><code>:ΔU</code>  : optimal manipulated input increments over <code>Hc</code>, <span>$\mathbf{ΔU}$</span>.</li><li><code>:ϵ</code>   : optimal slack variable, <span>$ϵ$</span>.</li><li><code>:J</code>   : objective value optimum, <span>$J$</span>.</li><li><code>:U</code>   : optimal manipulated inputs over <code>Hp</code>, <span>$\mathbf{U}$</span>.</li><li><code>:u</code>   : current optimal manipulated input, <span>$\mathbf{u}(k)$</span>.</li><li><code>:d</code>   : current measured disturbance, <span>$\mathbf{d}(k)$</span>.</li><li><code>:D̂</code>   : predicted measured disturbances over <code>Hp</code>, <span>$\mathbf{D̂}$</span>.</li><li><code>:ŷ</code>   : current estimated output, <span>$\mathbf{ŷ}(k)$</span>.</li><li><code>:Ŷ</code>   : optimal predicted outputs over <code>Hp</code>, <span>$\mathbf{Ŷ}$</span>.</li><li><code>:x̂end</code>: optimal terminal states, <span>$\mathbf{x̂}_{k-1}(k+H_p)$</span>.</li><li><code>:Ŷs</code>  : predicted stochastic output over <code>Hp</code> of <a href="../state_estim/#ModelPredictiveControl.InternalModel"><code>InternalModel</code></a>, <span>$\mathbf{Ŷ_s}$</span>.</li><li><code>:R̂y</code>  : predicted output setpoint over <code>Hp</code>, <span>$\mathbf{R̂_y}$</span>.</li><li><code>:R̂u</code>  : predicted manipulated input setpoint over <code>Hp</code>, <span>$\mathbf{R̂_u}$</span>.</li></ul><p>For <a href="#ModelPredictiveControl.LinMPC"><code>LinMPC</code></a> and <a href="#ModelPredictiveControl.NonLinMPC"><code>NonLinMPC</code></a>, the field <code>:sol</code> also contains the optimizer solution summary that can be printed. Lastly, the optimal economic cost <code>:JE</code> is also available for <a href="#ModelPredictiveControl.NonLinMPC"><code>NonLinMPC</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mpc = LinMPC(LinModel(tf(5, [2, 1]), 3), Nwt=[0], Hp=1, Hc=1);

julia&gt; u = moveinput!(mpc, [10]);

julia&gt; round.(getinfo(mpc)[:Ŷ], digits=3)
1-element Vector{Float64}:
 10.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/franckgaga/ModelPredictiveControl.jl/blob/6c28cfb718464c5ee95f21b36d34a9ed7112fc89/src/predictive_control.jl#L402-L438">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../state_estim/">« State Estimators</a><a class="docs-footer-nextpage" href="../generic_func/">Generic Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Thursday 2 November 2023 22:00">Thursday 2 November 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
