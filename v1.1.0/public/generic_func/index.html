<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Generic Functions · ModelPredictiveControl.jl</title><meta name="title" content="Generic Functions · ModelPredictiveControl.jl"/><meta property="og:title" content="Generic Functions · ModelPredictiveControl.jl"/><meta property="twitter:title" content="Generic Functions · ModelPredictiveControl.jl"/><meta name="description" content="Documentation for ModelPredictiveControl.jl."/><meta property="og:description" content="Documentation for ModelPredictiveControl.jl."/><meta property="twitter:description" content="Documentation for ModelPredictiveControl.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="ModelPredictiveControl.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="ModelPredictiveControl.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelPredictiveControl.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/installation/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/linmpc/">Linear Design</a></li><li><a class="tocitem" href="../../manual/nonlinmpc/">Nonlinear Design</a></li><li><a class="tocitem" href="../../manual/mtk/">ModelingToolkit</a></li></ul></li></ul></li><li><span class="tocitem">Functions</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox" checked/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Public</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../sim_model/">Plant Models</a></li><li><a class="tocitem" href="../state_estim/">State Estimators</a></li><li><a class="tocitem" href="../predictive_control/">Predictive Controllers</a></li><li class="is-active"><a class="tocitem" href>Generic Functions</a><ul class="internal"><li><a class="tocitem" href="#Set-Constraint"><span>Set Constraint</span></a></li><li><a class="tocitem" href="#Evaluate-Output-y"><span>Evaluate Output y</span></a></li><li><a class="tocitem" href="#Change-State-x"><span>Change State x</span></a></li><li><a class="tocitem" href="#Set-Model-and-Weights"><span>Set Model and Weights</span></a></li><li><a class="tocitem" href="#Get-Additional-Information"><span>Get Additional Information</span></a></li><li><a class="tocitem" href="#Real-Time-Simulate-and-Control"><span>Real-Time Simulate and Control</span></a></li></ul></li><li><a class="tocitem" href="../plot_sim/">Simulations and Plots</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../internals/sim_model/">Plant Models</a></li><li><a class="tocitem" href="../../internals/state_estim/">State Estimators</a></li><li><a class="tocitem" href="../../internals/predictive_control/">Predictive Controllers</a></li></ul></li></ul></li><li><a class="tocitem" href="../../func_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functions</a></li><li><a class="is-disabled">Public</a></li><li class="is-active"><a href>Generic Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Generic Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaControl/ModelPredictiveControl.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/main/docs/src/public/generic_func.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions:-Generic-Functions"><a class="docs-heading-anchor" href="#Functions:-Generic-Functions">Functions: Generic Functions</a><a id="Functions:-Generic-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions:-Generic-Functions" title="Permalink"></a></h1><ul><li><a href="#Functions:-Generic-Functions">Functions: Generic Functions</a></li><li class="no-marker"><ul><li><a href="#Set-Constraint">Set Constraint</a></li><li><a href="#Evaluate-Output-y">Evaluate Output y</a></li><li><a href="#Change-State-x">Change State x</a></li><li><a href="#Set-Model-and-Weights">Set Model and Weights</a></li><li><a href="#Get-Additional-Information">Get Additional Information</a></li><li><a href="#Real-Time-Simulate-and-Control">Real-Time Simulate and Control</a></li></ul></li></ul><p>This page contains the documentation of functions that are generic to <a href="../sim_model/#SimModel"><code>SimModel</code></a>, <a href="../state_estim/#StateEstimator"><code>StateEstimator</code></a> and <a href="../predictive_control/#PredictiveController"><code>PredictiveController</code></a> types.</p><h2 id="Set-Constraint"><a class="docs-heading-anchor" href="#Set-Constraint">Set Constraint</a><a id="Set-Constraint-1"></a><a class="docs-heading-anchor-permalink" href="#Set-Constraint" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.setconstraint!" href="#ModelPredictiveControl.setconstraint!"><code>ModelPredictiveControl.setconstraint!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setconstraint!(estim::MovingHorizonEstimator; &lt;keyword arguments&gt;) -&gt; estim</code></pre><p>Set the bound constraint parameters of the <a href="../state_estim/#MovingHorizonEstimator"><code>MovingHorizonEstimator</code></a> <code>estim</code>.</p><p>It supports both soft and hard constraints on the estimated state <span>$\mathbf{x̂}$</span>, process  noise <span>$\mathbf{ŵ}$</span> and sensor noise <span>$\mathbf{v̂}$</span>:</p><p class="math-container">\[\begin{alignat*}{3}
    \mathbf{x̂_{min} - c_{x̂_{min}}} ϵ ≤&amp;&amp;\   \mathbf{x̂}_k(k-j+p) &amp;≤ \mathbf{x̂_{max} + c_{x̂_{max}}} ϵ &amp;&amp;\qquad  j = N_k, N_k - 1, ... , 0    \\
    \mathbf{ŵ_{min} - c_{ŵ_{min}}} ϵ ≤&amp;&amp;\     \mathbf{ŵ}(k-j+p) &amp;≤ \mathbf{ŵ_{max} + c_{ŵ_{max}}} ϵ &amp;&amp;\qquad  j = N_k, N_k - 1, ... , 1    \\
    \mathbf{v̂_{min} - c_{v̂_{min}}} ϵ ≤&amp;&amp;\     \mathbf{v̂}(k-j+1) &amp;≤ \mathbf{v̂_{max} + c_{v̂_{max}}} ϵ &amp;&amp;\qquad  j = N_k, N_k - 1, ... , 1
\end{alignat*}\]</p><p>and also <span>$ϵ ≥ 0$</span>. All the constraint parameters are vector. Use <code>±Inf</code> values when there is no bound. The constraint softness parameters <span>$\mathbf{c}$</span>, also called equal concern for relaxation, are non-negative values that specify the softness of the associated bound. Use <code>0.0</code> values for hard constraints (default for all of them). Notice that constraining the estimated sensor noises is equivalent to bounding the innovation term, since  <span>$\mathbf{v̂}(k) = \mathbf{y^m}(k) - \mathbf{ŷ^m}(k)$</span>. See Extended Help for details on the constant <span>$p$</span>, on model augmentation and on time-varying constraints.</p><p><strong>Arguments</strong></p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>All the keyword arguments have non-Unicode alternatives e.g. <em><code>xhatmin</code></em> or <em><code>Vhatmax</code></em>. </p><p>The default constraints are mentioned here for clarity but omitting a keyword argument  will not re-assign to its default value (defaults are set at construction only).</p></div></div><ul><li><code>estim::MovingHorizonEstimator</code> : moving horizon estimator to set constraints</li><li><code>x̂min=fill(-Inf,nx̂)</code> / <code>x̂max=fill(+Inf,nx̂)</code> : estimated state bound <span>$\mathbf{x̂_{min/max}}$</span></li><li><code>ŵmin=fill(-Inf,nx̂)</code> / <code>ŵmax=fill(+Inf,nx̂)</code> : estimated process noise bound <span>$\mathbf{ŵ_{min/max}}$</span></li><li><code>v̂min=fill(-Inf,nym)</code> / <code>v̂max=fill(+Inf,nym)</code> : estimated sensor noise bound <span>$\mathbf{v̂_{min/max}}$</span></li><li><code>c_x̂min=fill(0.0,nx̂)</code> / <code>c_x̂max=fill(0.0,nx̂)</code> : <code>x̂min</code> / <code>x̂max</code> softness weight <span>$\mathbf{c_{x̂_{min/max}}}$</span></li><li><code>c_ŵmin=fill(0.0,nx̂)</code> / <code>c_ŵmax=fill(0.0,nx̂)</code> : <code>ŵmin</code> / <code>ŵmax</code> softness weight <span>$\mathbf{c_{ŵ_{min/max}}}$</span></li><li><code>c_v̂min=fill(0.0,nym)</code> / <code>c_v̂max=fill(0.0,nym)</code> : <code>v̂min</code> / <code>v̂max</code> softness weight <span>$\mathbf{c_{v̂_{min/max}}}$</span></li><li>all the keyword arguments above but with a first capital letter, e.g. <code>X̂max</code> or <code>C_ŵmax</code>:  for time-varying constraints (see Extended Help)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; estim = MovingHorizonEstimator(LinModel(ss(0.5,1,1,0,1)), He=3);

julia&gt; estim = setconstraint!(estim, x̂min=[-50, -50], x̂max=[50, 50])
MovingHorizonEstimator estimator with a sample time Ts = 1.0 s, OSQP optimizer, LinModel and:
 3 estimation steps He
 0 slack variable ϵ (estimation constraints)
 1 manipulated inputs u (0 integrating states)
 2 estimated states x̂
 1 measured outputs ym (1 integrating states)
 0 unmeasured outputs yu
 0 measured disturbances d</code></pre><p><strong>Extended Help</strong></p><details class="admonition is-details"><summary class="admonition-header">Extended Help</summary><div class="admonition-body"><p>The constant <span>$p=0$</span> if <code>estim.direct==true</code> (current form), else <span>$p=1$</span> (prediction form). Note that the state <span>$\mathbf{x̂}$</span> and process noise <span>$\mathbf{ŵ}$</span> constraints are applied on the augmented model, detailed in <a href="../state_estim/#SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a> Extended Help. For variable constraints, the bounds can be modified after calling <a href="#ModelPredictiveControl.updatestate!"><code>updatestate!</code></a>, that is, at runtime, except for <code>±Inf</code> bounds. Time-varying constraints over the estimation horizon <span>$H_e$</span> are also possible, mathematically defined as:</p><p class="math-container">\[\begin{alignat*}{3}
    \mathbf{X̂_{min} - C_{x̂_{min}}} ϵ ≤&amp;&amp;\ \mathbf{X̂} &amp;≤ \mathbf{X̂_{max} + C_{x̂_{max}}} ϵ \\
    \mathbf{Ŵ_{min} - C_{ŵ_{min}}} ϵ ≤&amp;&amp;\ \mathbf{Ŵ} &amp;≤ \mathbf{Ŵ_{max} + C_{ŵ_{max}}} ϵ \\
    \mathbf{V̂_{min} - C_{v̂_{min}}} ϵ ≤&amp;&amp;\ \mathbf{V̂} &amp;≤ \mathbf{V̂_{max} + C_{v̂_{max}}} ϵ
\end{alignat*}\]</p><p>For this, use the same keyword arguments as above but with a first capital letter:</p><ul><li><code>X̂min</code> / <code>X̂max</code> / <code>C_x̂min</code> / <code>C_x̂max</code> : <span>$\mathbf{X̂}$</span> constraints <code>(nx̂*(He+1),)</code>.</li><li><code>Ŵmin</code> / <code>Ŵmax</code> / <code>C_ŵmin</code> / <code>C_ŵmax</code> : <span>$\mathbf{Ŵ}$</span> constraints <code>(nx̂*He,)</code>.</li><li><code>V̂min</code> / <code>V̂max</code> / <code>C_v̂min</code> / <code>C_v̂max</code> : <span>$\mathbf{V̂}$</span> constraints <code>(nym*He,)</code>.</li></ul></div></details></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/bbb131b89316cac00507e1bb972717f56c825fb3/src/estimator/mhe/construct.jl#L421-L494">source</a></section><section><div><pre><code class="language-julia hljs">setconstraint!(mpc::PredictiveController; &lt;keyword arguments&gt;) -&gt; mpc</code></pre><p>Set the bound constraint parameters of the <a href="../predictive_control/#PredictiveController"><code>PredictiveController</code></a> <code>mpc</code>.</p><p>The predictive controllers support both soft and hard constraints, defined by:</p><p class="math-container">\[\begin{alignat*}{3}
    \mathbf{u_{min}  - c_{u_{min}}}  ϵ ≤&amp;&amp;\       \mathbf{u}(k+j) &amp;≤ \mathbf{u_{max}  + c_{u_{max}}}  ϵ &amp;&amp;\qquad  j = 0, 1 ,..., H_p - 1 \\
    \mathbf{Δu_{min} - c_{Δu_{min}}} ϵ ≤&amp;&amp;\      \mathbf{Δu}(k+j) &amp;≤ \mathbf{Δu_{max} + c_{Δu_{max}}} ϵ &amp;&amp;\qquad  j = 0, 1 ,..., H_c - 1 \\
    \mathbf{y_{min}  - c_{y_{min}}}  ϵ ≤&amp;&amp;\       \mathbf{ŷ}(k+j) &amp;≤ \mathbf{y_{max}  + c_{y_{max}}}  ϵ &amp;&amp;\qquad  j = 1, 2 ,..., H_p     \\
    \mathbf{x̂_{min}  - c_{x̂_{min}}}  ϵ ≤&amp;&amp;\     \mathbf{x̂}_i(k+j) &amp;≤ \mathbf{x̂_{max}  + c_{x̂_{max}}}  ϵ &amp;&amp;\qquad  j = H_p
\end{alignat*}\]</p><p>and also <span>$ϵ ≥ 0$</span>. The last line is the terminal constraints applied on the states at the end of the horizon (see Extended Help). See <a href="../state_estim/#MovingHorizonEstimator"><code>MovingHorizonEstimator</code></a> constraints for details on bounds and softness parameters <span>$\mathbf{c}$</span>. The output and terminal  constraints are all soft by default. See Extended Help for time-varying constraints.</p><p><strong>Arguments</strong></p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The keyword arguments <code>Δumin</code>, <code>Δumax</code>, <code>c_Δumin</code>, <code>c_Δumax</code>, <code>x̂min</code>, <code>x̂max</code>, <code>c_x̂min</code>, <code>c_x̂max</code> and their capital letter versions have non-Unicode alternatives e.g.  <em><code>Deltaumin</code></em>, <em><code>xhatmax</code></em> and <em><code>C_Deltaumin</code></em></p><p>The default constraints are mentioned here for clarity but omitting a keyword argument  will not re-assign to its default value (defaults are set at construction only).</p></div></div><ul><li><code>mpc::PredictiveController</code> : predictive controller to set constraints</li><li><code>umin=fill(-Inf,nu)</code> / <code>umax=fill(+Inf,nu)</code> : manipulated input bound <span>$\mathbf{u_{min/max}}$</span></li><li><code>Δumin=fill(-Inf,nu)</code> / <code>Δumax=fill(+Inf,nu)</code> : manipulated input increment bound <span>$\mathbf{Δu_{min/max}}$</span></li><li><code>ymin=fill(-Inf,ny)</code> / <code>ymax=fill(+Inf,ny)</code> : predicted output bound <span>$\mathbf{y_{min/max}}$</span></li><li><code>x̂min=fill(-Inf,nx̂)</code> / <code>x̂max=fill(+Inf,nx̂)</code> : terminal constraint bound <span>$\mathbf{x̂_{min/max}}$</span></li><li><code>c_umin=fill(0.0,nu)</code> / <code>c_umax=fill(0.0,nu)</code> : <code>umin</code> / <code>umax</code> softness weight <span>$\mathbf{c_{u_{min/max}}}$</span></li><li><code>c_Δumin=fill(0.0,nu)</code> / <code>c_Δumax=fill(0.0,nu)</code> : <code>Δumin</code> / <code>Δumax</code> softness weight <span>$\mathbf{c_{Δu_{min/max}}}$</span></li><li><code>c_ymin=fill(1.0,ny)</code> / <code>c_ymax=fill(1.0,ny)</code> : <code>ymin</code> / <code>ymax</code> softness weight <span>$\mathbf{c_{y_{min/max}}}$</span></li><li><code>c_x̂min=fill(1.0,nx̂)</code> / <code>c_x̂max=fill(1.0,nx̂)</code> : <code>x̂min</code> / <code>x̂max</code> softness weight <span>$\mathbf{c_{x̂_{min/max}}}$</span></li><li>all the keyword arguments above but with a first capital letter, except for the terminal constraints, e.g. <code>Ymax</code> or <code>C_Δumin</code>: for time-varying constraints (see Extended Help)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mpc = LinMPC(setop!(LinModel(tf(3, [30, 1]), 4), uop=[50], yop=[25]));

julia&gt; mpc = setconstraint!(mpc, umin=[0], umax=[100], Δumin=[-10], Δumax=[+10])
LinMPC controller with a sample time Ts = 4.0 s, OSQP optimizer, SteadyKalmanFilter estimator and:
 10 prediction steps Hp
  2 control steps Hc
  1 slack variable ϵ (control constraints)
  1 manipulated inputs u (0 integrating states)
  2 estimated states x̂
  1 measured outputs ym (1 integrating states)
  0 unmeasured outputs yu
  0 measured disturbances d</code></pre><p><strong>Extended Help</strong></p><details class="admonition is-details"><summary class="admonition-header">Extended Help</summary><div class="admonition-body"><p>Terminal constraints provide closed-loop stability guarantees on the nominal plant model. They can render an unfeasible problem however. In practice, a sufficiently large prediction horizon <span>$H_p$</span> without terminal constraints is typically enough for  stability. If <code>mpc.estim.direct==true</code>, the estimator computes the states at <span>$i = k$</span>  (the current time step), otherwise at <span>$i = k - 1$</span>. Note that terminal constraints are applied on the augmented state vector <span>$\mathbf{x̂}$</span> (see <a href="../state_estim/#SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a> for details on augmentation).</p><p>For variable constraints, the bounds can be modified after calling <a href="../predictive_control/#ModelPredictiveControl.moveinput!"><code>moveinput!</code></a>, that is, at runtime, but not the softness parameters <span>$\mathbf{c}$</span>. It is not possible to modify <code>±Inf</code> bounds at runtime.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>To keep a variable unconstrained while maintaining the ability to add a constraint later at runtime, set the bound to an absolute value sufficiently large when you create the controller (but different than <code>±Inf</code>).</p></div></div><p>It is also possible to specify time-varying constraints over <span>$H_p$</span> and <span>$H_c$</span>  horizons. In such a case, they are defined by:</p><p class="math-container">\[\begin{alignat*}{3}
    \mathbf{U_{min}  - C_{u_{min}}}  ϵ ≤&amp;&amp;\ \mathbf{U}  &amp;≤ \mathbf{U_{max}  + C_{u_{max}}}  ϵ \\
    \mathbf{ΔU_{min} - C_{Δu_{min}}} ϵ ≤&amp;&amp;\ \mathbf{ΔU} &amp;≤ \mathbf{ΔU_{max} + C_{Δu_{max}}} ϵ \\
    \mathbf{Y_{min}  - C_{y_{min}}}  ϵ ≤&amp;&amp;\ \mathbf{Ŷ}  &amp;≤ \mathbf{Y_{max}  + C_{y_{max}}}  ϵ
\end{alignat*}\]</p><p>For this, use the same keyword arguments as above but with a first capital letter:</p><ul><li><code>Umin</code>  / <code>Umax</code>  / <code>C_umin</code>  / <code>C_umax</code>  : <span>$\mathbf{U}$</span> constraints <code>(nu*Hp,)</code>.</li><li><code>ΔUmin</code> / <code>ΔUmax</code> / <code>C_Δumin</code> / <code>C_Δumax</code> : <span>$\mathbf{ΔU}$</span> constraints <code>(nu*Hc,)</code>.</li><li><code>Ymin</code>  / <code>Ymax</code>  / <code>C_ymin</code>  / <code>C_ymax</code>  : <span>$\mathbf{Ŷ}$</span> constraints <code>(ny*Hp,)</code>.</li></ul></div></details></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/bbb131b89316cac00507e1bb972717f56c825fb3/src/controller/construct.jl#L38-L126">source</a></section></article><h2 id="Evaluate-Output-y"><a class="docs-heading-anchor" href="#Evaluate-Output-y">Evaluate Output y</a><a id="Evaluate-Output-y-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluate-Output-y" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.evaloutput" href="#ModelPredictiveControl.evaloutput"><code>ModelPredictiveControl.evaloutput</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaloutput(model::SimModel, d=[]) -&gt; y</code></pre><p>Evaluate <code>SimModel</code> outputs <code>y</code> from <code>model.x0</code> states and measured disturbances <code>d</code>.</p><p>It returns <code>model</code> output at the current time step <span>$\mathbf{y}(k)$</span>. Calling a  <a href="../sim_model/#SimModel"><code>SimModel</code></a> object calls this <code>evaloutput</code> method.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = setop!(LinModel(tf(2, [10, 1]), 5.0), yop=[20]);

julia&gt; y = evaloutput(model)
1-element Vector{Float64}:
 20.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/bbb131b89316cac00507e1bb972717f56c825fb3/src/sim_model.jl#L262-L278">source</a></section><section><div><pre><code class="language-julia hljs">evaloutput(estim::StateEstimator, d=[]) -&gt; ŷ</code></pre><p>Evaluate <code>StateEstimator</code> outputs <code>ŷ</code> from <code>estim.x̂0</code> states and disturbances <code>d</code>.</p><p>It returns <code>estim</code> output at the current time step <span>$\mathbf{ŷ}(k)$</span>. If <code>estim.direct</code> is <code>true</code>, the method <a href="#ModelPredictiveControl.preparestate!"><code>preparestate!</code></a> should be called beforehand to correct the state estimate. </p><p>Calling a <a href="../state_estim/#StateEstimator"><code>StateEstimator</code></a> object calls this <code>evaloutput</code> method.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; kf = SteadyKalmanFilter(setop!(LinModel(tf(2, [10, 1]), 5), yop=[20]), direct=false);

julia&gt; ŷ = evaloutput(kf)
1-element Vector{Float64}:
 20.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/bbb131b89316cac00507e1bb972717f56c825fb3/src/estimator/execute.jl#L169-L188">source</a></section></article><h2 id="Change-State-x"><a class="docs-heading-anchor" href="#Change-State-x">Change State x</a><a id="Change-State-x-1"></a><a class="docs-heading-anchor-permalink" href="#Change-State-x" title="Permalink"></a></h2><h3 id="Prepare-State-x"><a class="docs-heading-anchor" href="#Prepare-State-x">Prepare State x</a><a id="Prepare-State-x-1"></a><a class="docs-heading-anchor-permalink" href="#Prepare-State-x" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.preparestate!" href="#ModelPredictiveControl.preparestate!"><code>ModelPredictiveControl.preparestate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">preparestate!(model::SimModel, _ , _ ) -&gt; x</code></pre><p>Do nothing for <a href="../sim_model/#SimModel"><code>SimModel</code></a> and return the current model state <span>$\mathbf{x}(k)$</span>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/bbb131b89316cac00507e1bb972717f56c825fb3/src/sim_model.jl#L222-L226">source</a></section><section><div><pre><code class="language-julia hljs">preparestate!(estim::StateEstimator, ym, d=estim.model.dop) -&gt; x̂</code></pre><p>Prepare <code>estim.x̂0</code> estimate with meas. outputs <code>ym</code> and dist. <code>d</code> for the current time step.</p><p>This function should be called at the beginning of each discrete time step. Its behavior depends if <code>estim</code> is a <a href="../state_estim/#StateEstimator"><code>StateEstimator</code></a> in the current/filter (1.) or  delayed/predictor (2.) formulation:</p><ol><li>If <code>estim.direct</code> is <code>true</code>, it removes the operating points with <a href="../../internals/state_estim/#ModelPredictiveControl.remove_op!"><code>remove_op!</code></a>, calls <a href="../../internals/state_estim/#ModelPredictiveControl.correct_estimate!"><code>correct_estimate!</code></a>, and returns the corrected state estimate  <span>$\mathbf{x̂}_k(k)$</span>.</li><li>Else, it does nothing and returns the current best estimate <span>$\mathbf{x̂}_{k-1}(k)$</span>.</li></ol><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; estim2 = SteadyKalmanFilter(LinModel(ss(0.1, 0.5, 1, 0, 4)), nint_ym=0, direct=true);

julia&gt; x̂ = round.(preparestate!(estim2, [1]), digits=3)
1-element Vector{Float64}:
 0.01

julia&gt; estim1 = SteadyKalmanFilter(LinModel(ss(0.1, 0.5, 1, 0, 4)), nint_ym=0, direct=false);

julia&gt; x̂ = preparestate!(estim1, [1])
1-element Vector{Float64}:
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/bbb131b89316cac00507e1bb972717f56c825fb3/src/estimator/execute.jl#L205-L233">source</a></section><section><div><pre><code class="language-julia hljs">preparestate!(mpc::PredictiveController, ym, d=[]) -&gt; x̂</code></pre><p>Call <a href="#ModelPredictiveControl.preparestate!"><code>preparestate!</code></a> on <code>mpc.estim</code> <a href="../state_estim/#StateEstimator"><code>StateEstimator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/bbb131b89316cac00507e1bb972717f56c825fb3/src/controller/execute.jl#L500-L504">source</a></section></article><h3 id="Update-State-x"><a class="docs-heading-anchor" href="#Update-State-x">Update State x</a><a id="Update-State-x-1"></a><a class="docs-heading-anchor-permalink" href="#Update-State-x" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.updatestate!" href="#ModelPredictiveControl.updatestate!"><code>ModelPredictiveControl.updatestate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">updatestate!(model::SimModel, u, d=[]) -&gt; xnext</code></pre><p>Update <code>model.x0</code> states with current inputs <code>u</code> and meas. dist. <code>d</code> for the next time step.</p><p>The method computes and returns the model state for the next time step <span>$\mathbf{x}(k+1)$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = LinModel(ss(1.0, 1.0, 1.0, 0, 1.0));

julia&gt; x = updatestate!(model, [1])
1-element Vector{Float64}:
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/bbb131b89316cac00507e1bb972717f56c825fb3/src/sim_model.jl#L233-L248">source</a></section><section><div><pre><code class="language-julia hljs">updatestate!(estim::StateEstimator, u, ym, d=[]) -&gt; x̂next</code></pre><p>Update <code>estim.x̂0</code> estimate with current inputs <code>u</code>, measured outputs <code>ym</code> and dist. <code>d</code>. </p><p>This function should be called at the end of each discrete time step. It removes the  operating points with <a href="../../internals/state_estim/#ModelPredictiveControl.remove_op!"><code>remove_op!</code></a>, calls <a href="../../internals/state_estim/#ModelPredictiveControl.update_estimate!"><code>update_estimate!</code></a> and returns the state estimate for the next time step <span>$\mathbf{x̂}_k(k+1)$</span>. The method <a href="#ModelPredictiveControl.preparestate!"><code>preparestate!</code></a> should be called prior to this one to correct the estimate when applicable (if <code>estim.direct == true</code>). Note that the <a href="../state_estim/#MovingHorizonEstimator"><code>MovingHorizonEstimator</code></a> with the default <code>direct=true</code> option is not able to estimate <span>$\mathbf{x̂}_k(k+1)$</span>, the returned value is therefore the current corrected state <span>$\mathbf{x̂}_k(k)$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; kf = SteadyKalmanFilter(LinModel(ss(0.1, 0.5, 1, 0, 4.0))); u = [1]; ym = [0];

julia&gt; preparestate!(kf, ym);

julia&gt; x̂ = updatestate!(kf, u, ym) # x̂[2] is the integrator state (nint_ym argument)
2-element Vector{Float64}:
 0.5
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/bbb131b89316cac00507e1bb972717f56c825fb3/src/estimator/execute.jl#L246-L270">source</a></section><section><div><pre><code class="language-julia hljs">updatestate!(mpc::PredictiveController, u, ym, d=[]) -&gt; x̂next</code></pre><p>Call <a href="#ModelPredictiveControl.updatestate!"><code>updatestate!</code></a> on <code>mpc.estim</code> <a href="../state_estim/#StateEstimator"><code>StateEstimator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/bbb131b89316cac00507e1bb972717f56c825fb3/src/controller/execute.jl#L527-L531">source</a></section></article><h3 id="Init-State-x"><a class="docs-heading-anchor" href="#Init-State-x">Init State x</a><a id="Init-State-x-1"></a><a class="docs-heading-anchor-permalink" href="#Init-State-x" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.initstate!" href="#ModelPredictiveControl.initstate!"><code>ModelPredictiveControl.initstate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initstate!(model::SimModel, u, d=[]) -&gt; x</code></pre><p>Init <code>model.x0</code> with manipulated inputs <code>u</code> and meas. dist. <code>d</code> steady-state.</p><p>The method tries to initialize the model state <span>$\mathbf{x}$</span> at steady-state. It removes the operating points on <code>u</code> and <code>d</code> and calls <a href="../../internals/sim_model/#ModelPredictiveControl.steadystate!"><code>steadystate!</code></a>:</p><ul><li>If <code>model</code> is a <a href="../sim_model/#LinModel"><code>LinModel</code></a>, the method computes the steady-state of current inputs <code>u</code> and measured disturbances <code>d</code>.</li><li>Else, <code>model.x0</code> is left unchanged. Use <a href="#ModelPredictiveControl.setstate!"><code>setstate!</code></a> to manually modify it.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = LinModel(tf(6, [10, 1]), 2.0);

julia&gt; u = [1]; x = initstate!(model, u); y = round.(evaloutput(model), digits=3)
1-element Vector{Float64}:
 6.0
 
julia&gt; x ≈ updatestate!(model, u)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/bbb131b89316cac00507e1bb972717f56c825fb3/src/sim_model.jl#L187-L210">source</a></section><section><div><pre><code class="language-julia hljs">initstate!(estim::StateEstimator, u, ym, d=[]) -&gt; x̂</code></pre><p>Init <code>estim.x̂0</code> states from current inputs <code>u</code>, measured outputs <code>ym</code> and disturbances <code>d</code>.</p><p>The method tries to find a good steady-state for the initial estimate <span>$\mathbf{x̂}$</span>. It stores <code>u - estim.model.uop</code> at <code>estim.lastu0</code> and removes the operating points with  <a href="../../internals/state_estim/#ModelPredictiveControl.remove_op!"><code>remove_op!</code></a>, and call <a href="../../internals/state_estim/#ModelPredictiveControl.init_estimate!"><code>init_estimate!</code></a>:</p><ul><li>If <code>estim.model</code> is a <a href="../sim_model/#LinModel"><code>LinModel</code></a>, it finds the steady-state of the augmented model using <code>u</code> and <code>d</code> arguments, and uses the <code>ym</code> argument to enforce that  <span>$\mathbf{ŷ^m}(0) = \mathbf{y^m}(0)$</span>. For control applications, this solution produces a bumpless manual to automatic transfer. See <a href="../../internals/state_estim/#ModelPredictiveControl.init_estimate!"><code>init_estimate!</code></a> for details.</li><li>Else, <code>estim.x̂0</code> is left unchanged. Use <a href="#ModelPredictiveControl.setstate!"><code>setstate!</code></a> to manually modify it.</li></ul><p>If applicable, it also sets the error covariance <code>estim.P̂</code> to <code>estim.P̂_0</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; estim = SteadyKalmanFilter(LinModel(tf(3, [10, 1]), 0.5), nint_ym=[2], direct=false);

julia&gt; u = [1]; y = [3 - 0.1]; x̂ = round.(initstate!(estim, u, y), digits=3)
3-element Vector{Float64}:
  5.0
  0.0
 -0.1

julia&gt; x̂ ≈ updatestate!(estim, u, y)
true

julia&gt; evaloutput(estim) ≈ y
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/bbb131b89316cac00507e1bb972717f56c825fb3/src/estimator/execute.jl#L85-L118">source</a></section><section><div><pre><code class="language-julia hljs">initstate!(mpc::PredictiveController, u, ym, d=[]) -&gt; x̂</code></pre><p>Init the states of <code>mpc.estim</code> <a href="../state_estim/#StateEstimator"><code>StateEstimator</code></a> and warm start <code>mpc.ΔŨ</code> at zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/bbb131b89316cac00507e1bb972717f56c825fb3/src/controller/execute.jl#L1-L5">source</a></section></article><h3 id="Set-State-x"><a class="docs-heading-anchor" href="#Set-State-x">Set State x</a><a id="Set-State-x-1"></a><a class="docs-heading-anchor-permalink" href="#Set-State-x" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.setstate!" href="#ModelPredictiveControl.setstate!"><code>ModelPredictiveControl.setstate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setstate!(model::SimModel, x) -&gt; model</code></pre><p>Set <code>model.x0</code> to <code>x - model.xop</code> from the argument <code>x</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/bbb131b89316cac00507e1bb972717f56c825fb3/src/sim_model.jl#L162-L166">source</a></section><section><div><pre><code class="language-julia hljs">setstate!(estim::StateEstimator, x̂) -&gt; estim</code></pre><p>Set <code>estim.x̂0</code> to <code>x̂ - estim.x̂op</code> from the argument <code>x̂</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/bbb131b89316cac00507e1bb972717f56c825fb3/src/estimator/execute.jl#L312-L316">source</a></section><section><div><pre><code class="language-julia hljs">setstate!(mpc::PredictiveController, x̂) -&gt; mpc</code></pre><p>Set <code>mpc.estim.x̂0</code> to <code>x̂ - estim.x̂op</code> from the argument <code>x̂</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/bbb131b89316cac00507e1bb972717f56c825fb3/src/controller/execute.jl#L551-L555">source</a></section></article><h2 id="Set-Model-and-Weights"><a class="docs-heading-anchor" href="#Set-Model-and-Weights">Set Model and Weights</a><a id="Set-Model-and-Weights-1"></a><a class="docs-heading-anchor-permalink" href="#Set-Model-and-Weights" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.setmodel!" href="#ModelPredictiveControl.setmodel!"><code>ModelPredictiveControl.setmodel!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setmodel!(estim::StateEstimator, model=estim.model; &lt;keyword arguments&gt;) -&gt; estim</code></pre><p>Set <code>model</code> and covariance matrices of <code>estim</code> <a href="../state_estim/#StateEstimator"><code>StateEstimator</code></a>.</p><p>Allows model adaptation of estimators based on <a href="../sim_model/#LinModel"><code>LinModel</code></a> at runtime. Modification  of <a href="../sim_model/#NonLinModel"><code>NonLinModel</code></a> state-space functions is not supported. New covariance matrices can be specified with the keyword arguments (see <a href="../state_estim/#SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a> documentation for the nomenclature). Not supported by <a href="../state_estim/#Luenberger"><code>Luenberger</code></a> and <a href="../state_estim/#SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a>,  use the time-varying <a href="../state_estim/#KalmanFilter"><code>KalmanFilter</code></a> instead. The <a href="../state_estim/#MovingHorizonEstimator"><code>MovingHorizonEstimator</code></a> model is kept constant over the estimation horizon <span>$H_e$</span>. The matrix dimensions and sample time must stay the same. Note that the observability and controllability of the new augmented model is not verified (see Extended Help for more info).</p><p><strong>Arguments</strong></p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Keyword arguments with <em><code>emphasis</code></em> are non-Unicode alternatives.</p></div></div><ul><li><code>estim::StateEstimator</code> : estimator to set model and covariances.</li><li><code>model=estim.model</code> : new plant model (not supported by <a href="../sim_model/#NonLinModel"><code>NonLinModel</code></a>).</li><li><code>Q̂=nothing</code> or <em><code>Qhat</code></em> : new augmented model <span>$\mathbf{Q̂}$</span> covariance matrix.</li><li><code>R̂=nothing</code> or <em><code>Rhat</code></em> : new augmented model <span>$\mathbf{R̂}$</span> covariance matrix.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; kf = KalmanFilter(LinModel(ss(0.1, 0.5, 1, 0, 4.0)), σQ=[√4.0], σQint_ym=[√0.25]);

julia&gt; kf.model.A[], kf.Q̂[1, 1], kf.Q̂[2, 2] 
(0.1, 4.0, 0.25)

julia&gt; setmodel!(kf, LinModel(ss(0.42, 0.5, 1, 0, 4.0)), Q̂=[1 0;0 0.5]);

julia&gt; kf.model.A[], kf.Q̂[1, 1], kf.Q̂[2, 2] 
(0.42, 1.0, 0.5)</code></pre><p><strong>Extended Help</strong></p><details class="admonition is-details"><summary class="admonition-header">Extended Help</summary><div class="admonition-body"><p>Using the default model augmentation computed by the <a href="../state_estim/#ModelPredictiveControl.default_nint"><code>default_nint</code></a> method,  switching from a non-integrating plant model to an integrating one will produce an augmented model that is not observable. Moving the unmeasured disturbances at the  model input (<code>nint_u</code> parameter) can fix this issue.</p></div></details></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/bbb131b89316cac00507e1bb972717f56c825fb3/src/estimator/execute.jl#L323-L365">source</a></section><section><div><pre><code class="language-julia hljs">setmodel!(mpc::PredictiveController, model=mpc.estim.model; &lt;keyword arguments&gt;) -&gt; mpc</code></pre><p>Set <code>model</code> and objective function weights of <code>mpc</code> <a href="../predictive_control/#PredictiveController"><code>PredictiveController</code></a>.</p><p>Allows model adaptation of controllers based on <a href="../sim_model/#LinModel"><code>LinModel</code></a> at runtime. Modification of <a href="../sim_model/#NonLinModel"><code>NonLinModel</code></a> state-space functions is not supported. New weight matrices in the objective function can be specified with the keyword arguments (see <a href="../predictive_control/#LinMPC"><code>LinMPC</code></a> for the nomenclature). If <code>Cwt ≠ Inf</code>, the augmented move suppression weight is <span>$\mathbf{Ñ}_{H_c} = \mathrm{diag}(\mathbf{N}_{H_c}, C)$</span>, else <span>$\mathbf{Ñ}_{H_c} = \mathbf{N}_{H_c}$</span>. The <a href="../state_estim/#StateEstimator"><code>StateEstimator</code></a> <code>mpc.estim</code> cannot be a <a href="../state_estim/#Luenberger"><code>Luenberger</code></a> observer or a <a href="../state_estim/#SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a> (the default estimator). Construct the <code>mpc</code> object with a time-varying <a href="../state_estim/#KalmanFilter"><code>KalmanFilter</code></a> instead. Note that the model is constant over the prediction horizon <span>$H_p$</span>.</p><p><strong>Arguments</strong></p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Keyword arguments with <em><code>emphasis</code></em> are non-Unicode alternatives.</p></div></div><ul><li><code>mpc::PredictiveController</code> : controller to set model and weights.</li><li><code>model=mpc.estim.model</code> : new plant model (not supported by <a href="../sim_model/#NonLinModel"><code>NonLinModel</code></a>).</li><li><code>Mwt=nothing</code> : new main diagonal in <span>$\mathbf{M}$</span> weight matrix (vector).</li><li><code>Nwt=nothing</code> : new main diagonal in <span>$\mathbf{N}$</span> weight matrix (vector).</li><li><code>Lwt=nothing</code> : new main diagonal in <span>$\mathbf{L}$</span> weight matrix (vector).</li><li><code>M_Hp=nothing</code> : new <span>$\mathbf{M}_{H_p}$</span> weight matrix.</li><li><code>Ñ_Hc=nothing</code> or <em><code>Ntilde_Hc</code></em> : new <span>$\mathbf{Ñ}_{H_c}$</span> weight matrix (see def. above).</li><li><code>L_Hp=nothing</code> : new <span>$\mathbf{L}_{H_p}$</span> weight matrix.</li><li>additional keyword arguments are passed to <code>setmodel!(mpc.estim)</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mpc = LinMPC(KalmanFilter(LinModel(ss(0.1, 0.5, 1, 0, 4.0)), σR=[√25]), Hp=1, Hc=1);

julia&gt; mpc.estim.model.A[1], mpc.estim.R̂[1], mpc.M_Hp[1], mpc.Ñ_Hc[1]
(0.1, 25.0, 1.0, 0.1)

julia&gt; setmodel!(mpc, LinModel(ss(0.42, 0.5, 1, 0, 4.0)); R̂=[9], M_Hp=[10], Nwt=[0.666]);

julia&gt; mpc.estim.model.A[1], mpc.estim.R̂[1], mpc.M_Hp[1], mpc.Ñ_Hc[1]
(0.42, 9.0, 10.0, 0.666)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/bbb131b89316cac00507e1bb972717f56c825fb3/src/controller/execute.jl#L559-L600">source</a></section></article><h2 id="Get-Additional-Information"><a class="docs-heading-anchor" href="#Get-Additional-Information">Get Additional Information</a><a id="Get-Additional-Information-1"></a><a class="docs-heading-anchor-permalink" href="#Get-Additional-Information" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.getinfo" href="#ModelPredictiveControl.getinfo"><code>ModelPredictiveControl.getinfo</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getinfo(estim::MovingHorizonEstimator) -&gt; info</code></pre><p>Get additional info on <code>estim</code> <a href="../state_estim/#MovingHorizonEstimator"><code>MovingHorizonEstimator</code></a> optimum for troubleshooting.</p><p>If <code>estim.direct==true</code>, the function should be called after calling <a href="#ModelPredictiveControl.preparestate!"><code>preparestate!</code></a>. Otherwise, call it after <a href="#ModelPredictiveControl.updatestate!"><code>updatestate!</code></a>. It returns the dictionary <code>info</code> with the following fields:</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Fields with <em><code>emphasis</code></em> are non-Unicode alternatives.</p></div></div><ul><li><code>:Ŵ</code> or <em><code>:What</code></em> : optimal estimated process noise over <span>$N_k$</span>, <span>$\mathbf{Ŵ}$</span></li><li><code>:ϵ</code> or <em><code>:epsilon</code></em> : optimal slack variable, <span>$ϵ$</span></li><li><code>:X̂</code> or <em><code>:Xhat</code></em> : optimal estimated states over <span>$N_k+1$</span>, <span>$\mathbf{X̂}$</span></li><li><code>:x̂</code> or <em><code>:xhat</code></em> : optimal estimated state for the next time step, <span>$\mathbf{x̂}_k(k+1)$</span></li><li><code>:V̂</code> or <em><code>:Vhat</code></em> : optimal estimated sensor noise over <span>$N_k$</span>, <span>$\mathbf{V̂}$</span></li><li><code>:P̄</code> or <em><code>:Pbar</code></em> : estimation error covariance at arrival, <span>$\mathbf{P̄}$</span></li><li><code>:x̄</code> or <em><code>:xbar</code></em> : optimal estimation error at arrival, <span>$\mathbf{x̄}$</span></li><li><code>:Ŷ</code> or <em><code>:Yhat</code></em> : optimal estimated outputs over <span>$N_k$</span>, <span>$\mathbf{Ŷ}$</span></li><li><code>:Ŷm</code> or <em><code>:Yhatm</code></em> : optimal estimated measured outputs over <span>$N_k$</span>, <span>$\mathbf{Ŷ^m}$</span></li><li><code>:x̂arr</code> or <em><code>:xhatarr</code></em> : optimal estimated state at arrival, <span>$\mathbf{x̂}_k(k-N_k+p)$</span></li><li><code>:J</code>   : objective value optimum, <span>$J$</span></li><li><code>:Ym</code>  : measured outputs over <span>$N_k$</span>, <span>$\mathbf{Y^m}$</span></li><li><code>:U</code>   : manipulated inputs over <span>$N_k$</span>, <span>$\mathbf{U}$</span></li><li><code>:D</code>   : measured disturbances over <span>$N_k$</span>, <span>$\mathbf{D}$</span></li><li><code>:sol</code> : solution summary of the optimizer for printing</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = LinModel(ss(1.0, 1.0, 1.0, 0, 5.0));

julia&gt; estim = MovingHorizonEstimator(model, He=1, nint_ym=0, direct=false);

julia&gt; updatestate!(estim, [0], [1]);

julia&gt; round.(getinfo(estim)[:Ŷ], digits=3)
1-element Vector{Float64}:
 0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/bbb131b89316cac00507e1bb972717f56c825fb3/src/estimator/mhe/execute.jl#L65-L105">source</a></section><section><div><pre><code class="language-julia hljs">getinfo(mpc::PredictiveController) -&gt; info</code></pre><p>Get additional info about <code>mpc</code> <a href="../predictive_control/#PredictiveController"><code>PredictiveController</code></a> optimum for troubleshooting.</p><p>The function should be called after calling <a href="../predictive_control/#ModelPredictiveControl.moveinput!"><code>moveinput!</code></a>. It returns the dictionary <code>info</code> with the following fields:</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Fields with <em><code>emphasis</code></em> are non-Unicode alternatives.</p></div></div><ul><li><code>:ΔU</code> or <em><code>:DeltaU</code></em> : optimal manipulated input increments over <span>$H_c$</span>, <span>$\mathbf{ΔU}$</span></li><li><code>:ϵ</code> or <em><code>:epsilon</code></em> : optimal slack variable, <span>$ϵ$</span></li><li><code>:D̂</code> or <em><code>:Dhat</code></em> : predicted measured disturbances over <span>$H_p$</span>, <span>$\mathbf{D̂}$</span></li><li><code>:ŷ</code> or <em><code>:yhat</code></em> : current estimated output, <span>$\mathbf{ŷ}(k)$</span></li><li><code>:Ŷ</code> or <em><code>:Yhat</code></em> : optimal predicted outputs over <span>$H_p$</span>, <span>$\mathbf{Ŷ}$</span></li><li><code>:Ŷs</code> or <em><code>:Yhats</code></em> : predicted stochastic output over <span>$H_p$</span> of <a href="../state_estim/#InternalModel"><code>InternalModel</code></a>, <span>$\mathbf{Ŷ_s}$</span></li><li><code>:R̂y</code> or <em><code>:Rhaty</code></em> : predicted output setpoint over <span>$H_p$</span>, <span>$\mathbf{R̂_y}$</span></li><li><code>:R̂u</code> or <em><code>:Rhatu</code></em> : predicted manipulated input setpoint over <span>$H_p$</span>, <span>$\mathbf{R̂_u}$</span></li><li><code>:x̂end</code> or <em><code>:xhatend</code></em> : optimal terminal states, <span>$\mathbf{x̂}_i(k+H_p)$</span></li><li><code>:J</code>   : objective value optimum, <span>$J$</span></li><li><code>:U</code>   : optimal manipulated inputs over <span>$H_p$</span>, <span>$\mathbf{U}$</span></li><li><code>:u</code>   : current optimal manipulated input, <span>$\mathbf{u}(k)$</span></li><li><code>:d</code>   : current measured disturbance, <span>$\mathbf{d}(k)$</span></li></ul><p>For <a href="../predictive_control/#LinMPC"><code>LinMPC</code></a> and <a href="../predictive_control/#NonLinMPC"><code>NonLinMPC</code></a>, the field <code>:sol</code> also contains the optimizer solution summary that can be printed. Lastly, the optimal economic cost <code>:JE</code> is also available for <a href="../predictive_control/#NonLinMPC"><code>NonLinMPC</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mpc = LinMPC(LinModel(tf(5, [2, 1]), 3), Nwt=[0], Hp=1, Hc=1);

julia&gt; preparestate!(mpc, [0]); u = moveinput!(mpc, [10]);

julia&gt; round.(getinfo(mpc)[:Ŷ], digits=3)
1-element Vector{Float64}:
 10.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/bbb131b89316cac00507e1bb972717f56c825fb3/src/controller/execute.jl#L73-L112">source</a></section></article><h2 id="Real-Time-Simulate-and-Control"><a class="docs-heading-anchor" href="#Real-Time-Simulate-and-Control">Real-Time Simulate and Control</a><a id="Real-Time-Simulate-and-Control-1"></a><a class="docs-heading-anchor-permalink" href="#Real-Time-Simulate-and-Control" title="Permalink"></a></h2><div class="admonition is-danger"><header class="admonition-header">Disclaimer</header><div class="admonition-body"><p>These utilities are for soft real-time applications. They are not suitable for hard real-time environnement like safety-critical processes.</p></div></div><h3 id="Save-current-time-t"><a class="docs-heading-anchor" href="#Save-current-time-t">Save current time t</a><a id="Save-current-time-t-1"></a><a class="docs-heading-anchor-permalink" href="#Save-current-time-t" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.savetime!" href="#ModelPredictiveControl.savetime!"><code>ModelPredictiveControl.savetime!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">savetime!(model::SimModel) -&gt; t</code></pre><p>Set <code>model.t</code> to <code>time()</code>  and return the value.</p><p>Used in conjunction with <a href="#ModelPredictiveControl.periodsleep"><code>periodsleep</code></a> for simple soft real-time simulations. Call this function before any other in the simulation loop.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/bbb131b89316cac00507e1bb972717f56c825fb3/src/sim_model.jl#L289-L296">source</a></section><section><div><pre><code class="language-julia hljs">savetime!(estim::StateEstimator) -&gt; t</code></pre><p>Call <code>savetime!(estim.model)</code> and return the time <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/bbb131b89316cac00507e1bb972717f56c825fb3/src/estimator/execute.jl#L286-L290">source</a></section><section><div><pre><code class="language-julia hljs">savetime!(mpc::PredictiveController) -&gt; t</code></pre><p>Call <code>savetime!(mpc.estim.model)</code> and return the time <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/bbb131b89316cac00507e1bb972717f56c825fb3/src/controller/execute.jl#L537-L541">source</a></section></article><h3 id="Period-Sleep"><a class="docs-heading-anchor" href="#Period-Sleep">Period Sleep</a><a id="Period-Sleep-1"></a><a class="docs-heading-anchor-permalink" href="#Period-Sleep" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.periodsleep" href="#ModelPredictiveControl.periodsleep"><code>ModelPredictiveControl.periodsleep</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">periodsleep(model::SimModel, busywait=false) -&gt; nothing</code></pre><p>Sleep for <code>model.Ts</code> s minus the time elapsed since the last call to <a href="#ModelPredictiveControl.savetime!"><code>savetime!</code></a>.</p><p>It calls <a href="https://docs.julialang.org/en/v1/base/parallel/#Base.sleep"><code>sleep</code></a> if <code>busywait</code> is <code>false</code>. Else, a simple <code>while</code> loop implements busy-waiting. As a rule-of-thumb, busy-waiting should be used if <code>model.Ts &lt; 0.1</code> s, since the accuracy of <code>sleep</code> is around 1 ms. Can be used to implement simple soft real-time simulations, see the example below.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The allocations in Julia are garbage-collected (GC) automatically. This can affect the  timing. In such cases, you can temporarily stop the GC with <code>GC.enable(false)</code>, and restart it at a convenient time e.g.: just before calling <code>periodsleep</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = LinModel(tf(2, [0.3, 1]), 0.25);

julia&gt; function sim_realtime!(model)
           t_0 = time()
           for i=1:3
               t = savetime!(model)      # first function called
               println(round(t - t_0, digits=3))
               updatestate!(model, [1])
               periodsleep(model, true)  # last function called
           end
       end;

julia&gt; sim_realtime!(model)
0.0
0.25
0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/bbb131b89316cac00507e1bb972717f56c825fb3/src/sim_model.jl#L302-L336">source</a></section><section><div><pre><code class="language-julia hljs">periodsleep(estim::StateEstimator) -&gt; nothing</code></pre><p>Call <code>periodsleep(estim.model)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/bbb131b89316cac00507e1bb972717f56c825fb3/src/estimator/execute.jl#L293-L297">source</a></section><section><div><pre><code class="language-julia hljs">periodsleep(mpc::PredictiveController) -&gt; nothing</code></pre><p>Call <code>periodsleep(mpc.estim.model)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/bbb131b89316cac00507e1bb972717f56c825fb3/src/controller/execute.jl#L544-L548">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../predictive_control/">« Predictive Controllers</a><a class="docs-footer-nextpage" href="../plot_sim/">Simulations and Plots »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Wednesday 27 November 2024 15:06">Wednesday 27 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
