<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Nonlinear Design · ModelPredictiveControl.jl</title><meta name="title" content="Nonlinear Design · ModelPredictiveControl.jl"/><meta property="og:title" content="Nonlinear Design · ModelPredictiveControl.jl"/><meta property="twitter:title" content="Nonlinear Design · ModelPredictiveControl.jl"/><meta name="description" content="Documentation for ModelPredictiveControl.jl."/><meta property="og:description" content="Documentation for ModelPredictiveControl.jl."/><meta property="twitter:description" content="Documentation for ModelPredictiveControl.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="ModelPredictiveControl.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="ModelPredictiveControl.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelPredictiveControl.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../installation/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../linmpc/">Linear Design</a></li><li class="is-active"><a class="tocitem" href>Nonlinear Design</a><ul class="internal"><li><a class="tocitem" href="#Nonlinear-Model"><span>Nonlinear Model</span></a></li><li><a class="tocitem" href="#Nonlinear-Model-Predictive-Controller"><span>Nonlinear Model Predictive Controller</span></a></li><li><a class="tocitem" href="#Economic-Model-Predictive-Controller"><span>Economic Model Predictive Controller</span></a></li><li><a class="tocitem" href="#Custom-Nonlinear-Inequality-Constraints"><span>Custom Nonlinear Inequality Constraints</span></a></li><li><a class="tocitem" href="#Model-Linearization"><span>Model Linearization</span></a></li><li><a class="tocitem" href="#Adapting-the-Model-via-Successive-Linearization"><span>Adapting the Model via Successive Linearization</span></a></li></ul></li><li><a class="tocitem" href="../mtk/">ModelingToolkit</a></li></ul></li></ul></li><li><span class="tocitem">Functions</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Public</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../public/sim_model/">Plant Models</a></li><li><a class="tocitem" href="../../public/state_estim/">State Estimators</a></li><li><a class="tocitem" href="../../public/predictive_control/">Predictive Controllers</a></li><li><a class="tocitem" href="../../public/generic_func/">Generic Functions</a></li><li><a class="tocitem" href="../../public/plot_sim/">Simulations and Plots</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../internals/sim_model/">Plant Models</a></li><li><a class="tocitem" href="../../internals/state_estim/">State Estimators</a></li><li><a class="tocitem" href="../../internals/predictive_control/">Predictive Controllers</a></li></ul></li></ul></li><li><a class="tocitem" href="../../func_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Nonlinear Design</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Nonlinear Design</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaControl/ModelPredictiveControl.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/main/docs/src/manual/nonlinmpc.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="man_nonlin"><a class="docs-heading-anchor" href="#man_nonlin">Manual: Nonlinear Design</a><a id="man_nonlin-1"></a><a class="docs-heading-anchor-permalink" href="#man_nonlin" title="Permalink"></a></h1><ul><li><a href="#man_nonlin">Manual: Nonlinear Design</a></li><li class="no-marker"><ul><li><a href="#Nonlinear-Model">Nonlinear Model</a></li><li><a href="#Nonlinear-Model-Predictive-Controller">Nonlinear Model Predictive Controller</a></li><li><a href="#Economic-Model-Predictive-Controller">Economic Model Predictive Controller</a></li><li><a href="#Custom-Nonlinear-Inequality-Constraints">Custom Nonlinear Inequality Constraints</a></li><li><a href="#Model-Linearization">Model Linearization</a></li><li><a href="#Adapting-the-Model-via-Successive-Linearization">Adapting the Model via Successive Linearization</a></li></ul></li></ul><h2 id="Nonlinear-Model"><a class="docs-heading-anchor" href="#Nonlinear-Model">Nonlinear Model</a><a id="Nonlinear-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-Model" title="Permalink"></a></h2><p>In this example, the goal is to control the angular position <span>$θ$</span> of a pendulum attached to a motor. Knowing that the manipulated input is the motor torque <span>$τ$</span> in Nm, the I/O vectors are:</p><p class="math-container">\[\begin{aligned}
    \mathbf{u} &amp;= τ \\
    \mathbf{y} &amp;= θ
\end{aligned}\]</p><p>The following figure presents the system:</p><p><img src="../../assets/pendulum.svg" alt="pendulum" width=200 style="background-color:white; 
    border:20px solid white; display: block; margin-left: auto; margin-right: auto;"/></p><p>The plant model is nonlinear:</p><p class="math-container">\[\begin{aligned}
    \dot{θ}(t) &amp;= ω(t) \\
    \dot{ω}(t) &amp;= -\frac{g}{L}\sin\big( θ(t) \big) - \frac{K}{m} ω(t) + \frac{1}{m L^2} τ(t)
\end{aligned}\]</p><p>in which <span>$g$</span> is the gravitational acceleration in m/s², <span>$L$</span>, the pendulum length in m, <span>$K$</span>, the friction coefficient at the pivot point in kg/s, and <span>$m$</span>, the mass attached at the end of the pendulum in kg, all bundled in the parameter vector <span>$\mathbf{p} = [\begin{smallmatrix} g &amp; L &amp; K &amp; m \end{smallmatrix}]&#39;$</span>. The <a href="../../public/sim_model/#NonLinModel"><code>NonLinModel</code></a> constructor assumes by default that the state function <code>f</code> is continuous in time, that is, an ordinary differential equation system (like here):</p><pre><code class="language-julia hljs">using ModelPredictiveControl
function f(x, u, _ , p)
    g, L, K, m = p          # [m/s²], [m], [kg/s], [kg]
    θ, ω = x[1], x[2]       # [rad], [rad/s]
    τ  = u[1]               # [Nm]
    dθ = ω
    dω = -g/L*sin(θ) - K/m*ω + τ/m/L^2
    return [dθ, dω]
end
h(x, _ , _ ) = [180/π*x[1]] # [°]
p_model = [9.8, 0.4, 1.2, 0.3]
nu, nx, ny, Ts = 1, 2, 1, 0.1
vu, vx, vy = [&quot;\$τ\$ (Nm)&quot;], [&quot;\$θ\$ (rad)&quot;, &quot;\$ω\$ (rad/s)&quot;], [&quot;\$θ\$ (°)&quot;]
model = setname!(NonLinModel(f, h, Ts, nu, nx, ny; p=p_model); u=vu, x=vx, y=vy)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NonLinModel with a sample time Ts = 0.1 s, RungeKutta solver and:
 1 manipulated inputs u
 2 states x
 1 outputs y
 0 measured disturbances d</code></pre><p>The output function <span>$\mathbf{h}$</span> converts the <span>$θ$</span> angle to degrees. Note that special characters like <span>$θ$</span> can be typed in the Julia REPL or VS Code by typing <code>\theta</code> and pressing the <code>&lt;TAB&gt;</code> key. The parameter <code>p</code> can be of any type but use a mutable type like a vector of you want to modify it later. A 4th order <a href="../../public/sim_model/#RungeKutta"><code>RungeKutta</code></a> method solves the differential equations by default. It is good practice to first simulate <code>model</code> using <a href="../../public/plot_sim/#ModelPredictiveControl.sim!"><code>sim!</code></a> as a quick sanity check:</p><pre><code class="language-julia hljs">using Plots
u = [0.5]
N = 35
res = sim!(model, N, u)
plot(res, plotu=false)</code></pre><p><img src="../plot1_NonLinMPC.svg" alt="plot1_NonLinMPC"/></p><p>The <a href="../../public/sim_model/#ModelPredictiveControl.setname!"><code>setname!</code></a> function allows customized Y-axis labels. The available plotting options are detailed in the documentation of the corresponding <a href="../../public/plot_sim/#ModelPredictiveControl.plot_recipe"><code>plot</code></a> method.</p><h2 id="Nonlinear-Model-Predictive-Controller"><a class="docs-heading-anchor" href="#Nonlinear-Model-Predictive-Controller">Nonlinear Model Predictive Controller</a><a id="Nonlinear-Model-Predictive-Controller-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-Model-Predictive-Controller" title="Permalink"></a></h2><p>An <a href="../../public/state_estim/#UnscentedKalmanFilter"><code>UnscentedKalmanFilter</code></a> estimates the plant state :</p><pre><code class="language-julia hljs">α=0.01; σQ=[0.1, 1.0]; σR=[5.0]; nint_u=[1]; σQint_u=[0.1]
estim = UnscentedKalmanFilter(model; α, σQ, σR, nint_u, σQint_u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">UnscentedKalmanFilter estimator with a sample time Ts = 0.1 s, NonLinModel and:
 1 manipulated inputs u (1 integrating states)
 3 estimated states x̂
 1 measured outputs ym (0 integrating states)
 0 unmeasured outputs yu
 0 measured disturbances d</code></pre><p>The vectors <code>σQ</code> and <code>σR</code> are the standard deviations of the process and sensor noises, respectively. The value for the velocity <span>$ω$</span> is higher here (<code>σQ</code> second value) since <span>$\dot{ω}(t)$</span> equation includes an uncertain parameter: the friction coefficient <span>$K$</span>. Also, the argument <code>nint_u</code> explicitly adds one integrating state at the model input, the motor torque <span>$τ$</span>, with an associated standard deviation <code>σQint_u</code> of 0.1 N m. The estimator tuning is tested on a plant with a 25 % larger friction coefficient <span>$K$</span>:</p><pre><code class="language-julia hljs">p_plant = copy(p_model)
p_plant[3] = 1.25*p_model[3]
plant = setname!(NonLinModel(f, h, Ts, nu, nx, ny; p=p_plant); u=vu, x=vx, y=vy)
res = sim!(estim, N, [0.5], plant=plant, y_noise=[0.5])
plot(res, plotu=false, plotxwithx̂=true)</code></pre><p><img src="../plot2_NonLinMPC.svg" alt="plot2_NonLinMPC"/></p><p>The estimate <span>$x̂_3$</span> is the integrating state on the torque <span>$τ$</span> that compensates for static errors. The Kalman filter performance seems sufficient for control.</p><p>As the motor torque is limited to -1.5 to 1.5 N m, we incorporate the input constraints in a <a href="../../public/predictive_control/#NonLinMPC"><code>NonLinMPC</code></a>:</p><pre><code class="language-julia hljs">Hp, Hc, Mwt, Nwt = 20, 2, [0.5], [2.5]
nmpc = NonLinMPC(estim; Hp, Hc, Mwt, Nwt, Cwt=Inf)
umin, umax = [-1.5], [+1.5]
nmpc = setconstraint!(nmpc; umin, umax)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NonLinMPC controller with a sample time Ts = 0.1 s, Ipopt optimizer, UnscentedKalmanFilter estimator and:
 20 prediction steps Hp
  2 control steps Hc
  0 slack variable ϵ (control constraints)
  1 manipulated inputs u (1 integrating states)
  3 estimated states x̂
  1 measured outputs ym (0 integrating states)
  0 unmeasured outputs yu
  0 measured disturbances d</code></pre><p>The option <code>Cwt=Inf</code> disables the slack variable <code>ϵ</code> for constraint softening. We test <code>mpc</code> performance on <code>plant</code> by imposing an angular setpoint of 180° (inverted position):</p><pre><code class="language-julia hljs">res_ry = sim!(nmpc, N, [180.0], plant=plant, x_0=[0, 0], x̂_0=[0, 0, 0])
plot(res_ry)</code></pre><p><img src="../plot3_NonLinMPC.svg" alt="plot3_NonLinMPC"/></p><p>The controller seems robust enough to variations on <span>$K$</span> coefficient. Starting from this inverted position, the closed-loop response to a step disturbances of 10° is also satisfactory:</p><pre><code class="language-julia hljs">res_yd = sim!(nmpc, N, [180.0], plant=plant, x_0=[π, 0], x̂_0=[π, 0, 0], y_step=[10])
plot(res_yd)</code></pre><p><img src="../plot4_NonLinMPC.svg" alt="plot4_NonLinMPC"/></p><p>See <a href="../../public/plot_sim/#ModelPredictiveControl.sim!"><code>sim!</code></a> documentation for details on the possible simulation scenarios.</p><h2 id="Economic-Model-Predictive-Controller"><a class="docs-heading-anchor" href="#Economic-Model-Predictive-Controller">Economic Model Predictive Controller</a><a id="Economic-Model-Predictive-Controller-1"></a><a class="docs-heading-anchor-permalink" href="#Economic-Model-Predictive-Controller" title="Permalink"></a></h2><p>Economic MPC can achieve the same objective but with lower economical costs. For this case study, the controller will aim to reduce the energy consumed by the motor. The power in watt transmitted by the motor to the pendulum is:</p><p class="math-container">\[P(t) = τ(t) ω(t)\]</p><p>Thus, the work in joule done by the motor from <span>$t = t_0$</span> to <span>$t_{end}$</span> is:</p><p class="math-container">\[W = \int_{t_0}^{t_{end}} P(t) \mathrm{d}t = \int_{t_0}^{t_{end}} τ(t) ω(t) \mathrm{d}t\]</p><p>With the sampling time <span>$T_s$</span> in s, the prediction horizon <span>$H_p$</span>, the limits defined as <span>$t_0 = k T_s$</span> and <span>$t_{end} = (k+H_p) T_s$</span>, and the left-endpoint rectangle method for the integral, we get:</p><p class="math-container">\[W ≈ T_s \sum_{j=0}^{H_p-1} τ(k + j) ω(k + j)\]</p><p>The objective function will now include an additive term that penalizes the work done by the motor <span>$W$</span> to reduce the energy consumption. Notice that <span>$W$</span> is a function of the manipulated input <span>$τ$</span> and the angular speed <span>$ω$</span>, a state that is not measured (only the angle <span>$θ$</span> is measured here). As the arguments of <a href="../../public/predictive_control/#NonLinMPC"><code>NonLinMPC</code></a> economic function <code>JE</code> do not include the states, the speed is now defined as an unmeasured output to design a Kalman Filter similar to the previous one (<span>$\mathbf{y^m} = θ$</span> and <span>$\mathbf{y^u} = ω$</span>):</p><pre><code class="language-julia hljs">h2(x, _ , _ ) = [180/π*x[1], x[2]]
nu, nx, ny = 1, 2, 2
model2 = setname!(NonLinModel(f, h2, Ts, nu, nx, ny; p=p_model), u=vu, x=vx, y=[vy; vx[2]])
plant2 = setname!(NonLinModel(f, h2, Ts, nu, nx, ny; p=p_plant), u=vu, x=vx, y=[vy; vx[2]])
estim2 = UnscentedKalmanFilter(model2; σQ, σR, nint_u, σQint_u, i_ym=[1])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">UnscentedKalmanFilter estimator with a sample time Ts = 0.1 s, NonLinModel and:
 1 manipulated inputs u (1 integrating states)
 3 estimated states x̂
 1 measured outputs ym (0 integrating states)
 1 unmeasured outputs yu
 0 measured disturbances d</code></pre><p>The <code>plant2</code> object based on <code>h2</code> is also required since <a href="../../public/plot_sim/#ModelPredictiveControl.sim!"><code>sim!</code></a> expects that the output vector of <code>plant</code> argument corresponds to the model output vector in <code>mpc</code> argument. We can now define the <span>$J_E$</span> function and the <code>empc</code> controller:</p><pre><code class="language-julia hljs">function JE(Ue, Ŷe, _ , p)
    Ts = p
    τ, ω = Ue[1:end-1], Ŷe[2:2:end-1]
    return Ts*sum(τ.*ω)
end
empc = NonLinMPC(estim2; Hp, Hc, Nwt, Mwt=[0.5, 0], Cwt=Inf, Ewt=3.5e3, JE=JE, p=Ts)
empc = setconstraint!(empc; umin, umax)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NonLinMPC controller with a sample time Ts = 0.1 s, Ipopt optimizer, UnscentedKalmanFilter estimator and:
 20 prediction steps Hp
  2 control steps Hc
  0 slack variable ϵ (control constraints)
  1 manipulated inputs u (1 integrating states)
  3 estimated states x̂
  1 measured outputs ym (0 integrating states)
  1 unmeasured outputs yu
  0 measured disturbances d</code></pre><p>The keyword argument <code>Ewt</code> weights the economic costs relative to the other terms in the objective function. The term must be large enough to be significant but a too high value can lead to a static error on the angle setpoint. The second element of <code>Mwt</code> is zero since the speed <span>$ω$</span> is not requested to track a setpoint. The closed-loop response to a 180° setpoint is similar:</p><pre><code class="language-julia hljs">res2_ry = sim!(empc, N, [180, 0], plant=plant2, x_0=[0, 0], x̂_0=[0, 0, 0])
plot(res2_ry, ploty=[1])</code></pre><p><img src="../plot5_NonLinMPC.svg" alt="plot5_NonLinMPC"/></p><p>and the energy consumption is slightly lower:</p><pre><code class="language-julia hljs">function calcW(res)
    τ, ω = res.U_data[1, 1:end-1], res.X_data[2, 1:end-1]
    return Ts*sum(τ.*ω)
end
Dict(:W_nmpc =&gt; calcW(res_ry), :W_empc =&gt; calcW(res2_ry))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Symbol, Float64} with 2 entries:
  :W_empc =&gt; 3.90053
  :W_nmpc =&gt; 3.92078</code></pre><p>Also, for a 10° step disturbance:</p><pre><code class="language-julia hljs">res2_yd = sim!(empc, N, [180; 0]; plant=plant2, x_0=[π, 0], x̂_0=[π, 0, 0], y_step=[10, 0])
plot(res2_yd, ploty=[1])</code></pre><p><img src="../plot6_NonLinMPC.svg" alt="plot6_NonLinMPC"/></p><p>the new controller is able to recuperate a little more energy from the pendulum (i.e. negative work):</p><pre><code class="language-julia hljs">Dict(:W_nmpc =&gt; calcW(res_yd), :W_empc =&gt; calcW(res2_yd))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Symbol, Float64} with 2 entries:
  :W_empc =&gt; -0.0542454
  :W_nmpc =&gt; -0.0440395</code></pre><p>Of course, this gain is only exploitable if the motor electronic includes some kind of regenerative circuitry.</p><h2 id="Custom-Nonlinear-Inequality-Constraints"><a class="docs-heading-anchor" href="#Custom-Nonlinear-Inequality-Constraints">Custom Nonlinear Inequality Constraints</a><a id="Custom-Nonlinear-Inequality-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Nonlinear-Inequality-Constraints" title="Permalink"></a></h2><p>Instead of limits on the torque, suppose that the motor can deliver a maximum of 3 watt:</p><p class="math-container">\[P(t) = τ(t) ω(t) ≤ P_\mathrm{max}\]</p><p>with <span>$P_\mathrm{max} = 3$</span> W. This inequality describes nonlinear constraints that can be implemented using the custom <span>$\mathbf{g_c}$</span> function of <a href="../../public/predictive_control/#NonLinMPC"><code>NonLinMPC</code></a>. The constructor expects a function in this form:</p><p class="math-container">\[\mathbf{g_c}(\mathbf{U_e}, \mathbf{Ŷ_e}, \mathbf{D̂_e}, \mathbf{p}, ϵ) ≤ \mathbf{0}\]</p><p>in which <span>$ϵ$</span> is the slack variable (scalar), an necessary feature to ensure feasibility when the nonlinear inequality constraints are active. There is also an additional <code>LHS</code> argument (&quot;left-hand side&quot; of the inequality above) for the in-place version:</p><pre><code class="language-julia hljs">function gc!(LHS, Ue, Ŷe, _, p, ϵ)
    Pmax = p
    i_τ, i_ω = 1, 2
    for i in eachindex(LHS)
        τ, ω = Ue[i_τ], Ŷe[i_ω]
        P = τ*ω
        LHS[i] = P - Pmax - ϵ
        i_τ += 1
        i_ω += 2
    end
    return nothing
end</code></pre><p>Here we implemented the custom nonlinear constraint function in the mutating form to reduce the computational burden (see <a href="../../public/predictive_control/#NonLinMPC"><code>NonLinMPC</code></a> Extended Help for details). Note that similar mutating forms are also possible for the <code>f</code> and <code>h</code> functions of <a href="../../public/sim_model/#NonLinModel"><code>NonLinModel</code></a>. We construct the controller by enabling relaxation with the <code>Cwt</code> argument, and also by specifying the number of custom inequality constraints <code>nc</code>:</p><pre><code class="language-julia hljs">Cwt, Pmax, nc = 1e5, 3, Hp+1
nmpc2 = NonLinMPC(estim2; Hp, Hc, Nwt=Nwt, Mwt=[0.5, 0], Cwt, gc!, nc, p=Pmax)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NonLinMPC controller with a sample time Ts = 0.1 s, Ipopt optimizer, UnscentedKalmanFilter estimator and:
 20 prediction steps Hp
  2 control steps Hc
  1 slack variable ϵ (control constraints)
  1 manipulated inputs u (1 integrating states)
  3 estimated states x̂
  1 measured outputs ym (0 integrating states)
  1 unmeasured outputs yu
  0 measured disturbances d</code></pre><p>In addition to the 180° setpoint response:</p><pre><code class="language-julia hljs">res3_ry = sim!(nmpc2, N, [180; 0]; plant=plant2, x_0=[0, 0], x̂_0=[0, 0, 0]);</code></pre><p>a plot for the power <span>$P(t)$</span> is included below:</p><pre><code class="language-julia hljs">function plotWithPower(res, Pmax)
    t, τ, ω = res.T_data, res.U_data[1, :], res.X_data[2, :]
    P, Pmax = τ.*ω, fill(Pmax, size(t))
    plt1 = plot(res, ploty=[1])
    plt2 = plot(t, P, label=raw&quot;$P$&quot;, ylabel=raw&quot;$P$ (W)&quot;, xlabel=&quot;Time (s)&quot;, legend=:right)
    plot!(plt2, t, Pmax, label=raw&quot;$P_\mathrm{max}$&quot;, linestyle=:dot, linewidth=1.5)
    return plot(plt1, plt2, layout=(2,1))
end
plotWithPower(res3_ry, Pmax)</code></pre><p><img src="../plot7_NonLinMPC.svg" alt="plot7_NonLinMPC"/></p><p>The slight constraint violation is caused here by the modeling error on the friction coefficient <span>$K$</span>.</p><h2 id="Model-Linearization"><a class="docs-heading-anchor" href="#Model-Linearization">Model Linearization</a><a id="Model-Linearization-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Linearization" title="Permalink"></a></h2><p>Nonlinear MPC is more computationally expensive than <a href="../../public/predictive_control/#LinMPC"><code>LinMPC</code></a>. Solving the problem should always be faster than the sampling time <span>$T_s = 0.1$</span> s for real-time operation. This requirement is sometimes hard to meet on electronics or mechanical systems because of the fast dynamics. To ease the design and comparison with <a href="../../public/predictive_control/#LinMPC"><code>LinMPC</code></a>, the <a href="../../public/sim_model/#ModelPredictiveControl.linearize"><code>linearize</code></a> function allows automatic linearization of <a href="../../public/sim_model/#NonLinModel"><code>NonLinModel</code></a> based on <a href="https://juliadiff.org/ForwardDiff.jl/stable/"><code>ForwardDiff.jl</code></a>. We first linearize <code>model</code> at the point <span>$θ = π$</span> rad and <span>$ω = τ = 0$</span> (inverted position):</p><pre><code class="language-julia hljs">linmodel = linearize(model, x=[π, 0], u=[0])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LinModel with a sample time Ts = 0.1 s and:
 1 manipulated inputs u
 2 states x
 1 outputs y
 0 measured disturbances d</code></pre><p>A <a href="../../public/state_estim/#SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a> and a <a href="../../public/predictive_control/#LinMPC"><code>LinMPC</code></a> are designed from <code>linmodel</code>:</p><pre><code class="language-julia hljs">skf = SteadyKalmanFilter(linmodel; σQ, σR, nint_u, σQint_u)
mpc = LinMPC(skf; Hp, Hc, Mwt, Nwt, Cwt=Inf)
mpc = setconstraint!(mpc, umin=[-1.5], umax=[+1.5])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LinMPC controller with a sample time Ts = 0.1 s, OSQP optimizer, SteadyKalmanFilter estimator and:
 20 prediction steps Hp
  2 control steps Hc
  0 slack variable ϵ (control constraints)
  1 manipulated inputs u (1 integrating states)
  3 estimated states x̂
  1 measured outputs ym (0 integrating states)
  0 unmeasured outputs yu
  0 measured disturbances d</code></pre><p>The linear controller satisfactorily rejects the 10° step disturbance:</p><pre><code class="language-julia hljs">res_lin = sim!(mpc, N, [180.0]; plant, x_0=[π, 0], y_step=[10])
plot(res_lin)</code></pre><p><img src="../plot9_NonLinMPC.svg" alt="plot9_NonLinMPC"/></p><p>Solving the optimization problem of <code>mpc</code> with <a href="https://darnstrom.github.io/daqp/"><code>DAQP</code></a> optimizer instead of the default <code>OSQP</code> solver can improve the performance here. It is indeed documented that <code>DAQP</code> can perform better on small/medium dense matrices and unstable poles<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>, which is obviously the case here (absolute value of unstable poles are greater than one):</p><pre><code class="language-julia hljs">using LinearAlgebra; poles = eigvals(linmodel.A)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Float64}:
 0.48163285653799215
 1.3963025601286745</code></pre><p>To install the solver, run:</p><pre><code class="language-text hljs">using Pkg; Pkg.add(&quot;DAQP&quot;)</code></pre><p>Constructing a <a href="../../public/predictive_control/#LinMPC"><code>LinMPC</code></a> with <code>DAQP</code>:</p><pre><code class="language-julia hljs">using JuMP, DAQP
daqp = Model(DAQP.Optimizer, add_bridges=false)
mpc2 = LinMPC(skf; Hp, Hc, Mwt, Nwt, Cwt=Inf, optim=daqp)
mpc2 = setconstraint!(mpc2; umin, umax)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LinMPC controller with a sample time Ts = 0.1 s, DAQP optimizer, SteadyKalmanFilter estimator and:
 20 prediction steps Hp
  2 control steps Hc
  0 slack variable ϵ (control constraints)
  1 manipulated inputs u (1 integrating states)
  3 estimated states x̂
  1 measured outputs ym (0 integrating states)
  0 unmeasured outputs yu
  0 measured disturbances d</code></pre><p>does slightly improve the rejection of the step disturbance:</p><pre><code class="language-julia hljs">res_lin2 = sim!(mpc2, N, [180.0]; plant, x_0=[π, 0], y_step=[10])
plot(res_lin2)</code></pre><p><img src="../plot10_NonLinMPC.svg" alt="plot10_NonLinMPC"/></p><p>The closed-loop performance is still lower than the nonlinear controller, as expected, but computations are about 210 times faster (0.000071 s versus 0.015 s per time steps, on average). However, remember that <code>linmodel</code> is only valid for angular positions near 180°. For example, the 180° setpoint response from 0° is unsatisfactory since the predictions are poor in the first quadrant:</p><pre><code class="language-julia hljs">res_lin3 = sim!(mpc2, N, [180.0]; plant, x_0=[0, 0])
plot(res_lin3)</code></pre><p><img src="../plot11_NonLinMPC.svg" alt="plot11_NonLinMPC"/></p><p>Multiple linearized model and controller objects are required for large deviations from this operating point. This is known as gain scheduling. Another approach is adapting the model of the <a href="../../public/predictive_control/#LinMPC"><code>LinMPC</code></a> instance based on repeated online linearization.</p><h2 id="Adapting-the-Model-via-Successive-Linearization"><a class="docs-heading-anchor" href="#Adapting-the-Model-via-Successive-Linearization">Adapting the Model via Successive Linearization</a><a id="Adapting-the-Model-via-Successive-Linearization-1"></a><a class="docs-heading-anchor-permalink" href="#Adapting-the-Model-via-Successive-Linearization" title="Permalink"></a></h2><p>The <a href="../../public/generic_func/#ModelPredictiveControl.setmodel!"><code>setmodel!</code></a> method allows online adaptation of a linear plant model. Combined with the automatic linearization of <a href="../../public/sim_model/#ModelPredictiveControl.linearize"><code>linearize</code></a>, a successive linearization MPC can be designed with minimal efforts. The <a href="../../public/state_estim/#SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a> does not support <a href="../../public/generic_func/#ModelPredictiveControl.setmodel!"><code>setmodel!</code></a> so we need to use the time-varying <a href="../../public/state_estim/#KalmanFilter"><code>KalmanFilter</code></a>, and we initialize it with a linearization at <span>$θ = ω = τ = 0$</span>:</p><pre><code class="language-julia hljs">linmodel = linearize(model, x=[0, 0], u=[0])
kf = KalmanFilter(linmodel; σQ, σR, nint_u, σQint_u)
mpc3 = LinMPC(kf; Hp, Hc, Mwt, Nwt, Cwt=Inf, optim=daqp)
mpc3 = setconstraint!(mpc3; umin, umax)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LinMPC controller with a sample time Ts = 0.1 s, DAQP optimizer, KalmanFilter estimator and:
 20 prediction steps Hp
  2 control steps Hc
  0 slack variable ϵ (control constraints)
  1 manipulated inputs u (1 integrating states)
  3 estimated states x̂
  1 measured outputs ym (0 integrating states)
  0 unmeasured outputs yu
  0 measured disturbances d</code></pre><p>We create a function that simulates the plant and the adaptive controller:</p><pre><code class="language-julia hljs">function sim_adapt!(mpc, nonlinmodel, N, ry, plant, x_0, x̂_0, y_step=[0])
    U_data, Y_data, Ry_data = zeros(plant.nu, N), zeros(plant.ny, N), zeros(plant.ny, N)
    setstate!(plant, x_0)
    initstate!(mpc, [0], plant())
    setstate!(mpc, x̂_0)
    for i = 1:N
        y = plant() + y_step
        x̂ = preparestate!(mpc, y)
        u = moveinput!(mpc, ry)
        linmodel = linearize(nonlinmodel; u, x=x̂[1:2])
        setmodel!(mpc, linmodel)
        U_data[:,i], Y_data[:,i], Ry_data[:,i] = u, y, ry
        updatestate!(mpc, u, y) # update mpc state estimate
        updatestate!(plant, u)  # update plant simulator
    end
    res = SimResult(mpc, U_data, Y_data; Ry_data)
    return res
end</code></pre><p>The <a href="../../public/generic_func/#ModelPredictiveControl.setmodel!"><code>setmodel!</code></a> method must be called after solving the optimization problem with <a href="../../public/predictive_control/#ModelPredictiveControl.moveinput!"><code>moveinput!</code></a> and before updating the state estimate with <a href="../../public/generic_func/#ModelPredictiveControl.updatestate!"><code>updatestate!</code></a>, that is, when both <span>$\mathbf{u}(k)$</span> and <span>$\mathbf{x̂}_{k}(k)$</span> are available as the new operating point. The <a href="../../public/plot_sim/#ModelPredictiveControl.SimResult"><code>SimResult</code></a> object is for plotting purposes only. The adaptive <a href="../../public/predictive_control/#LinMPC"><code>LinMPC</code></a> performances are similar to the nonlinear MPC, both for the 180° setpoint:</p><pre><code class="language-julia hljs">x_0 = [0, 0]; x̂_0 = [0, 0, 0]; ry = [180]
res_slin = sim_adapt!(mpc3, model, N, ry, plant, x_0, x̂_0)
plot(res_slin)</code></pre><p><img src="../plot12_NonLinMPC.svg" alt="plot12_NonLinMPC"/></p><p>and the 10° step disturbance:</p><pre><code class="language-julia hljs">x_0 = [π, 0]; x̂_0 = [π, 0, 0]; y_step = [10]
res_slin = sim_adapt!(mpc3, model, N, ry, plant, x_0, x̂_0, y_step)
plot(res_slin)</code></pre><p><img src="../plot13_NonLinMPC.svg" alt="plot13_NonLinMPC"/></p><p>The computations of the successive linearization MPC are about 75 times faster than the nonlinear MPC on average, an impressive gain for similar closed-loop performances!</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Arnström, D., Bemporad, A., and Axehill, D. (2022). A dual active-set solver for embedded quadratic programming using recursive LDLᵀ updates. IEEE Trans. Autom. Contr., 67(8). <a href="https://doi.org/doi:10.1109/TAC.2022.3176430">https://doi.org/doi:10.1109/TAC.2022.3176430</a>.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../linmpc/">« Linear Design</a><a class="docs-footer-nextpage" href="../mtk/">ModelingToolkit »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Sunday 22 December 2024 21:44">Sunday 22 December 2024</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
