<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Predictive Controllers · ModelPredictiveControl.jl</title><meta name="title" content="Predictive Controllers · ModelPredictiveControl.jl"/><meta property="og:title" content="Predictive Controllers · ModelPredictiveControl.jl"/><meta property="twitter:title" content="Predictive Controllers · ModelPredictiveControl.jl"/><meta name="description" content="Documentation for ModelPredictiveControl.jl."/><meta property="og:description" content="Documentation for ModelPredictiveControl.jl."/><meta property="twitter:description" content="Documentation for ModelPredictiveControl.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="ModelPredictiveControl.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="ModelPredictiveControl.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelPredictiveControl.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/installation/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/linmpc/">Linear Design</a></li><li><a class="tocitem" href="../../manual/nonlinmpc/">Nonlinear Design</a></li><li><a class="tocitem" href="../../manual/mtk/">ModelingToolkit</a></li></ul></li></ul></li><li><span class="tocitem">Functions</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Public</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../public/sim_model/">Plant Models</a></li><li><a class="tocitem" href="../../public/state_estim/">State Estimators</a></li><li><a class="tocitem" href="../../public/predictive_control/">Predictive Controllers</a></li><li><a class="tocitem" href="../../public/generic_func/">Generic Functions</a></li><li><a class="tocitem" href="../../public/plot_sim/">Simulations and Plots</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox" checked/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../sim_model/">Plant Models</a></li><li><a class="tocitem" href="../state_estim/">State Estimators</a></li><li class="is-active"><a class="tocitem" href>Predictive Controllers</a><ul class="internal"><li><a class="tocitem" href="#Controller-Construction"><span>Controller Construction</span></a></li><li><a class="tocitem" href="#Update-Quadratic-Optimization"><span>Update Quadratic Optimization</span></a></li><li><a class="tocitem" href="#Solve-Optimization-Problem"><span>Solve Optimization Problem</span></a></li></ul></li></ul></li></ul></li><li><a class="tocitem" href="../../func_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functions</a></li><li><a class="is-disabled">Internals</a></li><li class="is-active"><a href>Predictive Controllers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Predictive Controllers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaControl/ModelPredictiveControl.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/main/docs/src/internals/predictive_control.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions:-PredictiveController-Internals"><a class="docs-heading-anchor" href="#Functions:-PredictiveController-Internals">Functions: PredictiveController Internals</a><a id="Functions:-PredictiveController-Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Functions:-PredictiveController-Internals" title="Permalink"></a></h1><ul><li><a href="#Functions:-PredictiveController-Internals">Functions: PredictiveController Internals</a></li><li class="no-marker"><ul><li><a href="#Controller-Construction">Controller Construction</a></li><li><a href="#Update-Quadratic-Optimization">Update Quadratic Optimization</a></li><li><a href="#Solve-Optimization-Problem">Solve Optimization Problem</a></li></ul></li></ul><p>The prediction methodology of this module is mainly based on Maciejowski textbook <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</p><h2 id="Controller-Construction"><a class="docs-heading-anchor" href="#Controller-Construction">Controller Construction</a><a id="Controller-Construction-1"></a><a class="docs-heading-anchor-permalink" href="#Controller-Construction" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.move_blocking" href="#ModelPredictiveControl.move_blocking"><code>ModelPredictiveControl.move_blocking</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">move_blocking(Hp::Int, Hc::Vector{Int}) -&gt; nb</code></pre><p>Get the move blocking vector <code>nb</code> from the <code>Hc</code> argument, and modify it to match <code>Hp</code>.</p><p>This feature is also known as manipulated variable blocking. The argument <code>Hc</code> is interpreted as the move blocking vector <code>nb</code>. It specifies the length of each step (or &quot;block&quot;) in the <span>$\mathbf{ΔU}$</span> vector, to customize the pattern (in time steps, thus strictly positive integers):</p><p class="math-container">\[    \mathbf{n_b} = \begin{bmatrix} n_1 &amp; n_2 &amp; \cdots &amp; n_{H_c} \end{bmatrix}&#39;\]</p><p>The vector that includes all the manipulated input increments <span>$\mathbf{Δu}$</span> is then defined as:</p><p class="math-container">\[\mathbf{ΔU} = \begin{bmatrix}
    \mathbf{Δu}(k + 0)                                  \\[0.1em]
    \mathbf{Δu}(k + ∑_{i=1}^1 n_i)                      \\[0.1em]
    \mathbf{Δu}(k + ∑_{i=1}^2 n_i)                      \\[0.1em]
    \vdots                                              \\[0.1em]
    \mathbf{Δu}(k + ∑_{i=1}^{H_c-1} n_i)   
\end{bmatrix}\]</p><p>The provided <code>nb</code> vector is modified to ensure <code>sum(nb) == Hp</code>:</p><ul><li>If <code>sum(nb) &lt; Hp</code>, a new element is pushed to <code>nb</code> with the value <code>Hp - sum(nb)</code>.</li><li>If <code>sum(nb) &gt; Hp</code>, the intervals are truncated until <code>sum(nb) == Hp</code>. For example, if <code>Hp = 10</code> and <code>nb = [1, 2, 3, 6, 7]</code>, then <code>nb</code> is truncated to <code>[1, 2, 3, 4]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/construct.jl#L460-L487">source</a></section><section><div><pre><code class="language-julia hljs">move_blocking(Hp::Int, Hc::Int) -&gt; nb</code></pre><p>Construct a move blocking vector <code>nb</code> that match the provided <code>Hp</code> and <code>Hc</code> integers.</p><p>The vector is filled with <code>1</code>s, except for the last element which is <code>Hp - Hc + 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/construct.jl#L505-L511">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.init_ZtoΔU" href="#ModelPredictiveControl.init_ZtoΔU"><code>ModelPredictiveControl.init_ZtoΔU</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_ZtoΔU(estim::StateEstimator, transcription::TranscriptionMethod, Hp, Hc) -&gt; PΔu</code></pre><p>Init decision variables to input increments over <span>$H_c$</span> conversion matrix <code>PΔu</code>.</p><p>The conversion from the decision variables <span>$\mathbf{Z}$</span> to <span>$\mathbf{ΔU}$</span>, the input increments over <span>$H_c$</span>, is computed by:</p><p class="math-container">\[\mathbf{ΔU} = \mathbf{P_{Δu}} \mathbf{Z}\]</p><p>in which <span>$\mathbf{P_{Δu}}$</span> is defined in the Extended Help section.</p><p><strong>Extended Help</strong></p><details class="admonition is-details" id="Extended-Help-51b4496d24a3cd50"><summary class="admonition-header">Extended Help<a class="admonition-anchor" href="#Extended-Help-51b4496d24a3cd50" title="Permalink"></a></summary><div class="admonition-body"><p>Following the decision variable definition of the <a href="../../public/predictive_control/#TranscriptionMethod"><code>TranscriptionMethod</code></a>, the conversion matrix <span>$\mathbf{P_{Δu}}$</span>, we have:</p><ul><li><span>$\mathbf{P_{Δu}} = \mathbf{I}$</span> if <code>transcription</code> is a <a href="../../public/predictive_control/#SingleShooting"><code>SingleShooting</code></a></li><li><span>$\mathbf{P_{Δu}} = [\begin{smallmatrix}\mathbf{I} &amp; \mathbf{0} \end{smallmatrix}]$</span> if <code>transcription</code> is a <a href="../../public/predictive_control/#MultipleShooting"><code>MultipleShooting</code></a></li></ul><p>The matrix is store as as <code>SparseMatrixCSC</code> to support both cases efficiently.</p></div></details></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/transcription.jl#L64-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.init_ZtoU" href="#ModelPredictiveControl.init_ZtoU"><code>ModelPredictiveControl.init_ZtoU</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_ZtoU(estim, transcription, Hp, Hc, nb) -&gt; Pu, Tu</code></pre><p>Init decision variables to inputs over <span>$H_p$</span> conversion matrices.</p><p>The conversion from the decision variables <span>$\mathbf{Z}$</span> to <span>$\mathbf{U}$</span>, the manipulated inputs over <span>$H_p$</span>, is computed by:</p><p class="math-container">\[\mathbf{U} = \mathbf{P_u} \mathbf{Z} + \mathbf{T_u} \mathbf{u}(k-1)\]</p><p>The <span>$\mathbf{P_u}$</span> and <span>$\mathbf{T_u}$</span> matrices are defined in the Extended Help section.</p><p><strong>Extended Help</strong></p><details class="admonition is-details" id="Extended-Help-13713cc06e5679f6"><summary class="admonition-header">Extended Help<a class="admonition-anchor" href="#Extended-Help-13713cc06e5679f6" title="Permalink"></a></summary><div class="admonition-body"><p>With <span>$n_i$</span>, the <span>$i$</span>th element of the <span>$\mathbf{n_b}$</span> vector defined in <a href="#ModelPredictiveControl.move_blocking"><code>move_blocking</code></a> documentation, we introduce the <span>$\mathbf{Q}(n_i)$</span> matrix of size <code>(nu*ni, nu)</code>:</p><p class="math-container">\[\mathbf{Q}(n_i) =       \begin{bmatrix}
    \mathbf{I}          \\
    \mathbf{I}          \\
    \vdots              \\
    \mathbf{I}          \end{bmatrix}            \]</p><p>The <span>$\mathbf{U}$</span> vector and the conversion matrices are defined as:</p><p class="math-container">\[\mathbf{U} = \begin{bmatrix}
    \mathbf{u}(k + 0)                                                                   \\
    \mathbf{u}(k + 1)                                                                   \\
    \vdots                                                                              \\
    \mathbf{u}(k + H_p - 1)                                                             \end{bmatrix} , \quad
\mathbf{P_u^†} = \begin{bmatrix}
    \mathbf{Q}(n_1)         &amp; \mathbf{0}            &amp; \cdots    &amp; \mathbf{0}            \\
    \mathbf{Q}(n_2)         &amp; \mathbf{Q}(n_2)       &amp; \cdots    &amp; \mathbf{0}            \\
    \vdots                  &amp; \vdots                &amp; \ddots    &amp; \vdots                \\
    \mathbf{Q}(n_{H_c})     &amp; \mathbf{Q}(n_{H_c})   &amp; \cdots    &amp; \mathbf{Q}(n_{H_c})   \end{bmatrix} , \quad
\mathbf{T_u} = \begin{bmatrix}
    \mathbf{I}                                                                          \\
    \mathbf{I}                                                                          \\
    \vdots                                                                              \\
    \mathbf{I}                                                                          \end{bmatrix}\]</p><p>and, depending on the transcription method, we have:</p><ul><li><span>$\mathbf{P_u} = \mathbf{P_u^†}$</span> if <code>transcription</code> is a <a href="../../public/predictive_control/#SingleShooting"><code>SingleShooting</code></a></li><li><span>$\mathbf{P_u} = [\begin{smallmatrix}\mathbf{P_u^†} &amp; \mathbf{0} \end{smallmatrix}]$</span> if <code>transcription</code> is a <a href="../../public/predictive_control/#MultipleShooting"><code>MultipleShooting</code></a></li></ul><p>The conversion matrices are stored as <code>SparseMatrixCSC</code> since it was benchmarked that it is generally more performant than normal dense matrices, even for small <code>nu</code>, <code>Hp</code> and  <code>Hc</code> values. Using <code>Bool</code> element type and <code>BitMatrix</code> is also slower.</p></div></details></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/transcription.jl#L103-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.init_predmat" href="#ModelPredictiveControl.init_predmat"><code>ModelPredictiveControl.init_predmat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_predmat(
    model::LinModel, estim, transcription::SingleShooting, Hp, Hc
) -&gt; E, G, J, K, V, ex̂, gx̂, jx̂, kx̂, vx̂</code></pre><p>Construct the prediction matrices for <a href="../../public/sim_model/#LinModel"><code>LinModel</code></a> and <a href="../../public/predictive_control/#SingleShooting"><code>SingleShooting</code></a>.</p><p>The model predictions are evaluated from the deviation vectors (see <a href="../../public/sim_model/#ModelPredictiveControl.setop!"><code>setop!</code></a>), the decision variable <span>$\mathbf{Z}$</span> (see <a href="../../public/predictive_control/#TranscriptionMethod"><code>TranscriptionMethod</code></a>), and:</p><p class="math-container">\[\begin{aligned}
    \mathbf{Ŷ_0} &amp;= \mathbf{E Z} + \mathbf{G d_0}(k) + \mathbf{J D̂_0} 
                                 + \mathbf{K x̂_0}(k) + \mathbf{V u_0}(k-1) 
                                 + \mathbf{B}        + \mathbf{Ŷ_s}                      \\
                 &amp;= \mathbf{E Z} + \mathbf{F}
\end{aligned}\]</p><p>in which <span>$\mathbf{x̂_0}(k) = \mathbf{x̂}_i(k) - \mathbf{x̂_{op}}$</span>, with <span>$i = k$</span> if  <code>estim.direct==true</code>, otherwise <span>$i = k - 1$</span>. The predicted outputs <span>$\mathbf{Ŷ_0}$</span> and measured disturbances <span>$\mathbf{D̂_0}$</span> respectively include <span>$\mathbf{ŷ_0}(k+j)$</span> and  <span>$\mathbf{d̂_0}(k+j)$</span> values with <span>$j=1$</span> to <span>$H_p$</span>, and input increments <span>$\mathbf{ΔU}$</span>, <span>$\mathbf{Δu}(k+j)$</span> from <span>$j=0$</span> to <span>$H_c-1$</span>. The vector <span>$\mathbf{B}$</span> contains the contribution for non-zero state <span>$\mathbf{x̂_{op}}$</span> and state update <span>$\mathbf{f̂_{op}}$</span> operating points (for linearization at non-equilibrium point, see <a href="../../public/sim_model/#ModelPredictiveControl.linearize"><code>linearize</code></a>). The stochastic predictions <span>$\mathbf{Ŷ_s=0}$</span> if <code>estim</code> is not a <a href="../../public/state_estim/#InternalModel"><code>InternalModel</code></a>, see <a href="#ModelPredictiveControl.init_stochpred"><code>init_stochpred</code></a>. The method also computes similar matrices for the predicted terminal state at <span>$k+H_p$</span>:</p><p class="math-container">\[\begin{aligned}
    \mathbf{x̂_0}(k+H_p) &amp;= \mathbf{e_x̂ Z}  + \mathbf{g_x̂ d_0}(k)   + \mathbf{j_x̂ D̂_0} 
                                           + \mathbf{k_x̂ x̂_0}(k) + \mathbf{v_x̂ u_0}(k-1)
                                           + \mathbf{b_x̂}                                 \\
                        &amp;= \mathbf{e_x̂ Z}  + \mathbf{f_x̂}
\end{aligned}\]</p><p>The matrices <span>$\mathbf{E, G, J, K, V, B, e_x̂, g_x̂, j_x̂, k_x̂, v_x̂, b_x̂}$</span> are defined in the Extended Help section. The <span>$\mathbf{F}$</span> and <span>$\mathbf{f_x̂}$</span> vectors are  recalculated at each control period <span>$k$</span>, see <a href="#ModelPredictiveControl.initpred!-Tuple{PredictiveController, LinModel, Vararg{Any, 4}}"><code>initpred!</code></a> and <a href="#ModelPredictiveControl.linconstraint!-Tuple{PredictiveController, LinModel, TranscriptionMethod}"><code>linconstraint!</code></a>.</p><p><strong>Extended Help</strong></p><details class="admonition is-details" id="Extended-Help-c21fd96099ff2739"><summary class="admonition-header">Extended Help<a class="admonition-anchor" href="#Extended-Help-c21fd96099ff2739" title="Permalink"></a></summary><div class="admonition-body"><p>Using the augmented matrices <span>$\mathbf{Â, B̂_u, Ĉ, B̂_d, D̂_d}$</span> in <code>estim</code> (see  <a href="../state_estim/#ModelPredictiveControl.augment_model"><code>augment_model</code></a>), and the function <span>$\mathbf{W}(j) = ∑_{i=0}^j \mathbf{Â}^i$</span>, the prediction matrices are computed by :</p><p class="math-container">\[\begin{aligned}
\mathbf{E} &amp;= \begin{bmatrix}
    \mathbf{Ĉ W}(0)\mathbf{B̂_u}     &amp; \mathbf{0}                      &amp; \cdots &amp; \mathbf{0}                                        \\
    \mathbf{Ĉ W}(1)\mathbf{B̂_u}     &amp; \mathbf{Ĉ W}(0)\mathbf{B̂_u}     &amp; \cdots &amp; \mathbf{0}                                        \\
    \vdots                          &amp; \vdots                          &amp; \ddots &amp; \vdots                                            \\
    \mathbf{Ĉ W}(H_p-1)\mathbf{B̂_u} &amp; \mathbf{Ĉ W}(H_p-2)\mathbf{B̂_u} &amp; \cdots &amp; \mathbf{Ĉ W}(H_p-H_c+1)\mathbf{B̂_u} \end{bmatrix} \\
\mathbf{G} &amp;= \begin{bmatrix}
    \mathbf{Ĉ}\mathbf{Â}^{0} \mathbf{B̂_d}     \\ 
    \mathbf{Ĉ}\mathbf{Â}^{1} \mathbf{B̂_d}     \\ 
    \vdots                                    \\
    \mathbf{Ĉ}\mathbf{Â}^{H_p-1} \mathbf{B̂_d} \end{bmatrix} \\
\mathbf{J} &amp;= \begin{bmatrix}
    \mathbf{D̂_d}                              &amp; \mathbf{0}                                &amp; \cdots &amp; \mathbf{0}   \\ 
    \mathbf{Ĉ}\mathbf{Â}^{0} \mathbf{B̂_d}     &amp; \mathbf{D̂_d}                              &amp; \cdots &amp; \mathbf{0}   \\ 
    \vdots                                    &amp; \vdots                                    &amp; \ddots &amp; \vdots       \\
    \mathbf{Ĉ}\mathbf{Â}^{H_p-2} \mathbf{B̂_d} &amp; \mathbf{Ĉ}\mathbf{Â}^{H_p-3} \mathbf{B̂_d} &amp; \cdots &amp; \mathbf{D̂_d} \end{bmatrix} \\
\mathbf{K} &amp;= \begin{bmatrix}
    \mathbf{Ĉ}\mathbf{Â}^{1}        \\
    \mathbf{Ĉ}\mathbf{Â}^{2}        \\
    \vdots                          \\
    \mathbf{Ĉ}\mathbf{Â}^{H_p}      \end{bmatrix} \\
\mathbf{V} &amp;= \begin{bmatrix}
    \mathbf{Ĉ W}(0)\mathbf{B̂_u}     \\
    \mathbf{Ĉ W}(1)\mathbf{B̂_u}     \\
    \vdots                          \\
    \mathbf{Ĉ W}(H_p-1)\mathbf{B̂_u} \end{bmatrix} \\
\mathbf{B} &amp;= \begin{bmatrix}
    \mathbf{Ĉ W}(0)                 \\
    \mathbf{Ĉ W}(1)                 \\
    \vdots                          \\
    \mathbf{Ĉ W}(H_p-1)             \end{bmatrix}   \mathbf{\big(f̂_{op} - x̂_{op}\big)} 
\end{aligned}\]</p><p>For the terminal constraints, the matrices are computed with:</p><p class="math-container">\[\begin{aligned}
\mathbf{e_x̂} &amp;= \begin{bmatrix} 
                    \mathbf{W}(H_p-1)\mathbf{B̂_u} &amp; 
                    \mathbf{W}(H_p-2)\mathbf{B̂_u} &amp; 
                    \cdots &amp; 
                    \mathbf{W}(H_p-H_c+1)\mathbf{B̂_u} \end{bmatrix} \\
\mathbf{g_x̂} &amp;= \mathbf{Â}^{H_p-1} \mathbf{B̂_d} \\
\mathbf{j_x̂} &amp;= \begin{bmatrix} 
                    \mathbf{Â}^{H_p-2} \mathbf{B̂_d} &amp; 
                    \mathbf{Â}^{H_p-3} \mathbf{B̂_d} &amp; 
                    \cdots &amp; 
                    \mathbf{0} 
                \end{bmatrix} \\
\mathbf{k_x̂} &amp;= \mathbf{Â}^{H_p} \\
\mathbf{v_x̂} &amp;= \mathbf{W}(H_p-1)\mathbf{B̂_u} \\
\mathbf{b_x̂} &amp;= \mathbf{W}(H_p-1)    \mathbf{\big(f̂_{op} - x̂_{op}\big)}
\end{aligned}\]</p></div></details></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/transcription.jl#L177-L275">source</a></section><section><div><pre><code class="language-julia hljs">init_predmat(
    model::LinModel, estim, transcription::MultipleShooting, Hp, Hc
) -&gt; E, G, J, K, V, B, ex̂, gx̂, jx̂, kx̂, vx̂, bx̂</code></pre><p>Construct the prediction matrices for <a href="../../public/sim_model/#LinModel"><code>LinModel</code></a> and <a href="../../public/predictive_control/#MultipleShooting"><code>MultipleShooting</code></a>.</p><p>They are defined in the Extended Help section.</p><p><strong>Extended Help</strong></p><details class="admonition is-details" id="Extended-Help-f3aea574da8051b1"><summary class="admonition-header">Extended Help<a class="admonition-anchor" href="#Extended-Help-f3aea574da8051b1" title="Permalink"></a></summary><div class="admonition-body"><p>They are all appropriately sized zero matrices <span>$\mathbf{0}$</span>, except for:</p><p class="math-container">\[\begin{aligned}
\mathbf{E}   &amp;= [\begin{smallmatrix}\mathbf{0} &amp; \mathbf{E^†} \end{smallmatrix}]    \\
\mathbf{E^†} &amp;= \text{diag}\mathbf{(Ĉ,Ĉ,...,Ĉ)}                                     \\
\mathbf{J}   &amp;= \text{diag}\mathbf{(D̂_d,D̂_d,...,D̂_d)}                               \\
\mathbf{e_x̂} &amp;= [\begin{smallmatrix}\mathbf{0} &amp; \mathbf{I}\end{smallmatrix}]   
\end{aligned}\]</p></div></details></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/transcription.jl#L346-L366">source</a></section><section><div><pre><code class="language-julia hljs">init_predmat(model::SimModel, estim, transcription::MultipleShooting, Hp, Hc)</code></pre><p>Return the terminal state matrices for <a href="../../public/sim_model/#SimModel"><code>SimModel</code></a> and <a href="../../public/predictive_control/#MultipleShooting"><code>MultipleShooting</code></a>.</p><p>The output prediction matrices are all empty matrices. The terminal state matrices are given in the Extended Help section.</p><p><strong>Extended Help</strong></p><details class="admonition is-details" id="Extended-Help-5911477446f1728d"><summary class="admonition-header">Extended Help<a class="admonition-anchor" href="#Extended-Help-5911477446f1728d" title="Permalink"></a></summary><div class="admonition-body"><p>The terminal state matrices all appropriately sized zero matrices <span>$\mathbf{0}$</span>, except for <span>$\mathbf{e_x̂} = [\begin{smallmatrix}\mathbf{0} &amp; \mathbf{I}\end{smallmatrix}]$</span></p></div></details></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/transcription.jl#L392-L404">source</a></section><section><div><pre><code class="language-julia hljs">init_predmat(model::SimModel, estim, transcription::TranscriptionMethod, Hp, Hc)</code></pre><p>Return empty matrices for all other cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/transcription.jl#L425-L429">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.init_defectmat" href="#ModelPredictiveControl.init_defectmat"><code>ModelPredictiveControl.init_defectmat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_defectmat(model::LinModel, estim, transcription::MultipleShooting, Hp, Hc)</code></pre><p>Init the matrices for computing the defects over the predicted states. </p><p>An equation similar to the prediction matrices (see  <a href="#ModelPredictiveControl.init_predmat"><code>init_predmat</code></a>) computes the defects over the predicted states:</p><p class="math-container">\[\begin{aligned}
    \mathbf{Ŝ} &amp;= \mathbf{E_ŝ Z} + \mathbf{G_ŝ d_0}(k)  + \mathbf{J_ŝ D̂_0} 
                                 + \mathbf{K_ŝ x̂_0}(k)  + \mathbf{V_ŝ u_0}(k-1) 
                                 + \mathbf{B_ŝ}                                         \\
               &amp;= \mathbf{E_ŝ Z} + \mathbf{F_ŝ}
\end{aligned}\]</p><p>They are forced to be <span>$\mathbf{Ŝ = 0}$</span> using the optimization equality constraints. The matrices <span>$\mathbf{E_ŝ, G_ŝ, J_ŝ, K_ŝ, V_ŝ, B_ŝ}$</span> are defined in the Extended Help section.</p><p><strong>Extended Help</strong></p><details class="admonition is-details" id="Extended-Help-b706019f483508a8"><summary class="admonition-header">Extended Help<a class="admonition-anchor" href="#Extended-Help-b706019f483508a8" title="Permalink"></a></summary><div class="admonition-body"><p>The matrices are computed by:</p><p class="math-container">\[\begin{aligned}
\mathbf{E_ŝ} &amp;= \begin{bmatrix}
    \mathbf{B̂_u} &amp; \mathbf{0}   &amp; \cdots &amp; \mathbf{0}   &amp; -\mathbf{I} &amp;  \mathbf{0} &amp; \cdots &amp;  \mathbf{0}  &amp;  \mathbf{0}      \\
    \mathbf{B̂_u} &amp; \mathbf{B̂_u} &amp; \cdots &amp; \mathbf{0}   &amp;  \mathbf{Â} &amp; -\mathbf{I} &amp; \cdots &amp;  \mathbf{0}  &amp;  \mathbf{0}      \\
    \vdots       &amp; \vdots       &amp; \ddots &amp; \vdots       &amp;  \vdots     &amp;  \vdots     &amp; \ddots &amp;  \vdots      &amp;  \vdots          \\
    \mathbf{B̂_u} &amp; \mathbf{B̂_u} &amp; \cdots &amp; \mathbf{B̂_u} &amp;  \mathbf{0} &amp;  \mathbf{0} &amp; \cdots &amp;  \mathbf{Â}  &amp; -\mathbf{I}      \end{bmatrix} \\
\mathbf{G_ŝ} &amp;= \begin{bmatrix}
    \mathbf{B̂_d} \\ \mathbf{0} \\ \vdots \\ \mathbf{0}                                                          \end{bmatrix} \\
\mathbf{J_ŝ} &amp;= \begin{bmatrix}
    \mathbf{0}   &amp; \mathbf{0}   &amp; \cdots &amp; \mathbf{0}   &amp; \mathbf{0}                                            \\
    \mathbf{B̂_d} &amp; \mathbf{0}   &amp; \cdots &amp; \mathbf{0}   &amp; \mathbf{0}                                            \\
    \vdots       &amp; \vdots       &amp; \ddots &amp; \vdots       &amp; \vdots                                                \\
    \mathbf{0}   &amp; \mathbf{0}   &amp; \cdots &amp; \mathbf{B̂_d} &amp; \mathbf{0}                                            \end{bmatrix} \\
\mathbf{K_ŝ} &amp;= \begin{bmatrix}
    \mathbf{Â} \\ \mathbf{0} \\ \vdots \\ \mathbf{0}                                                            \end{bmatrix} \\
\mathbf{V_ŝ} &amp;= \begin{bmatrix}
    \mathbf{B̂_u} \\ \mathbf{B̂_u} \\ \vdots \\ \mathbf{B̂_u}                                                      \end{bmatrix} \\
\mathbf{B_ŝ} &amp;= \begin{bmatrix}
    \mathbf{f̂_{op} - x̂_{op}} \\ \mathbf{f̂_{op} - x̂_{op}} \\ \vdots \\ \mathbf{f̂_{op} - x̂_{op}}                  \end{bmatrix}
\end{aligned}\]</p></div></details></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/transcription.jl#L445-L488">source</a></section><section><div><pre><code class="language-julia hljs">init_defectmat(model::SimModel, estim, transcription::TranscriptionMethod, Hp, Hc)</code></pre><p>Return empty matrices for all other cases (N/A).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/transcription.jl#L519-L523">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.relaxU" href="#ModelPredictiveControl.relaxU"><code>ModelPredictiveControl.relaxU</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">relaxU(Pu, C_umin, C_umax, nϵ) -&gt; A_Umin, A_Umax, P̃u</code></pre><p>Augment manipulated inputs constraints with slack variable ϵ for softening.</p><p>Denoting the decision variables augmented with the slack variable <span>$\mathbf{Z̃} = [\begin{smallmatrix} \mathbf{Z} \\ ϵ \end{smallmatrix}]$</span>, it returns the augmented conversion matrix <span>$\mathbf{P̃_u}$</span>, similar to the one described at <a href="#ModelPredictiveControl.init_ZtoU"><code>init_ZtoU</code></a>. It also returns the <span>$\mathbf{A}$</span> matrices for the inequality constraints:</p><p class="math-container">\[\begin{bmatrix} 
    \mathbf{A_{U_{min}}} \\ 
    \mathbf{A_{U_{max}}} 
\end{bmatrix} \mathbf{Z̃} ≤
\begin{bmatrix}
    - \mathbf{U_{min} + T_u u}(k-1) \\
    + \mathbf{U_{max} - T_u u}(k-1)
\end{bmatrix}\]</p><p>in which <span>$\mathbf{U_{min}}$</span> and <span>$\mathbf{U_{max}}$</span> vectors respectively contains <span>$\mathbf{u_{min}}$</span> and <span>$\mathbf{u_{max}}$</span> repeated <span>$H_p$</span> times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/construct.jl#L655-L677">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.relaxΔU" href="#ModelPredictiveControl.relaxΔU"><code>ModelPredictiveControl.relaxΔU</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">relaxΔU(PΔu, C_Δumin, C_Δumax, ΔUmin, ΔUmax, nϵ) -&gt; A_ΔŨmin, A_ΔŨmax, ΔŨmin, ΔŨmax, P̃Δu</code></pre><p>Augment input increments constraints with slack variable ϵ for softening.</p><p>Denoting the decision variables augmented with the slack variable  <span>$\mathbf{Z̃} = [\begin{smallmatrix} \mathbf{Z} \\ ϵ \end{smallmatrix}]$</span>, it returns the augmented conversion matrix <span>$\mathbf{P̃_{Δu}}$</span>, similar to the one described at <a href="#ModelPredictiveControl.init_ZtoΔU"><code>init_ZtoΔU</code></a>, but extracting the input increments augmented with the slack variable <span>$\mathbf{ΔŨ} = [\begin{smallmatrix} \mathbf{ΔU} \\ ϵ \end{smallmatrix}] = \mathbf{P̃_{Δu} Z̃}$</span>. Also, knowing that <span>$0 ≤ ϵ ≤ ∞$</span>, it also returns the augmented bounds  <span>$\mathbf{ΔŨ_{min}} = [\begin{smallmatrix} \mathbf{ΔU_{min}} \\ 0 \end{smallmatrix}]$</span> and <span>$\mathbf{ΔŨ_{max}} = [\begin{smallmatrix} \mathbf{ΔU_{min}} \\ ∞ \end{smallmatrix}]$</span>, and the <span>$\mathbf{A}$</span> matrices for the inequality constraints:</p><p class="math-container">\[\begin{bmatrix} 
    \mathbf{A_{ΔŨ_{min}}} \\ 
    \mathbf{A_{ΔŨ_{max}}}
\end{bmatrix} \mathbf{Z̃} ≤
\begin{bmatrix}
    - \mathbf{ΔŨ_{min}} \\
    + \mathbf{ΔŨ_{max}}
\end{bmatrix}\]</p><p>Note that strictly speaking, the lower bound on the slack variable ϵ is a decision variable bound, which is more precise than a linear inequality constraint. However, it is more convenient to treat it as a linear inequality constraint since the optimizer <code>OSQP.jl</code> does not support pure bounds on the decision variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/construct.jl#L691-L719">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.relaxŶ" href="#ModelPredictiveControl.relaxŶ"><code>ModelPredictiveControl.relaxŶ</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">relaxŶ(E, C_ymin, C_ymax, nϵ) -&gt; A_Ymin, A_Ymax, Ẽ</code></pre><p>Augment linear output prediction constraints with slack variable ϵ for softening.</p><p>Denoting the decision variables augmented with the slack variable  <span>$\mathbf{Z̃} = [\begin{smallmatrix} \mathbf{Z} \\ ϵ \end{smallmatrix}]$</span>, it returns the  <span>$\mathbf{Ẽ}$</span> matrix that appears in the linear model prediction equation  <span>$\mathbf{Ŷ_0 = Ẽ Z̃ + F}$</span>, and the <span>$\mathbf{A}$</span> matrices for the inequality constraints:</p><p class="math-container">\[\begin{bmatrix} 
    \mathbf{A_{Y_{min}}} \\ 
    \mathbf{A_{Y_{max}}}
\end{bmatrix} \mathbf{Z̃} ≤
\begin{bmatrix}
    - \mathbf{(Y_{min} - Y_{op}) + F} \\
    + \mathbf{(Y_{max} - Y_{op}) - F} 
\end{bmatrix}\]</p><p>in which <span>$\mathbf{Y_{min}, Y_{max}}$</span> and <span>$\mathbf{Y_{op}}$</span> vectors respectively contains <span>$\mathbf{y_{min}, y_{max}}$</span> and <span>$\mathbf{y_{op}}$</span> repeated <span>$H_p$</span> times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/construct.jl#L735-L756">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.relaxterminal" href="#ModelPredictiveControl.relaxterminal"><code>ModelPredictiveControl.relaxterminal</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">relaxterminal(ex̂, c_x̂min, c_x̂max, nϵ) -&gt; A_x̂min, A_x̂max, ẽx̂</code></pre><p>Augment terminal state constraints with slack variable ϵ for softening.</p><p>Denoting the decision variables augmented with the slack variable  <span>$\mathbf{Z̃} = [\begin{smallmatrix} \mathbf{Z} \\ ϵ \end{smallmatrix}]$</span>, it returns the  <span>$\mathbf{ẽ_{x̂}}$</span> matrix that appears in the terminal state equation  <span>$\mathbf{x̂_0}(k + H_p) = \mathbf{ẽ_x̂ Z̃ + f_x̂}$</span>, and the <span>$\mathbf{A}$</span> matrices for  the inequality constraints:</p><p class="math-container">\[\begin{bmatrix} 
    \mathbf{A_{x̂_{min}}} \\ 
    \mathbf{A_{x̂_{max}}}
\end{bmatrix} \mathbf{Z̃} ≤
\begin{bmatrix}
    - \mathbf{(x̂_{min} - x̂_{op}) + f_x̂} \\
    + \mathbf{(x̂_{max} - x̂_{op}) - f_x̂}
\end{bmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/construct.jl#L774-L794">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.init_quadprog" href="#ModelPredictiveControl.init_quadprog"><code>ModelPredictiveControl.init_quadprog</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_quadprog(model::LinModel, weights::ControllerWeights, Ẽ, P̃Δu, P̃u) -&gt; H̃</code></pre><p>Init the quadratic programming Hessian <code>H̃</code> for MPC.</p><p>The matrix appear in the quadratic general form:</p><p class="math-container">\[    J = \min_{\mathbf{Z̃}} \frac{1}{2}\mathbf{Z̃&#39; H̃ Z̃} + \mathbf{q̃&#39; Z̃} + r \]</p><p>The Hessian matrix is constant if the model and weights are linear and time invariant (LTI): </p><p class="math-container">\[    \mathbf{H̃} = 2 (   \mathbf{Ẽ&#39;}      \mathbf{M}_{H_p} \mathbf{Ẽ} 
                     + \mathbf{P̃_{Δu}&#39;} \mathbf{Ñ}_{H_c} \mathbf{P̃_{Δu}} 
                     + \mathbf{P̃_{u}&#39;}  \mathbf{L}_{H_p} \mathbf{P̃_{u}}     )\]</p><p>in which <span>$\mathbf{Ẽ}$</span>, <span>$\mathbf{P̃_{Δu}}$</span> and <span>$\mathbf{P̃_{u}}$</span> matrices are defined at <a href="#ModelPredictiveControl.relaxŶ"><code>relaxŶ</code></a>, <a href="#ModelPredictiveControl.relaxΔU"><code>relaxΔU</code></a> and <a href="#ModelPredictiveControl.relaxU"><code>relaxU</code></a> documentation, respectively. The vector <span>$\mathbf{q̃}$</span> and scalar <span>$r$</span> need recalculation each control period <span>$k$</span>, see <a href="#ModelPredictiveControl.initpred!-Tuple{PredictiveController, LinModel, Vararg{Any, 4}}"><code>initpred!</code></a>. <span>$r$</span> does not impact the minima position. It is thus useless at optimization but required to evaluate the minimal <span>$J$</span> value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/construct.jl#L539-L559">source</a></section><section><div><p>Return empty matrix if <code>model</code> is not a <a href="../../public/sim_model/#LinModel"><code>LinModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/construct.jl#L565">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.init_stochpred" href="#ModelPredictiveControl.init_stochpred"><code>ModelPredictiveControl.init_stochpred</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_stochpred(estim::InternalModel, Hp) -&gt; Ks, Ps</code></pre><p>Init the stochastic prediction matrices for <a href="../../public/state_estim/#InternalModel"><code>InternalModel</code></a>.</p><p><code>Ks</code> and <code>Ps</code> matrices are defined as:</p><p class="math-container">\[    \mathbf{Ŷ_s} = \mathbf{K_s x̂_s}(k) + \mathbf{P_s ŷ_s}(k)\]</p><p>Current stochastic outputs <span>$\mathbf{ŷ_s}(k)$</span> comprises the measured outputs  <span>$\mathbf{ŷ_s^m}(k) = \mathbf{y^m}(k) - \mathbf{ŷ_d^m}(k)$</span> and unmeasured  <span>$\mathbf{ŷ_s^u}(k) = \mathbf{0}$</span>. See <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/construct.jl#L834-L851">source</a></section><section><div><p>Return empty matrices if <code>estim</code> is not a <a href="../../public/state_estim/#InternalModel"><code>InternalModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/construct.jl#L867">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.init_matconstraint_mpc" href="#ModelPredictiveControl.init_matconstraint_mpc"><code>ModelPredictiveControl.init_matconstraint_mpc</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_matconstraint_mpc(
    model::LinModel, transcription::TranscriptionMethod, nc::Int,
    i_Umin, i_Umax, i_ΔŨmin, i_ΔŨmax, i_Ymin, i_Ymax, i_x̂min, i_x̂max, 
    args...
) -&gt; i_b, i_g, A, Aeq, neq</code></pre><p>Init <code>i_b</code>, <code>i_g</code>, <code>neq</code>, and <code>A</code> and <code>Aeq</code> matrices for the all the MPC constraints.</p><p>The linear and nonlinear constraints are respectively defined as:</p><p class="math-container">\[\begin{aligned} 
    \mathbf{A Z̃ }       &amp;≤ \mathbf{b}           \\ 
    \mathbf{A_{eq} Z̃}   &amp;= \mathbf{b_{eq}}      \\
    \mathbf{g(Z̃)}       &amp;≤ \mathbf{0}           \\
    \mathbf{g_{eq}(Z̃)}  &amp;= \mathbf{0}           \\
\end{aligned}\]</p><p>The argument <code>nc</code> is the number of custom nonlinear inequality constraints in <span>$\mathbf{g_c}$</span>. <code>i_b</code> is a <code>BitVector</code> including the indices of <span>$\mathbf{b}$</span> that are finite numbers. <code>i_g</code> is a similar vector but for the indices of <span>$\mathbf{g}$</span>. The method also returns the <span>$\mathbf{A, A_{eq}}$</span> matrices and <code>neq</code> if <code>args</code> is provided. In such a  case, <code>args</code>  needs to contain all the inequality and equality constraint matrices:  <code>A_Umin, A_Umax, A_ΔŨmin, A_ΔŨmax, A_Ymin, A_Ymax, A_x̂min, A_x̂max, A_ŝ</code>. The integer <code>neq</code> is the number of nonlinear equality constraints in <span>$\mathbf{g_{eq}}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/transcription.jl#L538-L563">source</a></section><section><div><p>Init <code>i_b</code> without output constraints if <code>NonLinModel</code> and not <code>SingleShooting</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/transcription.jl#L582">source</a></section><section><div><p>Init <code>i_b</code> without output &amp; terminal constraints if <code>NonLinModel</code> and <code>SingleShooting</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/transcription.jl#L602">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.init_nonlincon!" href="#ModelPredictiveControl.init_nonlincon!"><code>ModelPredictiveControl.init_nonlincon!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_nonlincon!(
    mpc::PredictiveController, model::LinModel, transcription::TranscriptionMethod, 
    gfuncs  , ∇gfuncs!,   
    geqfuncs, ∇geqfuncs!
)</code></pre><p>Init nonlinear constraints for <a href="../../public/sim_model/#LinModel"><code>LinModel</code></a> for all <a href="../../public/predictive_control/#TranscriptionMethod"><code>TranscriptionMethod</code></a>.</p><p>The only nonlinear constraints are the custom inequality constraints <code>gc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/transcription.jl#L621-L631">source</a></section><section><div><pre><code class="language-julia hljs">init_nonlincon!(
    mpc::PredictiveController, model::NonLinModel, transcription::MultipleShooting, 
    gfuncs,   ∇gfuncs!,
    geqfuncs, ∇geqfuncs!
)</code></pre><p>Init nonlinear constraints for <a href="../../public/sim_model/#NonLinModel"><code>NonLinModel</code></a> and <a href="../../public/predictive_control/#MultipleShooting"><code>MultipleShooting</code></a>.</p><p>The nonlinear constraints are the output prediction <code>Ŷ</code> bounds, the custom inequality constraints <code>gc</code> and all the nonlinear equality constraints <code>geq</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/transcription.jl#L651-L662">source</a></section><section><div><pre><code class="language-julia hljs">init_nonlincon!(
    mpc::PredictiveController, model::NonLinModel, ::SingleShooting, 
    gfuncs,   ∇gfuncs!,
    geqfuncs, ∇geqfuncs!
)</code></pre><p>Init nonlinear constraints for <a href="../../public/sim_model/#NonLinModel"><code>NonLinModel</code></a> and <a href="../../public/predictive_control/#SingleShooting"><code>SingleShooting</code></a>.</p><p>The nonlinear constraints are the custom inequality constraints <code>gc</code>, the output prediction <code>Ŷ</code> bounds and the terminal state <code>x̂end</code> bounds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/transcription.jl#L708-L719">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.get_optim_functions-Tuple{NonLinMPC, JuMP.GenericModel}" href="#ModelPredictiveControl.get_optim_functions-Tuple{NonLinMPC, JuMP.GenericModel}"><code>ModelPredictiveControl.get_optim_functions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_optim_functions(
    mpc::NonLinMPC, optim::JuMP.GenericModel
) -&gt; Jfunc, ∇Jfunc!, gfuncs, ∇gfuncs!, geqfuncs, ∇geqfuncs!</code></pre><p>Return the functions for the nonlinear optimization of <code>mpc</code> <a href="../../public/predictive_control/#NonLinMPC"><code>NonLinMPC</code></a> controller.</p><p>Return the nonlinear objective <code>Jfunc</code> function, and <code>∇Jfunc!</code>, to compute its gradient.  Also return vectors with the nonlinear inequality constraint functions <code>gfuncs</code>, and  <code>∇gfuncs!</code>, for the associated gradients. Lastly, also return vectors with the nonlinear  equality constraint functions <code>geqfuncs</code> and gradients <code>∇geqfuncs!</code>.</p><p>This method is really intricate and I&#39;m not proud of it. That&#39;s because of 3 elements:</p><ul><li>These functions are used inside the nonlinear optimization, so they must be type-stable and as efficient as possible. All the function outputs and derivatives are cached and updated in-place if required to use the efficient <a href="https://juliadiff.org/DifferentiationInterface.jl/DifferentiationInterface/stable/api/#DifferentiationInterface.value_and_jacobian%21"><code>value_and_jacobian!</code></a>.</li><li>The <code>JuMP</code> NLP syntax forces splatting for the decision variable, which implies use of <code>Vararg{T,N}</code> (see the (performance tip)[@extref Julia Be-aware-of-when-Julia-avoids-specializing] ) and memoization to avoid redundant computations. This is already complex, but it&#39;s even worse knowing that most automatic differentiation tools do not support splatting.</li><li>The signature of gradient and hessian functions is not the same for univariate (<code>nZ̃ == 1</code>) and multivariate (<code>nZ̃ &gt; 1</code>) operators in <code>JuMP</code>. Both must be defined.</li></ul><p>Inspired from: <a href="https://jump.dev/JuMP.jl/stable/tutorials/nonlinear/tips_and_tricks/#User-defined-operators-with-vector-outputs">User-defined operators with vector outputs</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/nonlinmpc.jl#L535-L560">source</a></section></article><h2 id="Update-Quadratic-Optimization"><a class="docs-heading-anchor" href="#Update-Quadratic-Optimization">Update Quadratic Optimization</a><a id="Update-Quadratic-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Update-Quadratic-Optimization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.initpred!-Tuple{PredictiveController, LinModel, Vararg{Any, 4}}" href="#ModelPredictiveControl.initpred!-Tuple{PredictiveController, LinModel, Vararg{Any, 4}}"><code>ModelPredictiveControl.initpred!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initpred!(mpc::PredictiveController, model::LinModel, d, D̂, R̂y, R̂u) -&gt; nothing</code></pre><p>Init linear model prediction matrices <code>F, q̃, r</code> and current estimated output <code>ŷ</code>.</p><p>See <a href="#ModelPredictiveControl.init_predmat"><code>init_predmat</code></a> and <a href="#ModelPredictiveControl.init_quadprog"><code>init_quadprog</code></a> for the definition of the matrices. They are computed with these equations using in-place operations:</p><p class="math-container">\[\begin{aligned}
    \mathbf{F}       &amp;= \mathbf{G d_0}(k) + \mathbf{J D̂_0} + \mathbf{K x̂_0}(k) 
                            + \mathbf{V u_0}(k-1) + \mathbf{B} + \mathbf{Ŷ_s}           \\
    \mathbf{C_y}     &amp;= \mathbf{F} + \mathbf{Y_{op}} - \mathbf{R̂_y}                     \\
    \mathbf{C_u}     &amp;= \mathbf{T_u}\mathbf{u}(k-1)  - \mathbf{R̂_u}                     \\
    \mathbf{q̃}       &amp;= 2[    (\mathbf{M}_{H_p} \mathbf{Ẽ})&#39;   \mathbf{C_y} 
                            + (\mathbf{L}_{H_p} \mathbf{P̃_U})&#39; \mathbf{C_u}   ]         \\
    r                &amp;=     \mathbf{C_y&#39;}  \mathbf{M}_{H_p} \mathbf{C_y} 
                          + \mathbf{C_u&#39;}  \mathbf{L}_{H_p} \mathbf{C_u}
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/execute.jl#L191-L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.linconstraint!-Tuple{PredictiveController, LinModel, TranscriptionMethod}" href="#ModelPredictiveControl.linconstraint!-Tuple{PredictiveController, LinModel, TranscriptionMethod}"><code>ModelPredictiveControl.linconstraint!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linconstraint!(mpc::PredictiveController, model::LinModel)</code></pre><p>Set <code>b</code> vector for the linear model inequality constraints (<span>$\mathbf{A Z̃ ≤ b}$</span>).</p><p>Also init <span>$\mathbf{f_x̂} = \mathbf{g_x̂ d_0}(k) + \mathbf{j_x̂ D̂_0} + \mathbf{k_x̂ x̂_0}(k) +  \mathbf{v_x̂ u_0}(k-1) + \mathbf{b_x̂}$</span> vector for the terminal constraints, see <a href="#ModelPredictiveControl.init_predmat"><code>init_predmat</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/transcription.jl#L857-L865">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.linconstrainteq!" href="#ModelPredictiveControl.linconstrainteq!"><code>ModelPredictiveControl.linconstrainteq!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linconstrainteq!(
    mpc::PredictiveController, model::LinModel, transcription::MultipleShooting
)</code></pre><p>Set <code>beq</code> vector for the linear model equality constraints (<span>$\mathbf{A_{eq} Z̃ = b_{eq}}$</span>).</p><p>Also init <span>$\mathbf{F_ŝ} = \mathbf{G_ŝ d_0}(k) + \mathbf{J_ŝ D̂_0} + \mathbf{K_ŝ x̂_0}(k) +  \mathbf{V_ŝ u_0}(k-1) + \mathbf{B_ŝ}$</span>, see <a href="#ModelPredictiveControl.init_defectmat"><code>init_defectmat</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/transcription.jl#L943-L952">source</a></section></article><h2 id="Solve-Optimization-Problem"><a class="docs-heading-anchor" href="#Solve-Optimization-Problem">Solve Optimization Problem</a><a id="Solve-Optimization-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-Optimization-Problem" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.optim_objective!-Tuple{PredictiveController}" href="#ModelPredictiveControl.optim_objective!-Tuple{PredictiveController}"><code>ModelPredictiveControl.optim_objective!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">optim_objective!(mpc::PredictiveController) -&gt; Z̃</code></pre><p>Optimize the objective function of <code>mpc</code> <a href="../../public/predictive_control/#PredictiveController"><code>PredictiveController</code></a> and return the solution <code>Z̃</code>.</p><p>If first warm-starts the solver with <a href="#ModelPredictiveControl.set_warmstart!"><code>set_warmstart!</code></a>. It then calls  <code>JuMP.optimize!(mpc.optim)</code> and extract the solution. A failed optimization prints an  <code>@error</code> log in the REPL and returns the warm-start value. A failed optimization also prints <a href="../../public/generic_func/#ModelPredictiveControl.getinfo"><code>getinfo</code></a> results in the debug log <a href="https://docs.julialang.org/en/v1/stdlib/Logging/#Example:-Enable-debug-level-messages">if activated</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/execute.jl#L389-L398">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.set_warmstart!" href="#ModelPredictiveControl.set_warmstart!"><code>ModelPredictiveControl.set_warmstart!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_warmstart!(mpc::PredictiveController, transcription::SingleShooting, Z̃var) -&gt; Z̃s</code></pre><p>Set and return the warm-start value of <code>Z̃var</code> for <a href="../../public/predictive_control/#SingleShooting"><code>SingleShooting</code></a> transcription.</p><p>If supported by <code>mpc.optim</code>, it warm-starts the solver at:</p><p class="math-container">\[\mathbf{Z̃_s} = 
\begin{bmatrix}
    \mathbf{Δu}(k+0|k-1)        \\ 
    \mathbf{Δu}(k+1|k-1)        \\ 
    \vdots                      \\
    \mathbf{Δu}(k+H_c-2|k-1)    \\
    \mathbf{0}                  \\
    ϵ(k-1)
\end{bmatrix}\]</p><p>where <span>$\mathbf{Δu}(k+j|k-1)$</span> is the input increment for time <span>$k+j$</span> computed at the  last control period <span>$k-1$</span>, and <span>$ϵ(k-1)$</span>, the slack variable of the last control period.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/transcription.jl#L970-L989">source</a></section><section><div><pre><code class="language-julia hljs">set_warmstart!(mpc::PredictiveController, transcription::MultipleShooting, Z̃var) -&gt; Z̃s</code></pre><p>Set and return the warm-start value of <code>Z̃var</code> for <a href="../../public/predictive_control/#MultipleShooting"><code>MultipleShooting</code></a> transcription.</p><p>It warm-starts the solver at:</p><p class="math-container">\[\mathbf{Z̃_s} =
\begin{bmatrix}
    \mathbf{Δu}(k+0|k-1)        \\ 
    \mathbf{Δu}(k+1|k-1)        \\ 
    \vdots                      \\
    \mathbf{Δu}(k+H_c-2|k-1)    \\
    \mathbf{0}                  \\
    \mathbf{x̂_0}(k+1|k-1)       \\
    \mathbf{x̂_0}(k+2|k-1)       \\
    \vdots                      \\
    \mathbf{x̂_0}(k+H_p-1|k-1)   \\
    \mathbf{x̂_0}(k+H_p-1|k-1)   \\
    ϵ(k-1)
\end{bmatrix}\]</p><p>where <span>$\mathbf{x̂_0}(k+j|k-1)$</span> is the predicted state for time <span>$k+j$</span> computed at the last control period <span>$k-1$</span>, expressed as a deviation from the operating point  <span>$\mathbf{x̂_{op}}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/transcription.jl#L1001-L1026">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.getinput!" href="#ModelPredictiveControl.getinput!"><code>ModelPredictiveControl.getinput!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getinput!(mpc::PredictiveController, Z̃) -&gt; u</code></pre><p>Get current manipulated input <code>u</code> from the solution <code>Z̃</code>, store it and return it.</p><p>The first manipulated input <span>$\mathbf{u}(k)$</span> is extracted from the decision vector <span>$\mathbf{Z̃}$</span> and applied on the plant (from the receding horizon principle). It also stores <code>u - mpc.estim.model.uop</code> at <code>mpc.lastu0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/87c474d4aa2baaab4c73d7a4fc5415f721f45ce0/src/controller/execute.jl#L453-L461">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Maciejowski, J. 2000, &quot;Predictive control : with constraints&quot;, 1st ed., Prentice Hall,  ISBN 978-0201398236.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Desbiens, A., D. Hodouin &amp; É. Plamondon. 2000, &quot;Global predictive control: a unified control structure for decoupling setpoint tracking, feedforward compensation and  disturbance rejection dynamics&quot;, <em>IEE Proceedings - Control Theory and Applications</em>,  vol. 147, no 4, <a href="https://doi.org/10.1049/ip-cta:20000443">https://doi.org/10.1049/ip-cta:20000443</a>, p. 465–475, ISSN 1350-2379.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../state_estim/">« State Estimators</a><a class="docs-footer-nextpage" href="../../func_index/">Index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Friday 13 June 2025 01:19">Friday 13 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
