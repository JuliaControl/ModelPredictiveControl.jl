<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>State Estimators · ModelPredictiveControl.jl</title><meta name="title" content="State Estimators · ModelPredictiveControl.jl"/><meta property="og:title" content="State Estimators · ModelPredictiveControl.jl"/><meta property="twitter:title" content="State Estimators · ModelPredictiveControl.jl"/><meta name="description" content="Documentation for ModelPredictiveControl.jl."/><meta property="og:description" content="Documentation for ModelPredictiveControl.jl."/><meta property="twitter:description" content="Documentation for ModelPredictiveControl.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="ModelPredictiveControl.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="ModelPredictiveControl.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ModelPredictiveControl.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/installation/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/linmpc/">Linear Design</a></li><li><a class="tocitem" href="../../manual/nonlinmpc/">Nonlinear Design</a></li><li><a class="tocitem" href="../../manual/mtk/">ModelingToolkit</a></li></ul></li></ul></li><li><span class="tocitem">Functions</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox" checked/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Public</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../sim_model/">Plant Models</a></li><li class="is-active"><a class="tocitem" href>State Estimators</a><ul class="internal"><li><a class="tocitem" href="#StateEstimator"><span>StateEstimator</span></a></li><li><a class="tocitem" href="#SteadyKalmanFilter"><span>SteadyKalmanFilter</span></a></li><li><a class="tocitem" href="#KalmanFilter"><span>KalmanFilter</span></a></li><li><a class="tocitem" href="#Luenberger"><span>Luenberger</span></a></li><li><a class="tocitem" href="#UnscentedKalmanFilter"><span>UnscentedKalmanFilter</span></a></li><li><a class="tocitem" href="#ExtendedKalmanFilter"><span>ExtendedKalmanFilter</span></a></li><li><a class="tocitem" href="#MovingHorizonEstimator"><span>MovingHorizonEstimator</span></a></li><li><a class="tocitem" href="#InternalModel"><span>InternalModel</span></a></li><li><a class="tocitem" href="#Default-Model-Augmentation"><span>Default Model Augmentation</span></a></li></ul></li><li><a class="tocitem" href="../predictive_control/">Predictive Controllers</a></li><li><a class="tocitem" href="../generic_func/">Generic Functions</a></li><li><a class="tocitem" href="../plot_sim/">Simulations and Plots</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../internals/sim_model/">Plant Models</a></li><li><a class="tocitem" href="../../internals/state_estim/">State Estimators</a></li><li><a class="tocitem" href="../../internals/predictive_control/">Predictive Controllers</a></li></ul></li></ul></li><li><a class="tocitem" href="../../func_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functions</a></li><li><a class="is-disabled">Public</a></li><li class="is-active"><a href>State Estimators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>State Estimators</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaControl/ModelPredictiveControl.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/main/docs/src/public/state_estim.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions:-State-Estimators"><a class="docs-heading-anchor" href="#Functions:-State-Estimators">Functions: State Estimators</a><a id="Functions:-State-Estimators-1"></a><a class="docs-heading-anchor-permalink" href="#Functions:-State-Estimators" title="Permalink"></a></h1><ul><li><a href="#Functions:-State-Estimators">Functions: State Estimators</a></li><li class="no-marker"><ul><li><a href="#StateEstimator">StateEstimator</a></li><li><a href="#SteadyKalmanFilter">SteadyKalmanFilter</a></li><li><a href="#KalmanFilter">KalmanFilter</a></li><li><a href="#Luenberger">Luenberger</a></li><li><a href="#UnscentedKalmanFilter">UnscentedKalmanFilter</a></li><li><a href="#ExtendedKalmanFilter">ExtendedKalmanFilter</a></li><li><a href="#MovingHorizonEstimator">MovingHorizonEstimator</a></li><li><a href="#InternalModel">InternalModel</a></li><li><a href="#Default-Model-Augmentation">Default Model Augmentation</a></li></ul></li></ul><p>This module includes many state estimators (or state observer), both for deterministic and stochastic systems. The implementations focus on control applications, that is, relying on the estimates to compute a <a href="https://en.wikipedia.org/wiki/Full_state_feedback">full state feedback</a> (predictive controllers, in this package). They all incorporates some kind of integral action by default, since it is generally desired to eliminate the steady-state error with closed-loop control (offset-free tracking).</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If you plan to use the estimators for other contexts than this specific package (e.g. : filter, parameter estimation, etc.), careful must be taken at construction since the integral action is not necessarily desired. The options <code>nint_u=0</code> and <code>nint_ym=0</code> disable it.</p></div></div><p>The estimators are all implemented in the current form (a.k.a. as filter form) by default to improve accuracy and robustness, that is, they all estimates at each discrete time <span>$k$</span> the states of the current period <span>$\mathbf{x̂}_k(k)$</span><sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> (using the newest measurements, see <a href="../../manual/linmpc/#man_lin">Manual</a> for examples). The predictor form (a.k.a. delayed form) is also available with the option <code>direct=false</code>. This allow moving the estimator computations after solving the MPC problem with <a href="../predictive_control/#ModelPredictiveControl.moveinput!"><code>moveinput!</code></a>, for when the estimations are expensive (for instance, with the <a href="#MovingHorizonEstimator"><code>MovingHorizonEstimator</code></a>).</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The nomenclature in this page introduces the estimated state <span>$\mathbf{x̂}$</span> and output <span>$\mathbf{ŷ}$</span> vectors of respectively <code>nx̂</code> and <code>ny</code> elements. Also, all the estimators support measured <span>$\mathbf{y^m}$</span> (<code>nym</code> elements) and unmeasured <span>$\mathbf{y^u}$</span> (<code>nyu</code> elements) model output, where <span>$\mathbf{y}$</span> refers to all of them.</p></div></div><h2 id="StateEstimator"><a class="docs-heading-anchor" href="#StateEstimator">StateEstimator</a><a id="StateEstimator-1"></a><a class="docs-heading-anchor-permalink" href="#StateEstimator" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.StateEstimator" href="#ModelPredictiveControl.StateEstimator"><code>ModelPredictiveControl.StateEstimator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract supertype of all state estimators.</p><hr/><pre><code class="nohighlight hljs">(estim::StateEstimator)(d=[]) -&gt; ŷ</code></pre><p>Functor allowing callable <code>StateEstimator</code> object as an alias for <a href="../generic_func/#ModelPredictiveControl.evaloutput"><code>evaloutput</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; kf = KalmanFilter(setop!(LinModel(tf(3, [10, 1]), 2), yop=[20]), direct=false);

julia&gt; ŷ = kf() 
1-element Vector{Float64}:
 20.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/b12125e6c0b8439a3919d56061b1293b01f714c3/src/state_estim.jl#L1-L18">source</a></section></article><h2 id="SteadyKalmanFilter"><a class="docs-heading-anchor" href="#SteadyKalmanFilter">SteadyKalmanFilter</a><a id="SteadyKalmanFilter-1"></a><a class="docs-heading-anchor-permalink" href="#SteadyKalmanFilter" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.SteadyKalmanFilter" href="#ModelPredictiveControl.SteadyKalmanFilter"><code>ModelPredictiveControl.SteadyKalmanFilter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SteadyKalmanFilter(model::LinModel; &lt;keyword arguments&gt;)</code></pre><p>Construct a steady-state Kalman Filter with the <a href="../sim_model/#LinModel"><code>LinModel</code></a> <code>model</code>.</p><p>The steady-state (or <a href="https://en.wikipedia.org/wiki/Kalman_filter#Asymptotic_form">asymptotic</a>) Kalman filter is based on the process model:</p><p class="math-container">\[\begin{aligned}
    \mathbf{x}(k+1) &amp;= 
            \mathbf{Â x}(k) + \mathbf{B̂_u u}(k) + \mathbf{B̂_d d}(k) + \mathbf{w}(k) \\
    \mathbf{y^m}(k) &amp;= \mathbf{Ĉ^m x}(k) + \mathbf{D̂_d^m d}(k) + \mathbf{v}(k) \\
    \mathbf{y^u}(k) &amp;= \mathbf{Ĉ^u x}(k) + \mathbf{D̂_d^u d}(k)
\end{aligned}\]</p><p>with sensor <span>$\mathbf{v}(k)$</span> and process <span>$\mathbf{w}(k)$</span> noises as uncorrelated zero mean  white noise vectors, with a respective covariance of <span>$\mathbf{R̂}$</span> and <span>$\mathbf{Q̂}$</span>.  The arguments are in standard deviations σ, i.e. same units than outputs and states. The  matrices <span>$\mathbf{Â, B̂_u, B̂_d, Ĉ, D̂_d}$</span> are <code>model</code> matrices augmented with the stochastic model, which is specified by the numbers of integrator <code>nint_u</code> and <code>nint_ym</code> (see Extended Help). Likewise, the covariance matrices are augmented with <span>$\mathbf{Q̂ = \text{diag}(Q,  Q_{int_u}, Q_{int_{ym}})}$</span> and <span>$\mathbf{R̂ = R}$</span>. The Extended Help provide some guidelines on the covariance tuning. The matrices <span>$\mathbf{Ĉ^m, D̂_d^m}$</span> are the rows of  <span>$\mathbf{Ĉ, D̂_d}$</span> that correspond to measured outputs <span>$\mathbf{y^m}$</span> (and unmeasured ones, for <span>$\mathbf{Ĉ^u, D̂_d^u}$</span>). The Kalman filter will estimate the current state with  the newest measurements <span>$\mathbf{x̂}_k(k)$</span> if <code>direct</code> is <code>true</code>, else it will predict the state of the next time step <span>$\mathbf{x̂}_k(k+1)$</span>. This estimator is allocation-free.</p><p><strong>Arguments</strong></p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Keyword arguments with <em><code>emphasis</code></em> are non-Unicode alternatives.</p></div></div><ul><li><code>model::LinModel</code> : (deterministic) model for the estimations.</li><li><code>i_ym=1:model.ny</code> : <code>model</code> output indices that are measured <span>$\mathbf{y^m}$</span>, the rest    are unmeasured <span>$\mathbf{y^u}$</span>.</li><li><code>σQ=fill(1/model.nx,model.nx)</code> or <em><code>sigmaQ</code></em> : main diagonal of the process noise   covariance <span>$\mathbf{Q}$</span> of <code>model</code>, specified as a standard deviation vector.</li><li><code>σR=fill(1,length(i_ym))</code> or <em><code>sigmaR</code></em> : main diagonal of the sensor noise covariance   <span>$\mathbf{R}$</span> of <code>model</code> measured outputs, specified as a standard deviation vector.</li><li><code>nint_u=0</code>: integrator quantity for the stochastic model of the unmeasured disturbances at   the manipulated inputs (vector), use <code>nint_u=0</code> for no integrator (see Extended Help).</li><li><code>nint_ym=default_nint(model,i_ym,nint_u)</code> : same than <code>nint_u</code> but for the unmeasured    disturbances at the measured outputs, use <code>nint_ym=0</code> for no integrator (see Extended Help).</li><li><code>σQint_u=fill(1,sum(nint_u))</code> or <em><code>sigmaQint_u</code></em> : same than <code>σQ</code> but for the unmeasured   disturbances at manipulated inputs <span>$\mathbf{Q_{int_u}}$</span> (composed of integrators).</li><li><code>σQint_ym=fill(1,sum(nint_ym))</code> or <em><code>sigmaQint_u</code></em> : same than <code>σQ</code> for the unmeasured   disturbances at measured outputs <span>$\mathbf{Q_{int_{ym}}}$</span> (composed of integrators).</li><li><code>direct=true</code>: construct with a direct transmission from <span>$\mathbf{y^m}$</span> (a.k.a. current  estimator, in opposition to the delayed/predictor form).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 0.5);

julia&gt; estim = SteadyKalmanFilter(model, i_ym=[2], σR=[1], σQint_ym=[0.01])
SteadyKalmanFilter estimator with a sample time Ts = 0.5 s, LinModel and:
 1 manipulated inputs u (0 integrating states)
 3 estimated states x̂
 1 measured outputs ym (1 integrating states)
 1 unmeasured outputs yu
 0 measured disturbances d</code></pre><p><strong>Extended Help</strong></p><details class="admonition is-details"><summary class="admonition-header">Extended Help</summary><div class="admonition-body"><p>The <code>σR</code> argument is generally fixed at the estimated standard deviations of the sensor noises. The <code>σQ</code>, <code>σQint_u</code> and <code>σQint_ym</code> arguments can be used to tune the filter response. Increasing them make the filter more responsive to disturbances but more sensitive to measurement noise.</p><p>The model augmentation with <code>nint_u</code> vector adds integrators at model manipulated inputs, and <code>nint_ym</code>, at measured outputs. They create the integral action when the estimator is used in a controller as state feedback. By default, the method <a href="#ModelPredictiveControl.default_nint"><code>default_nint</code></a> adds one integrator per measured output if feasible. The argument <code>nint_ym</code> can also be tweaked by following these rules on each measured output:</p><ul><li>Use 0 integrator if the model output is already integrating (else it will be unobservable)</li><li>Use 1 integrator if the disturbances on the output are typically &quot;step-like&quot;</li><li>Use 2 integrators if the disturbances on the output are typically &quot;ramp-like&quot; </li></ul><p>The function <a href="../../internals/state_estim/#ModelPredictiveControl.init_estimstoch"><code>init_estimstoch</code></a> builds the stochastic model for estimation.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Increasing <code>σQint_u</code> and <code>σQint_ym</code> values increases the integral action &quot;gain&quot;.</p></div></div><p>The constructor pre-compute the steady-state Kalman gain <code>K̂</code> with the <a href="https://juliacontrol.github.io/ControlSystems.jl/stable/lib/synthesis/#ControlSystemsBase.kalman-Tuple%7BAny%2C%20Any%2C%20Any%2C%20Any%2C%20Any%2C%20Vararg%7BAny%7D%7D"><code>kalman</code></a> function. It can sometimes fail, for example when <code>model</code> matrices are ill-conditioned. In such a case, you can try the alternative time-varying <a href="#KalmanFilter"><code>KalmanFilter</code></a>.</p></div></details></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/b12125e6c0b8439a3919d56061b1293b01f714c3/src/estimator/kalman.jl#L78-L166">source</a></section><section><div><pre><code class="language-julia hljs">SteadyKalmanFilter(model, i_ym, nint_u, nint_ym, Q̂, R̂; direct=true)</code></pre><p>Construct the estimator from the augmented covariance matrices <code>Q̂</code> and <code>R̂</code>.</p><p>This syntax allows nonzero off-diagonal elements in <span>$\mathbf{Q̂, R̂}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/b12125e6c0b8439a3919d56061b1293b01f714c3/src/estimator/kalman.jl#L188-L194">source</a></section></article><h2 id="KalmanFilter"><a class="docs-heading-anchor" href="#KalmanFilter">KalmanFilter</a><a id="KalmanFilter-1"></a><a class="docs-heading-anchor-permalink" href="#KalmanFilter" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.KalmanFilter" href="#ModelPredictiveControl.KalmanFilter"><code>ModelPredictiveControl.KalmanFilter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KalmanFilter(model::LinModel; &lt;keyword arguments&gt;)</code></pre><p>Construct a time-varying Kalman Filter with the <a href="../sim_model/#LinModel"><code>LinModel</code></a> <code>model</code>.</p><p>The process model is identical to <a href="#SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a>. The matrix <span>$\mathbf{P̂}$</span> is the estimation error covariance of <code>model</code> states augmented with the stochastic ones (specified by <code>nint_u</code> and <code>nint_ym</code>). Three keyword arguments specify its initial value with <span>$\mathbf{P̂}_{-1}(0) = \mathrm{diag}\{ \mathbf{P}(0), \mathbf{P_{int_{u}}}(0),  \mathbf{P_{int_{ym}}}(0) \}$</span>. The initial state estimate <span>$\mathbf{x̂}_{-1}(0)$</span> can be manually specified with <a href="../generic_func/#ModelPredictiveControl.setstate!"><code>setstate!</code></a>, or automatically with <a href="../generic_func/#ModelPredictiveControl.initstate!"><code>initstate!</code></a>. This estimator is allocation-free.</p><p><strong>Arguments</strong></p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Keyword arguments with <em><code>emphasis</code></em> are non-Unicode alternatives.</p></div></div><ul><li><code>model::LinModel</code> : (deterministic) model for the estimations.</li><li><code>i_ym=1:model.ny</code> : <code>model</code> output indices that are measured <span>$\mathbf{y^m}$</span>, the rest    are unmeasured <span>$\mathbf{y^u}$</span>.</li><li><code>σP_0=fill(1/model.nx,model.nx)</code> or <em><code>sigmaP_0</code></em> : main diagonal of the initial estimate   covariance <span>$\mathbf{P}(0)$</span>, specified as a standard deviation vector.</li><li><code>σQ=fill(1/model.nx,model.nx)</code> or <em><code>sigmaQ</code></em> : main diagonal of the process noise   covariance <span>$\mathbf{Q}$</span> of <code>model</code>, specified as a standard deviation vector.</li><li><code>σR=fill(1,length(i_ym))</code> or <em><code>sigmaR</code></em> : main diagonal of the sensor noise covariance   <span>$\mathbf{R}$</span> of <code>model</code> measured outputs, specified as a standard deviation vector.</li><li><code>nint_u=0</code>: integrator quantity for the stochastic model of the unmeasured disturbances at   the manipulated inputs (vector), use <code>nint_u=0</code> for no integrator.</li><li><code>nint_ym=default_nint(model,i_ym,nint_u)</code> : same than <code>nint_u</code> but for the unmeasured    disturbances at the measured outputs, use <code>nint_ym=0</code> for no integrator.</li><li><code>σQint_u=fill(1,sum(nint_u))</code> or <em><code>sigmaQint_u</code></em> : same than <code>σQ</code> but for the unmeasured   disturbances at manipulated inputs <span>$\mathbf{Q_{int_u}}$</span> (composed of integrators).</li><li><code>σPint_u_0=fill(1,sum(nint_u))</code> or <em><code>sigmaPint_u_0</code></em> : same than <code>σP_0</code> but for the unmeasured   disturbances at manipulated inputs <span>$\mathbf{P_{int_u}}(0)$</span> (composed of integrators).</li><li><code>σQint_ym=fill(1,sum(nint_ym))</code> or <em><code>sigmaQint_u</code></em> : same than <code>σQ</code> for the unmeasured   disturbances at measured outputs <span>$\mathbf{Q_{int_{ym}}}$</span> (composed of integrators).</li><li><code>σPint_ym_0=fill(1,sum(nint_ym))</code> or <em><code>sigmaPint_ym_0</code></em> : same than <code>σP_0</code> but for the unmeasured   disturbances at measured outputs <span>$\mathbf{P_{int_{ym}}}(0)$</span> (composed of integrators).</li><li><code>direct=true</code>: construct with a direct transmission from <span>$\mathbf{y^m}$</span> (a.k.a. current  estimator, in opposition to the delayed/predictor form).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 0.5);

julia&gt; estim = KalmanFilter(model, i_ym=[2], σR=[1], σP_0=[100, 100], σQint_ym=[0.01])
KalmanFilter estimator with a sample time Ts = 0.5 s, LinModel and:
 1 manipulated inputs u (0 integrating states)
 3 estimated states x̂
 1 measured outputs ym (1 integrating states)
 1 unmeasured outputs yu
 0 measured disturbances d</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/b12125e6c0b8439a3919d56061b1293b01f714c3/src/estimator/kalman.jl#L344-L397">source</a></section><section><div><pre><code class="language-julia hljs">KalmanFilter(model, i_ym, nint_u, nint_ym, P̂_0, Q̂, R̂; direct=true)</code></pre><p>Construct the estimator from the augmented covariance matrices <code>P̂_0</code>, <code>Q̂</code> and <code>R̂</code>.</p><p>This syntax allows nonzero off-diagonal elements in <span>$\mathbf{P̂}_{-1}(0), \mathbf{Q̂, R̂}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/b12125e6c0b8439a3919d56061b1293b01f714c3/src/estimator/kalman.jl#L426-L432">source</a></section></article><h2 id="Luenberger"><a class="docs-heading-anchor" href="#Luenberger">Luenberger</a><a id="Luenberger-1"></a><a class="docs-heading-anchor-permalink" href="#Luenberger" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.Luenberger" href="#ModelPredictiveControl.Luenberger"><code>ModelPredictiveControl.Luenberger</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Luenberger(
    model::LinModel; 
    i_ym = 1:model.ny, 
    nint_u  = 0,
    nint_ym = default_nint(model, i_ym),
    poles = 1e-3*(1:(model.nx + sum(nint_u) + sum(nint_ym))) .+ 0.5,
    direct = true
)</code></pre><p>Construct a Luenberger observer with the <a href="../sim_model/#LinModel"><code>LinModel</code></a> <code>model</code>.</p><p><code>i_ym</code> provides the <code>model</code> output indices that are measured <span>$\mathbf{y^m}$</span>, the rest are unmeasured <span>$\mathbf{y^u}$</span>. <code>model</code> matrices are augmented with the stochastic model, which is specified by the numbers of integrator <code>nint_u</code> and <code>nint_ym</code> (see <a href="#SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a> Extended Help). The argument <code>poles</code> is a vector of <code>model.nx + sum(nint_u) + sum(nint_ym)</code> elements specifying the observer poles/eigenvalues (near <span>$z=0.5$</span> by default). The observer is constructed with a direct transmission from <span>$\mathbf{y^m}$</span> if <code>direct=true</code> (a.k.a.  current observers, in opposition to the delayed/prediction form). The method computes the observer gain <code>K̂</code> with <a href="https://juliacontrol.github.io/ControlSystems.jl/stable/lib/synthesis/#ControlSystemsBase.place"><code>place</code></a> function. This estimator is allocation-free.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 0.5);

julia&gt; estim = Luenberger(model, nint_ym=[1, 1], poles=[0.61, 0.62, 0.63, 0.64])
Luenberger estimator with a sample time Ts = 0.5 s, LinModel and:
 1 manipulated inputs u (0 integrating states)
 4 estimated states x̂
 2 measured outputs ym (2 integrating states)
 0 unmeasured outputs yu
 0 measured disturbances d</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/b12125e6c0b8439a3919d56061b1293b01f714c3/src/estimator/luenberger.jl#L61-L95">source</a></section></article><h2 id="UnscentedKalmanFilter"><a class="docs-heading-anchor" href="#UnscentedKalmanFilter">UnscentedKalmanFilter</a><a id="UnscentedKalmanFilter-1"></a><a class="docs-heading-anchor-permalink" href="#UnscentedKalmanFilter" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.UnscentedKalmanFilter" href="#ModelPredictiveControl.UnscentedKalmanFilter"><code>ModelPredictiveControl.UnscentedKalmanFilter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnscentedKalmanFilter(model::SimModel; &lt;keyword arguments&gt;)</code></pre><p>Construct an unscented Kalman Filter with the <a href="../sim_model/#SimModel"><code>SimModel</code></a> <code>model</code>.</p><p>Both <a href="../sim_model/#LinModel"><code>LinModel</code></a> and <a href="../sim_model/#NonLinModel"><code>NonLinModel</code></a> are supported. The unscented Kalman filter is based on the process model :</p><p class="math-container">\[\begin{aligned}
    \mathbf{x}(k+1) &amp;= \mathbf{f̂}\Big(\mathbf{x}(k), \mathbf{u}(k), \mathbf{d}(k)\Big) 
                        + \mathbf{w}(k)                                                   \\
    \mathbf{y^m}(k) &amp;= \mathbf{ĥ^m}\Big(\mathbf{x}(k), \mathbf{d}(k)\Big) + \mathbf{v}(k) \\
    \mathbf{y^u}(k) &amp;= \mathbf{ĥ^u}\Big(\mathbf{x}(k), \mathbf{d}(k)\Big)                 \\
\end{aligned}\]</p><p>See <a href="#SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a> for details on <span>$\mathbf{v}(k), \mathbf{w}(k)$</span> noises and <span>$\mathbf{R̂}, \mathbf{Q̂}$</span> covariances. The two matrices are constructed from <span>$\mathbf{Q̂ = \text{diag}(Q, Q_{int_u}, Q_{int_{ym}})}$</span> and <span>$\mathbf{R̂ = R}$</span>. The functions <span>$\mathbf{f̂, ĥ}$</span> are <code>model</code> state-space functions augmented with the stochastic model of the unmeasured disturbances, which is specified by the numbers of integrator <code>nint_u</code> and <code>nint_ym</code> (see Extended Help). Model parameters <span>$\mathbf{p}$</span> are not argument of <span>$\mathbf{f̂, ĥ}$</span> functions for conciseness. The <span>$\mathbf{ĥ^m}$</span> function represents the measured outputs of <span>$\mathbf{ĥ}$</span> function (and unmeasured ones, for <span>$\mathbf{ĥ^u}$</span>). The matrix <span>$\mathbf{P̂}$</span> is the estimation error covariance of <code>model</code> state augmented with the  stochastic ones. Three keyword arguments specify its initial value with <span>$\mathbf{P̂}_{-1}(0) =  \mathrm{diag}\{ \mathbf{P}(0), \mathbf{P_{int_{u}}}(0), \mathbf{P_{int_{ym}}}(0) \}$</span>. The  initial state estimate <span>$\mathbf{x̂}_{-1}(0)$</span> can be manually specified with <a href="../generic_func/#ModelPredictiveControl.setstate!"><code>setstate!</code></a>. This estimator is allocation-free if <code>model</code> simulations do not allocate.</p><p><strong>Arguments</strong></p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Keyword arguments with <em><code>emphasis</code></em> are non-Unicode alternatives.</p></div></div><ul><li><code>model::SimModel</code> : (deterministic) model for the estimations.</li><li><code>i_ym=1:model.ny</code> : <code>model</code> output indices that are measured <span>$\mathbf{y^m}$</span>, the rest    are unmeasured <span>$\mathbf{y^u}$</span>.</li><li><code>σP_0=fill(1/model.nx,model.nx)</code> or <em><code>sigmaP_0</code></em> : main diagonal of the initial estimate   covariance <span>$\mathbf{P}(0)$</span>, specified as a standard deviation vector.</li><li><code>σQ=fill(1/model.nx,model.nx)</code> or <em><code>sigmaQ</code></em> : main diagonal of the process noise   covariance <span>$\mathbf{Q}$</span> of <code>model</code>, specified as a standard deviation vector.</li><li><code>σR=fill(1,length(i_ym))</code> or <em><code>sigmaR</code></em> : main diagonal of the sensor noise covariance   <span>$\mathbf{R}$</span> of <code>model</code> measured outputs, specified as a standard deviation vector.</li><li><code>nint_u=0</code>: integrator quantity for the stochastic model of the unmeasured disturbances at   the manipulated inputs (vector), use <code>nint_u=0</code> for no integrator (see Extended Help).</li><li><code>nint_ym=default_nint(model,i_ym,nint_u)</code> : same than <code>nint_u</code> but for the unmeasured    disturbances at the measured outputs, use <code>nint_ym=0</code> for no integrator (see Extended Help).</li><li><code>σQint_u=fill(1,sum(nint_u))</code> or <em><code>sigmaQint_u</code></em> : same than <code>σQ</code> but for the unmeasured   disturbances at manipulated inputs <span>$\mathbf{Q_{int_u}}$</span> (composed of integrators).</li><li><code>σPint_u_0=fill(1,sum(nint_u))</code> or <em><code>sigmaPint_u_0</code></em> : same than <code>σP_0</code> but for the unmeasured   disturbances at manipulated inputs <span>$\mathbf{P_{int_u}}(0)$</span> (composed of integrators).</li><li><code>σQint_ym=fill(1,sum(nint_ym))</code> or <em><code>sigmaQint_u</code></em> : same than <code>σQ</code> for the unmeasured   disturbances at measured outputs <span>$\mathbf{Q_{int_{ym}}}$</span> (composed of integrators).</li><li><code>σPint_ym_0=fill(1,sum(nint_ym))</code> or <em><code>sigmaPint_ym_0</code></em> : same than <code>σP_0</code> but for the unmeasured   disturbances at measured outputs <span>$\mathbf{P_{int_{ym}}}(0)$</span> (composed of integrators).</li><li><code>α=1e-3</code> or <em><code>alpha</code></em> : alpha parameter, spread of the state distribution <span>$(0 &lt; α ≤ 1)$</span>.</li><li><code>β=2</code> or <em><code>beta</code></em> : beta parameter, skewness and kurtosis of the states distribution <span>$(β ≥ 0)$</span>.</li><li><code>κ=0</code> or <em><code>kappa</code></em> : kappa parameter, another spread parameter <span>$(0 ≤ κ ≤ 3)$</span>.</li><li><code>direct=true</code>: construct with a direct transmission from <span>$\mathbf{y^m}$</span> (a.k.a. current  estimator, in opposition to the delayed/predictor form).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = NonLinModel((x,u,_,_)-&gt;0.1x+u, (x,_,_)-&gt;2x, 10.0, 1, 1, 1, solver=nothing);

julia&gt; estim = UnscentedKalmanFilter(model, σR=[1], nint_ym=[2], σPint_ym_0=[1, 1])
UnscentedKalmanFilter estimator with a sample time Ts = 10.0 s, NonLinModel and:
 1 manipulated inputs u (0 integrating states)
 3 estimated states x̂
 1 measured outputs ym (2 integrating states)
 0 unmeasured outputs yu
 0 measured disturbances d</code></pre><p><strong>Extended Help</strong></p><details class="admonition is-details"><summary class="admonition-header">Extended Help</summary><div class="admonition-body"><p>The Extended Help of <a href="#SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a> details the tuning of the covariances and the augmentation with <code>nint_ym</code> and <code>nint_u</code> arguments. The default augmentation scheme is identical, that is <code>nint_u=0</code> and <code>nint_ym</code> computed by <a href="#ModelPredictiveControl.default_nint"><code>default_nint</code></a>. Note that the constructor does not validate the observability of the resulting augmented <a href="../sim_model/#NonLinModel"><code>NonLinModel</code></a>. In such cases, it is the user&#39;s responsibility to ensure that it is still observable.</p></div></details></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/b12125e6c0b8439a3919d56061b1293b01f714c3/src/estimator/kalman.jl#L573-L654">source</a></section><section><div><pre><code class="language-julia hljs">UnscentedKalmanFilter(
    model, i_ym, nint_u, nint_ym, P̂_0, Q̂, R̂, α=1e-3, β=2, κ=0; direct=true
)</code></pre><p>Construct the estimator from the augmented covariance matrices <code>P̂_0</code>, <code>Q̂</code> and <code>R̂</code>.</p><p>This syntax allows nonzero off-diagonal elements in <span>$\mathbf{P̂}_{-1}(0), \mathbf{Q̂, R̂}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/b12125e6c0b8439a3919d56061b1293b01f714c3/src/estimator/kalman.jl#L691-L699">source</a></section></article><h2 id="ExtendedKalmanFilter"><a class="docs-heading-anchor" href="#ExtendedKalmanFilter">ExtendedKalmanFilter</a><a id="ExtendedKalmanFilter-1"></a><a class="docs-heading-anchor-permalink" href="#ExtendedKalmanFilter" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.ExtendedKalmanFilter" href="#ModelPredictiveControl.ExtendedKalmanFilter"><code>ModelPredictiveControl.ExtendedKalmanFilter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ExtendedKalmanFilter(model::SimModel; &lt;keyword arguments&gt;)</code></pre><p>Construct an extended Kalman Filter with the <a href="../sim_model/#SimModel"><code>SimModel</code></a> <code>model</code>.</p><p>Both <a href="../sim_model/#LinModel"><code>LinModel</code></a> and <a href="../sim_model/#NonLinModel"><code>NonLinModel</code></a> are supported. The process model is identical to <a href="#UnscentedKalmanFilter"><code>UnscentedKalmanFilter</code></a>. By default, the Jacobians of the augmented model <span>$\mathbf{f̂, ĥ}$</span> are computed with <a href="https://juliadiff.org/ForwardDiff.jl/stable/#ForwardDiff"><code>ForwardDiff</code></a> automatic differentiation. This estimator is allocation-free if <code>model</code> simulations do not allocate.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>See the Extended Help of <a href="../sim_model/#ModelPredictiveControl.linearize"><code>linearize</code></a> function if you get an error like:     <code>MethodError: no method matching (::var&quot;##&quot;)(::Vector{ForwardDiff.Dual})</code>.</p></div></div><p><strong>Arguments</strong></p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Keyword arguments with <em><code>emphasis</code></em> are non-Unicode alternatives.</p></div></div><ul><li><code>model::SimModel</code> : (deterministic) model for the estimations.</li><li><code>i_ym=1:model.ny</code> : <code>model</code> output indices that are measured <span>$\mathbf{y^m}$</span>, the rest    are unmeasured <span>$\mathbf{y^u}$</span>.</li><li><code>σP_0=fill(1/model.nx,model.nx)</code> or <em><code>sigmaP_0</code></em> : main diagonal of the initial estimate   covariance <span>$\mathbf{P}(0)$</span>, specified as a standard deviation vector.</li><li><code>σQ=fill(1/model.nx,model.nx)</code> or <em><code>sigmaQ</code></em> : main diagonal of the process noise   covariance <span>$\mathbf{Q}$</span> of <code>model</code>, specified as a standard deviation vector.</li><li><code>σR=fill(1,length(i_ym))</code> or <em><code>sigmaR</code></em> : main diagonal of the sensor noise covariance   <span>$\mathbf{R}$</span> of <code>model</code> measured outputs, specified as a standard deviation vector.</li><li><code>nint_u=0</code>: integrator quantity for the stochastic model of the unmeasured disturbances at   the manipulated inputs (vector), use <code>nint_u=0</code> for no integrator (see Extended Help).</li><li><code>nint_ym=default_nint(model,i_ym,nint_u)</code> : same than <code>nint_u</code> but for the unmeasured    disturbances at the measured outputs, use <code>nint_ym=0</code> for no integrator (see Extended Help).</li><li><code>σQint_u=fill(1,sum(nint_u))</code> or <em><code>sigmaQint_u</code></em> : same than <code>σQ</code> but for the unmeasured   disturbances at manipulated inputs <span>$\mathbf{Q_{int_u}}$</span> (composed of integrators).</li><li><code>σPint_u_0=fill(1,sum(nint_u))</code> or <em><code>sigmaPint_u_0</code></em> : same than <code>σP_0</code> but for the unmeasured   disturbances at manipulated inputs <span>$\mathbf{P_{int_u}}(0)$</span> (composed of integrators).</li><li><code>σQint_ym=fill(1,sum(nint_ym))</code> or <em><code>sigmaQint_u</code></em> : same than <code>σQ</code> for the unmeasured   disturbances at measured outputs <span>$\mathbf{Q_{int_{ym}}}$</span> (composed of integrators).</li><li><code>σPint_ym_0=fill(1,sum(nint_ym))</code> or <em><code>sigmaPint_ym_0</code></em> : same than <code>σP_0</code> but for the unmeasured   disturbances at measured outputs <span>$\mathbf{P_{int_{ym}}}(0)$</span> (composed of integrators).</li><li><code>jacobian=AutoForwardDiff()</code>: an <code>AbstractADType</code> backend for the Jacobians of the augmented   model, see <a href="https://juliadiff.org/DifferentiationInterface.jl/DifferentiationInterface/stable/explanation/backends/#List"><code>DifferentiationInterface</code> doc</a>.</li><li><code>direct=true</code>: construct with a direct transmission from <span>$\mathbf{y^m}$</span> (a.k.a. current  estimator, in opposition to the delayed/predictor form).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = NonLinModel((x,u,_,_)-&gt;0.2x+u, (x,_,_)-&gt;-3x, 5.0, 1, 1, 1, solver=nothing);

julia&gt; estim = ExtendedKalmanFilter(model, σQ=[2], σQint_ym=[2], σP_0=[0.1], σPint_ym_0=[0.1])
ExtendedKalmanFilter estimator with a sample time Ts = 5.0 s, NonLinModel and:
 1 manipulated inputs u (0 integrating states)
 2 estimated states x̂
 1 measured outputs ym (1 integrating states)
 0 unmeasured outputs yu
 0 measured disturbances d</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/b12125e6c0b8439a3919d56061b1293b01f714c3/src/estimator/kalman.jl#L954-L1009">source</a></section><section><div><pre><code class="language-julia hljs">ExtendedKalmanFilter(
    model, i_ym, nint_u, nint_ym, P̂_0, Q̂, R̂; jacobian=AutoForwardDiff(), direct=true
)</code></pre><p>Construct the estimator from the augmented covariance matrices <code>P̂_0</code>, <code>Q̂</code> and <code>R̂</code>.</p><p>This syntax allows nonzero off-diagonal elements in <span>$\mathbf{P̂}_{-1}(0), \mathbf{Q̂, R̂}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/b12125e6c0b8439a3919d56061b1293b01f714c3/src/estimator/kalman.jl#L1042-L1050">source</a></section></article><h2 id="MovingHorizonEstimator"><a class="docs-heading-anchor" href="#MovingHorizonEstimator">MovingHorizonEstimator</a><a id="MovingHorizonEstimator-1"></a><a class="docs-heading-anchor-permalink" href="#MovingHorizonEstimator" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.MovingHorizonEstimator" href="#ModelPredictiveControl.MovingHorizonEstimator"><code>ModelPredictiveControl.MovingHorizonEstimator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MovingHorizonEstimator(model::SimModel; &lt;keyword arguments&gt;)</code></pre><p>Construct a moving horizon estimator (MHE) based on <code>model</code> (<a href="../sim_model/#LinModel"><code>LinModel</code></a> or <a href="../sim_model/#NonLinModel"><code>NonLinModel</code></a>).</p><p>It can handle constraints on the estimates, see <a href="../generic_func/#ModelPredictiveControl.setconstraint!"><code>setconstraint!</code></a>. Additionally,  <code>model</code> is not linearized like the <a href="#ExtendedKalmanFilter"><code>ExtendedKalmanFilter</code></a>, and the probability  distribution is not approximated like the <a href="#UnscentedKalmanFilter"><code>UnscentedKalmanFilter</code></a>. The computational costs are drastically higher, however, since it minimizes the following objective function at each discrete time <span>$k$</span>:</p><p class="math-container">\[\min_{\mathbf{x̂}_k(k-N_k+p), \mathbf{Ŵ}, ϵ}   \mathbf{x̄}&#39; \mathbf{P̄}^{-1}       \mathbf{x̄} 
                                            + \mathbf{Ŵ}&#39; \mathbf{Q̂}_{N_k}^{-1} \mathbf{Ŵ}  
                                            + \mathbf{V̂}&#39; \mathbf{R̂}_{N_k}^{-1} \mathbf{V̂}
                                            + C ϵ^2\]</p><p>in which the arrival costs are evaluated from the states estimated at time <span>$k-N_k$</span>:</p><p class="math-container">\[\begin{aligned}
    \mathbf{x̄} &amp;= \mathbf{x̂}_{k-N_k}(k-N_k+p) - \mathbf{x̂}_k(k-N_k+p) \\
    \mathbf{P̄} &amp;= \mathbf{P̂}_{k-N_k}(k-N_k+p)
\end{aligned}\]</p><p>and the covariances are repeated <span>$N_k$</span> times:</p><p class="math-container">\[\begin{aligned}
    \mathbf{Q̂}_{N_k} &amp;= \text{diag}\mathbf{(Q̂,Q̂,...,Q̂)}  \\
    \mathbf{R̂}_{N_k} &amp;= \text{diag}\mathbf{(R̂,R̂,...,R̂)} 
\end{aligned}\]</p><p>The estimation horizon <span>$H_e$</span> limits the window length:</p><p class="math-container">\[N_k =                     \begin{cases}
    k + 1   &amp;  k &lt; H_e    \\
    H_e     &amp;  k ≥ H_e    \end{cases}\]</p><p>The vectors <span>$\mathbf{Ŵ}$</span> and <span>$\mathbf{V̂}$</span> respectively encompass the estimated process noises <span>$\mathbf{ŵ}(k-j+p)$</span> from <span>$j=N_k$</span> to <span>$1$</span> and sensor noises <span>$\mathbf{v̂}(k-j+1)$</span> from <span>$j=N_k$</span> to <span>$1$</span>. The Extended Help defines the two vectors, the slack variable <span>$ϵ$</span>, and the estimation of the covariance at arrival <span>$\mathbf{P̂}_{k-N_k}(k-N_k+p)$</span>. If the keyword argument <code>direct=true</code> (default value), the constant <span>$p=0$</span> in the equations above, and the MHE is in the current form. Else <span>$p=1$</span>, leading to the prediction form.</p><p>See <a href="#UnscentedKalmanFilter"><code>UnscentedKalmanFilter</code></a> for details on the augmented process model and  <span>$\mathbf{R̂}, \mathbf{Q̂}$</span> covariances. This estimator allocates a fair amount of memory  at each time step for the optimization, which is hard-coded as a single shooting transcription for now.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>See the Extended Help if you get an error like:     <code>MethodError: no method matching (::var&quot;##&quot;)(::Vector{ForwardDiff.Dual})</code>.</p></div></div><p><strong>Arguments</strong></p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Keyword arguments with <em><code>emphasis</code></em> are non-Unicode alternatives.</p></div></div><ul><li><code>model::SimModel</code> : (deterministic) model for the estimations.</li><li><code>He=nothing</code> : estimation horizon <span>$H_e$</span>, must be specified.</li><li><code>i_ym=1:model.ny</code> : <code>model</code> output indices that are measured <span>$\mathbf{y^m}$</span>, the rest    are unmeasured <span>$\mathbf{y^u}$</span>.</li><li><code>σP_0=fill(1/model.nx,model.nx)</code> or <em><code>sigmaP_0</code></em> : main diagonal of the initial estimate   covariance <span>$\mathbf{P}(0)$</span>, specified as a standard deviation vector.</li><li><code>σQ=fill(1/model.nx,model.nx)</code> or <em><code>sigmaQ</code></em> : main diagonal of the process noise   covariance <span>$\mathbf{Q}$</span> of <code>model</code>, specified as a standard deviation vector.</li><li><code>σR=fill(1,length(i_ym))</code> or <em><code>sigmaR</code></em> : main diagonal of the sensor noise covariance   <span>$\mathbf{R}$</span> of <code>model</code> measured outputs, specified as a standard deviation vector.</li><li><code>nint_u=0</code>: integrator quantity for the stochastic model of the unmeasured disturbances at   the manipulated inputs (vector), use <code>nint_u=0</code> for no integrator (see Extended Help).</li><li><code>nint_ym=default_nint(model,i_ym,nint_u)</code> : same than <code>nint_u</code> but for the unmeasured    disturbances at the measured outputs, use <code>nint_ym=0</code> for no integrator (see Extended Help).</li><li><code>σQint_u=fill(1,sum(nint_u))</code> or <em><code>sigmaQint_u</code></em> : same than <code>σQ</code> but for the unmeasured   disturbances at manipulated inputs <span>$\mathbf{Q_{int_u}}$</span> (composed of integrators).</li><li><code>σPint_u_0=fill(1,sum(nint_u))</code> or <em><code>sigmaPint_u_0</code></em> : same than <code>σP_0</code> but for the unmeasured   disturbances at manipulated inputs <span>$\mathbf{P_{int_u}}(0)$</span> (composed of integrators).</li><li><code>σQint_ym=fill(1,sum(nint_ym))</code> or <em><code>sigmaQint_u</code></em> : same than <code>σQ</code> for the unmeasured   disturbances at measured outputs <span>$\mathbf{Q_{int_{ym}}}$</span> (composed of integrators).</li><li><code>σPint_ym_0=fill(1,sum(nint_ym))</code> or <em><code>sigmaPint_ym_0</code></em> : same than <code>σP_0</code> but for the unmeasured   disturbances at measured outputs <span>$\mathbf{P_{int_{ym}}}(0)$</span> (composed of integrators).</li><li><code>Cwt=Inf</code> : slack variable weight <span>$C$</span>, default to <code>Inf</code> meaning hard constraints only.</li><li><code>optim=default_optim_mhe(model)</code> : a <a href="https://jump.dev/JuMP.jl/stable/api/JuMP/#JuMP.Model"><code>JuMP.Model</code></a> object with a quadratic or  nonlinear optimizer for solving (default to <a href="https://github.com/jump-dev/Ipopt.jl"><code>Ipopt</code></a>,  or <a href="https://osqp.org/docs/parsers/jump.html"><code>OSQP</code></a> if <code>model</code> is a <a href="../sim_model/#LinModel"><code>LinModel</code></a>).</li><li><code>gradient=AutoForwardDiff()</code> : an <code>AbstractADType</code> backend for the gradient of the objective  function when <code>model</code> is not a <a href="../sim_model/#LinModel"><code>LinModel</code></a>, see <a href="https://juliadiff.org/DifferentiationInterface.jl/DifferentiationInterface/stable/explanation/backends/#List"><code>DifferentiationInterface</code> doc</a>.</li><li><code>jacobian=AutoForwardDiff()</code> : an <code>AbstractADType</code> backend for the Jacobian of the  constraints when <code>model</code> is not a <a href="../sim_model/#LinModel"><code>LinModel</code></a>, see <code>gradient</code> above for the options.</li><li><code>direct=true</code>: construct with a direct transmission from <span>$\mathbf{y^m}$</span> (a.k.a. current  estimator, in opposition to the delayed/predictor form).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = NonLinModel((x,u,_,_)-&gt;0.1x+u, (x,_,_)-&gt;2x, 10.0, 1, 1, 1, solver=nothing);

julia&gt; estim = MovingHorizonEstimator(model, He=5, σR=[1], σP_0=[0.01])
MovingHorizonEstimator estimator with a sample time Ts = 10.0 s, Ipopt optimizer, NonLinModel and:
 5 estimation steps He
 0 slack variable ϵ (estimation constraints)
 1 manipulated inputs u (0 integrating states)
 2 estimated states x̂
 1 measured outputs ym (1 integrating states)
 0 unmeasured outputs yu
 0 measured disturbances d</code></pre><p><strong>Extended Help</strong></p><details class="admonition is-details"><summary class="admonition-header">Extended Help</summary><div class="admonition-body"><p>The estimated process and sensor noises are defined as:</p><p class="math-container">\[\mathbf{Ŵ} = 
\begin{bmatrix}
    \mathbf{ŵ}(k-N_k+p+0)     \\
    \mathbf{ŵ}(k-N_k+p+1)     \\
    \vdots                  \\
    \mathbf{ŵ}(k+p-1)
\end{bmatrix} , \quad
\mathbf{V̂} =
\begin{bmatrix}
    \mathbf{v̂}(k-N_k+1)     \\
    \mathbf{v̂}(k-N_k+2)     \\
    \vdots                  \\
    \mathbf{v̂}(k)
\end{bmatrix}\]</p><p>based on the augmented model functions <span>$\mathbf{f̂, ĥ^m}$</span>:</p><p class="math-container">\[\begin{aligned}
    \mathbf{v̂}(k-j)     &amp;= \mathbf{y^m}(k-j) - \mathbf{ĥ^m}\Big(\mathbf{x̂}_k(k-j), \mathbf{d}(k-j)\Big) \\
    \mathbf{x̂}_k(k-j+1) &amp;= \mathbf{f̂}\Big(\mathbf{x̂}_k(k-j), \mathbf{u}(k-j), \mathbf{d}(k-j)\Big) + \mathbf{ŵ}(k-j)
\end{aligned}\]</p><p>The constant <span>$p$</span> equals to <code>!direct</code>. In other words, <span>$\mathbf{Ŵ}$</span> and <span>$\mathbf{V̂}$</span> are shifted by one time step if <code>direct==true</code>. The non-default prediction form with <span>$p=1$</span> is particularly useful for the MHE since it moves its expensive computations after the MPC optimization. That is, <a href="../generic_func/#ModelPredictiveControl.preparestate!"><code>preparestate!</code></a> will solve the optimization by default, but it can be postponed to <a href="../generic_func/#ModelPredictiveControl.updatestate!"><code>updatestate!</code></a> with <code>direct=false</code>.</p><p>The Extended Help of <a href="#SteadyKalmanFilter"><code>SteadyKalmanFilter</code></a> details the tuning of the covariances and the augmentation with <code>nint_ym</code> and <code>nint_u</code> arguments. The default augmentation scheme is identical, that is <code>nint_u=0</code> and <code>nint_ym</code> computed by <a href="#ModelPredictiveControl.default_nint"><code>default_nint</code></a>. Note that the constructor does not validate the observability of the resulting augmented <a href="../sim_model/#NonLinModel"><code>NonLinModel</code></a>. In such cases, it is the user&#39;s responsibility to ensure that it is still observable.</p><p>The estimation covariance at arrival <span>$\mathbf{P̂}_{k-N_k}(k-N_k+p)$</span> gives an uncertainty on the state estimate at the beginning of the window <span>$k-N_k+p$</span>, that is, in the past. It is not the same as the current estimate covariance <span>$\mathbf{P̂}_k(k)$</span>, a value not computed by the MHE (contrarily to e.g. the <a href="#KalmanFilter"><code>KalmanFilter</code></a>). Three keyword arguments specify its initial value with <span>$\mathbf{P̂_i} =  \mathrm{diag}\{ \mathbf{P}(0), \mathbf{P_{int_{u}}}(0), \mathbf{P_{int_{ym}}}(0) \}$</span>. The initial state estimate <span>$\mathbf{x̂_i}$</span> can be manually specified with <a href="../generic_func/#ModelPredictiveControl.setstate!"><code>setstate!</code></a>, or automatically  with <a href="../generic_func/#ModelPredictiveControl.initstate!"><code>initstate!</code></a> for <a href="../sim_model/#LinModel"><code>LinModel</code></a>. Note the MHE with <span>$p=0$</span> is slightly inconsistent with all the other estimators here. It interprets the initial values as <span>$\mathbf{x̂_i} = \mathbf{x̂}_{-1}(-1)$</span> and  <span>$\mathbf{P̂_i} = \mathbf{P̂}_{-1}(-1)$</span>, an  <em>a posteriori</em> estimate<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup> from the last time step. The MHE with <span>$p=1$</span> is consistent, interpreting them as  <span>$\mathbf{x̂_i} = \mathbf{x̂}_{-1}(0)$</span> and <span>$\mathbf{P̂_i} = \mathbf{P̂}_{-1}(0)$</span>.</p><p>The optimization and the update of the arrival covariance depend on <code>model</code>:</p><ul><li>If <code>model</code> is a <a href="../sim_model/#LinModel"><code>LinModel</code></a>, the optimization is treated as a quadratic program with a time-varying Hessian, which is generally cheaper than nonlinear programming. By default, a <a href="#KalmanFilter"><code>KalmanFilter</code></a> estimates the arrival covariance (customizable).</li><li>Else, a nonlinear program with dense <a href="https://juliadiff.org/ForwardDiff.jl/stable/#ForwardDiff"><code>ForwardDiff</code></a> automatic differentiation (AD) compute the objective and constraint derivatives by default  (customizable). Optimizers generally benefit from exact derivatives like AD. However,  the <code>f</code> and <code>h</code> functions must be compatible with this feature. See the  <a href="https://jump.dev/JuMP.jl/stable/manual/nonlinear/#Common-mistakes-when-writing-a-user-defined-operator"><code>JuMP</code> documentation</a> for common mistakes when writing these functions. Also, an <a href="#UnscentedKalmanFilter"><code>UnscentedKalmanFilter</code></a> estimates the arrival covariance by default.</li></ul><p>The slack variable <span>$ϵ$</span> relaxes the constraints if enabled, see <a href="../generic_func/#ModelPredictiveControl.setconstraint!"><code>setconstraint!</code></a>.  It is disabled by default for the MHE (from <code>Cwt=Inf</code>) but it should be activated for problems with two or more types of bounds, to ensure feasibility (e.g. on the estimated state <span>$\mathbf{x̂}$</span> and sensor noise <span>$\mathbf{v̂}$</span>). Note that if <code>Cwt≠Inf</code>, the attribute <code>nlp_scaling_max_gradient</code> of <code>Ipopt</code> is set to  <code>10/Cwt</code> (if not already set),  to scale the small values of <span>$ϵ$</span>. Use the second constructor to specify the arrival covariance estimation method.</p></div></details></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/b12125e6c0b8439a3919d56061b1293b01f714c3/src/estimator/mhe/construct.jl#L194-L375">source</a></section><section><div><pre><code class="language-julia hljs">MovingHorizonEstimator(
    model, He, i_ym, nint_u, nint_ym, P̂_0, Q̂, R̂, Cwt=Inf;
    optim=default_optim_mhe(model), 
    gradient=AutoForwardDiff(),
    jacobian=AutoForwardDiff(),
    direct=true,
    covestim=default_covestim_mhe(model, i_ym, nint_u, nint_ym, P̂_0, Q̂, R̂; direct)
)</code></pre><p>Construct the estimator from the augmented covariance matrices <code>P̂_0</code>, <code>Q̂</code> and <code>R̂</code>.</p><p>This syntax allows nonzero off-diagonal elements in <span>$\mathbf{P̂_i}, \mathbf{Q̂, R̂}$</span>, where <span>$\mathbf{P̂_i}$</span> is the initial estimation covariance, provided by <code>P̂_0</code> argument. The keyword argument <code>covestim</code> also allows specifying a custom <a href="#StateEstimator"><code>StateEstimator</code></a> object for the estimation of covariance at the arrival <span>$\mathbf{P̂}_{k-N_k}(k-N_k+p)$</span>. The supported types are <a href="#KalmanFilter"><code>KalmanFilter</code></a>, <a href="#UnscentedKalmanFilter"><code>UnscentedKalmanFilter</code></a> and  <a href="#ExtendedKalmanFilter"><code>ExtendedKalmanFilter</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/b12125e6c0b8439a3919d56061b1293b01f714c3/src/estimator/mhe/construct.jl#L415-L433">source</a></section></article><h2 id="InternalModel"><a class="docs-heading-anchor" href="#InternalModel">InternalModel</a><a id="InternalModel-1"></a><a class="docs-heading-anchor-permalink" href="#InternalModel" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.InternalModel" href="#ModelPredictiveControl.InternalModel"><code>ModelPredictiveControl.InternalModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InternalModel(model::SimModel; i_ym=1:model.ny, stoch_ym=ss(I,I,I,I,model.Ts))</code></pre><p>Construct an internal model estimator based on <code>model</code> (<a href="../sim_model/#LinModel"><code>LinModel</code></a> or <a href="../sim_model/#NonLinModel"><code>NonLinModel</code></a>).</p><p><code>i_ym</code> provides the <code>model</code> output indices that are measured <span>$\mathbf{y^m}$</span>, the rest are  unmeasured <span>$\mathbf{y^u}$</span>. <code>model</code> evaluates the deterministic predictions  <span>$\mathbf{ŷ_d}$</span>, and <code>stoch_ym</code>, the stochastic predictions of the measured outputs  <span>$\mathbf{ŷ_s^m}$</span> (the unmeasured ones being <span>$\mathbf{ŷ_s^u=0}$</span>). The predicted outputs sum both values : <span>$\mathbf{ŷ = ŷ_d + ŷ_s}$</span>. See the Extended Help for more details. This estimator is allocation-free is <code>model</code> simulations do not allocate.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>InternalModel</code> estimator does not work if <code>model</code> is integrating or unstable. The  constructor verifies these aspects for <code>LinModel</code> but not for <code>NonLinModel</code>. Uses any  other state estimator in such cases.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; estim = InternalModel(LinModel([tf(3, [30, 1]); tf(-2, [5, 1])], 0.5), i_ym=[2])
InternalModel estimator with a sample time Ts = 0.5 s, LinModel and:
 1 manipulated inputs u
 2 estimated states x̂
 1 measured outputs ym
 1 unmeasured outputs yu
 0 measured disturbances d</code></pre><p><strong>Extended Help</strong></p><details class="admonition is-details"><summary class="admonition-header">Extended Help</summary><div class="admonition-body"><p><code>stoch_ym</code> is a <code>TransferFunction</code> or <code>StateSpace</code> object that models disturbances on <span>$\mathbf{y^m}$</span>. Its input is a hypothetical zero mean white noise vector. <code>stoch_ym</code>  supposes 1 integrator per measured outputs by default, assuming that the current stochastic estimate <span>$\mathbf{ŷ_s^m}(k) = \mathbf{y^m}(k) - \mathbf{ŷ_d^m}(k)$</span> is constant in the  future. This is the dynamic matrix control (DMC) strategy, which is simple but sometimes too aggressive. Additional poles and zeros in <code>stoch_ym</code> can mitigate this. The following block diagram summarizes the internal model structure.</p><p><img src="../../assets/imc.svg" alt="block diagram of the internal model structure"/></p></div></details></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/b12125e6c0b8439a3919d56061b1293b01f714c3/src/estimator/internal_model.jl#L65-L104">source</a></section></article><h2 id="Default-Model-Augmentation"><a class="docs-heading-anchor" href="#Default-Model-Augmentation">Default Model Augmentation</a><a id="Default-Model-Augmentation-1"></a><a class="docs-heading-anchor-permalink" href="#Default-Model-Augmentation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelPredictiveControl.default_nint" href="#ModelPredictiveControl.default_nint"><code>ModelPredictiveControl.default_nint</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">default_nint(model::LinModel, i_ym=1:model.ny, nint_u=0) -&gt; nint_ym</code></pre><p>Get default integrator quantity per measured outputs <code>nint_ym</code> for <a href="../sim_model/#LinModel"><code>LinModel</code></a>.</p><p>The arguments <code>i_ym</code> and <code>nint_u</code> are the measured output indices and the integrator quantity on each manipulated input, respectively. By default, one integrator is added on each measured outputs. If <span>$\mathbf{Â, Ĉ}$</span> matrices of the augmented model become unobservable, the integrator is removed. This approach works well for stable, integrating and unstable <code>model</code> (see Examples).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; model = LinModel(append(tf(3, [10, 1]), tf(2, [1, 0]), tf(4,[-5, 1])), 1.0);

julia&gt; nint_ym = default_nint(model)
3-element Vector{Int64}:
 1
 0
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/b12125e6c0b8439a3919d56061b1293b01f714c3/src/estimator/construct.jl#L230-L251">source</a></section><section><div><pre><code class="language-julia hljs">default_nint(model::SimModel, i_ym=1:model.ny, nint_u=0)</code></pre><p>One integrator on each measured output by default if <code>model</code> is not a  <a href="../sim_model/#LinModel"><code>LinModel</code></a>.</p><p>Theres is no verification the augmented model remains observable. If the integrator quantity per manipulated input <code>nint_u ≠ 0</code>, the method returns zero integrator on each measured output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ModelPredictiveControl.jl/blob/b12125e6c0b8439a3919d56061b1293b01f714c3/src/estimator/construct.jl#L265-L273">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>also denoted <span>$\mathbf{x̂}_{k|k}$</span> <a href="https://en.wikipedia.org/wiki/Kalman_filter">elsewhere</a>.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>M. Hovd (2012), &quot;A Note On The Smoothing Formulation Of Moving Horizon Estimation&quot;,   <em>Facta Universitatis</em>, Vol. 11 №2.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sim_model/">« Plant Models</a><a class="docs-footer-nextpage" href="../predictive_control/">Predictive Controllers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Saturday 19 April 2025 18:05">Saturday 19 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
